\documentclass[hyperref={unicode=true}]{beamer}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}

\usepackage{multicol}

\usepackage[pgf]{dot2texi}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows}

\usepackage{listings}
\usepackage{graphicx}

\usepackage{comment}

\title{Лекция 11. Фрейм функции. Язык спецификации ACSL.}
\author{}
\date{}

\usetheme{Warsaw}

\AtBeginSection[] {
	\begin{frame}{Содержание}
		\tableofcontents[currentsection]
	\end{frame}
}
%\overfullrule=5pt

\begin{document}
	\begin{frame}{}
		\titlepage
	\end{frame}

    \begin{frame}{Цель лекции}
    Обсудить вопросы спецификации Си-программ.
    \end{frame}

    \section{Фрейм функции (footprint)}

    \begin{frame}{Мотивация}
    \begin{itemize}
    \item
    Вы уже написали функцию, заменяющую
    одно значение на другое значение в массиве.
    \item
    Напишите еще одну функцию, чтобы проверить
    спецификацию первой функции. Функция принимает
    на вход массив (указатель на начало и размер)
    и 3 значения \texttt{v0, v1, v2}. Размер массива
    не должен быть меньше 2. Постусловие функции --
    что 0-й элемент массива становится равным
    \texttt{v0}, а 1-й элемент массива становится
    равным \texttt{v2}. Функция сначала присваивает
    в 0-й элемент массива значение \texttt{v0},
    в 1-й элемент массива значение \texttt{v1},
    затем вызывает первую функцию для части массива,
    с 1-го элемента до его конца.
    \item
    Почему одно из условий постусловия не доказывается?
    \end{itemize}
    \end{frame}

    \begin{frame}{Фрейм функции}
    \begin{itemize}
    \item
    В спецификации первой функции не сказано, что
    может делать функция за рамками переданного массива.
    Значит, она может делать что угодно.
    \item
    Необходимо думать о границах области памяти (рамке,
    фрейме, footprint), которую разрешено изменять функции.
    \item
    Добавьте соответствующее постусловие к первой функции.
    \item
    Проверьте, что если второй функции передать еще один массив
    и с ним вторая функция ничего не делает, то этот факт
    доказывается!
    \end{itemize}
    \end{frame}

    \section{Система Frama-C}

    \begin{frame}{Frama-C}
    \begin{itemize}
    \item Система статического анализа Си-программ.
    \item Состоит из ядра и плагинов. Ядро -- это фронтенд
    анализа, плагин -- бекэнд анализа.
    \item Один из плагинов (AstraVer) -- дедуктивная верификация.
    \item Плагины могут взаимодействовать друг с другом
    для компенсации недостатков друг друга. Пример:
    есть плагин, который сам выводит несложные инварианты цикла,
    и уже на этой основе другой плагин сообщает об ошибке.
    Всё это делается полностью автоматически.
    \item \texttt{frama-c -av file.c ...}
    \end{itemize}
    \end{frame}

    \begin{frame}{Работа на уровне исходного кода}
    \begin{itemize}
    \item Исходный код может быть снабжен аннотациями
    для более точного анализа. Для дедуктивной верификации
    аннотациями записывается спецификация, инварианты цикла
    и т.п.
    \item Причем пользователь Frama-C работает
    исключительно на уровне исходного кода (иначе будет тяжело
    автоматизировать комбинирование плагинов).
    \item На уровне исходного кода не доступна его модель на WhyML.
    Эта модель может иметь существенные особенности по сравнению
    с исходным Си-кодом, важные для верификации.
    \end{itemize}
    \end{frame}

    \begin{frame}{Модель кода WhyML не доступна}
    \begin{itemize}
    \item (-) Например, нельзя написать лемму, в которой
    используются функциональные символы из модели памяти.
    \item (+) Плагин \textsl{AstraVer} может самостоятельно
    строить модель программы, применяя различные
    оптимизации для более эффективной верификации.
    \end{itemize}
    \end{frame}

    \section{Язык ACSL}

    \begin{frame}{Что такое ACSL}
    \begin{itemize}
    \item
    ACSL -- ANSI/ISO C Specification Language.
    \item
    Frama-C использует подмножество языка ACSL.
    \item
    Исходный код дополняется \emph{аннотациями}:
    комментариями \texttt{/*@ ... */}
    \end{itemize}
    \end{frame}

    \begin{frame}{Аннотации ACSL для спецификации функции}
    Спецификация функции -- это аннотация, которая
    расположена перед заголовком функции.
    \begin{itemize}
    \item
    requires expr; -- предусловие (можно несколько requires или ни одного)
    \item
    ensures expr; -- постусловие (можно несколько ensures или ни одного)
    \item
    decreases expr; -- оценочная функция для рекурсивной функции
    (фундированное множество -- то же, что в WhyML)
    \item
    Синтаксис выражений похож на WhyML, но он сделан более
    похожим на Си (синтаксис кванторов!).
    \end{itemize}
    \end{frame}

    \begin{frame}{Типы данных}
    \begin{itemize}
    \item
    \texttt{integer} -- бесконечный целый тип (только для спецификаций)
    \item
    Все Си-шные типы тоже есть
    \item
    В операциях с \texttt{int} и \texttt{integer} происходит преобразование
    \texttt{int} к \texttt{integer}
    \end{itemize}
    \end{frame}

    \begin{frame}{Модель памяти недоступна}
    \begin{itemize}
    \item
    Типы-символы, функциональные и предикатные символы
    модели памяти для одного вида анализа может не подходить
    для другого вида анализа, поэтому язык ACSL старается
    включать только общие возможности разных моделей памяти
    \item
    Наша модель памяти недоступна (типы-символы, функциональные
    и предикатные символы, аксиомы и леммы)
    \item
    Поэтому в спецификациях для указателей
    надо использовать Си-шное разыменование, сложение, вычитание,
    сравнение.
    \end{itemize}
    \end{frame}

    \begin{frame}{At, Old, метки памяти}
    \begin{itemize}
    \item
    Есть конструкции \texttt{\textbackslash{}old}, \texttt{\textbackslash{}at}
    \item
    Метки памяти -- это Си-метки + \texttt{Pre}, \texttt{Here}, \texttt{Post}
    \item
    Не путать \texttt{\textbackslash{}at(*p,L)} и \texttt{*\textbackslash{}at(p,L)}
    \end{itemize}
    \end{frame}

    \begin{frame}{Спецификация фрейма функции}
    \begin{itemize}
    \item
    Модель памяти недоступна, поэтому для фрейма ввели
    дополнительные части спецификации функции:
    \item
    assigns Locations; -- валидная память за пределами Locations
    не меняет своего значения при выходе из функции
    \item
    allocates Locations; -- валидная память за пределами Locations
    не меняет своего статуса аллоцированности при выходе из функции
    (если была освобождена, остается освобожденной; была выделенной,
     остается выделенной); Locations вычисляется в состоянии памяти
    при возврате из функции
    \item
    frees Locations; -- то же, что allocates, но Locations
    вычисляется при входе в функцию
    \end{itemize}
    \end{frame}

    \begin{frame}{Спецификация циклов}
    \begin{itemize}
    \item
    Аннотация цикла записывается перед циклом. Точки сечения,
    фундированное множество -- те же, что в WhyML.
    \item
    \texttt{loop invariant expr;} -- индуктивное утверждение
    (может быть несколько или отсутствовать)
    \item
    \texttt{loop variant expr;} -- оценочная функция
    (если ее нет, то она равна 0)
    \item
    \texttt{loop assigns Locations;} -- фрейм цикла
    \end{itemize}
    \end{frame}

    \begin{frame}{Символы}
    \begin{itemize}
    \item
    Можно вводить свои символы!
    \item
    Типы-символы, функциональные и предикатные символы, аксиомы
    пишутся в аннотациях \texttt{axiomatic}
    \item
    Функциональный символ начинается со слова \texttt{logic}
    \item
    Предикатный символ начинается со слова \texttt{predicate}
    \item
    Аксиома начинается со слова \texttt{axiom}
    \item
    Полиморфные типы не поддерживаются
    \end{itemize}
    \end{frame}

    \begin{frame}{Снова без модели памяти}
    \begin{itemize}
    \item
    Модель памяти не доступна даже в axiomatic, это нужно учитывать.
    \item
    Если нужны метки памяти для функциональных и предикатных символов,
    их надо писать в фигурных скобках после имени символа, а потом
    использовать в конструкции \texttt{\textbackslash{}at}.
    \item
    Меток может быть несколько -- и это удобно! (для разыменования
            каждого указателя своя метка -- и можно использовать
            такой предикатный символ в очень разном контексте,
            не создавая много однотипных предикатных символов)
    \end{itemize}
    \end{frame}

    \begin{frame}{Но есть предикаты, входящие в язык}
    \begin{itemize}
    \item
    \texttt{\textbackslash{}valid} -- валидность указателя
    \item
    \texttt{\textbackslash{}offset\_min}, \texttt{\textbackslash{}offset\_max}
    \item
    \texttt{\textbackslash{}base\_addr} (правда, AstraVer транслирует
    только равенство двух base\_addr -- это  проверка, что два
    указателя находятся в одном блоке)
    \item
    \texttt{\textbackslash{}allocable}, \texttt{\textbackslash{}freeable}
    \end{itemize}
    \end{frame}

    \begin{frame}{Аннотации для верификации}
    \begin{itemize}
    \item
    \texttt{assert expr;}
    \item
    \texttt{ghost}-метки и локальные переменные (тип - только Си-шный),
    \texttt{ghost}-блоки (только с Си-шным кодом): это из-за того, что
    в Frama-C фронтенд кода принимает только Си-код (не ghost-аннотация
    анализируется фронтендом отдельно, поэтому с ней нет этих проблем)
    \item
    \texttt{ghost}-функции
    \item
    \texttt{lemma} -- леммы
    \end{itemize}
    \end{frame}

    \begin{frame}{Behavior}
    \begin{itemize}
    \item
    Можно указать у assert, что он нужен для доказательства
    определенной аннотации ensures
    \item
    То же можно сделать с loop invariant
    \item
    Ensures надо поместить в behavior
    \item
    Синтаксис смотрите в документации по ACSL
    \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Лемма-функции}
    Пример:

    \begin{lstlisting}
/*@ ghost
     /@ lemma
          requires ....
          ensures ....
     @/
     void lemmafunction(....) {
      ....
     }
*/
    \end{lstlisting}
    \end{frame}

    \begin{frame}{Построение теорий WhyML и их зависимости}
    \begin{itemize}
    \item
    Каждый axiomatic и глобальная лемма становятся
    отдельной теорией.
    \item
    В теорию импортируются все теории, в которых
    объявляются символы, используемые в первой теории.
    \item
    Для более тонкого управления импортированием
    надо объявить символ и воспользоваться им в нужном месте.
    \item
    В условиях верификации используются все леммы,
    расположенные до верифицируемой функции.
    \end{itemize}
    \end{frame}

    \begin{frame}{Триггеры}
    \begin{itemize}
    \item
    В кванторах ACSL нет триггеров.
    \item
    Солвер будет выбирать триггер, исходя из квантора, каким
    он будет в WhyML! Квантор может сильно отличаться
    от его ACSL-варианта.
    \end{itemize}
    \end{frame}

    \begin{frame}{Переносимость Си-программ и верификации}
    \begin{itemize}
    \item
    В Си размеры типов выбирает платформа, а не язык.
    \item
    Frama-C фиксирует размеры типов во фронтенд анализе
    (опциями можно настраивать эти размеры). Дедуктивная
    верификация делается с этими размерами типов.
    \item
    Последовательность вычислений тоже фиксируется
    фронтендом Frama-C.
    \end{itemize}
    \end{frame}

    \begin{frame}{Глобальные инварианты}
    \begin{itemize}
    \item
    Это утверждения, которые выполнены всегда, когда
    программа находится в определенной точке программы
        \begin{itemize}
        \item строгие - везде
        \item слабые - при вызове и при возврате из
        каждой функции
        \end{itemize}
    \item Инвариант глобальных переменных:
    \begin{block}{}
    \texttt{global invariant positive: size >= 0;}
    \end{block}
    \item Инвариант (каждой переменной) типа:
    \begin{block}{}
    \texttt{type invariant valid\_array (Array *a) =
    a->size >= 0 \&\& \textbackslash{}valid(a->data + (0 .. a->size - 1));}
    \end{block}
    \end{itemize}
    \end{frame}

    \begin{frame}{Проблемы глобальных инвариантов}
    \begin{itemize}
    \item
    Пусть у некоторого типа должен быть инвариант.
    У любой ли функции этот инвариант должен быть
    выполнен хотя бы в слабом смысле?
    \item
    Для функции-конструктора? (а что это в Си?)
    \item
    Для функции-деструктора? (а что это в Си?)
    \item
    Для вспомогательной функции, вызываемой из
    <<публичной>> функции? Любой такой вспомогательной
    функции?
    \end{itemize}
    \end{frame}

    \begin{frame}{Подход AstraVer}
    \begin{itemize}
    \item
    Надо точнее специфицировать, когда должен быть
    выполнен глобальный инвариант. Вводить дополнительные
    конструкции в язык спецификации?
    \item
    В AstraVer глобальные инварианты не
    вставляются автоматически в спецификации функций!
    \item
    Это просто предикаты, которые надо явно
    указать в спецификациях нужных функций.
    \end{itemize}
    \end{frame}

    \begin{frame}{И это не все проблемы}
    \begin{itemize}
    \item
    Пусть некоторый тип является частью другого типа.
    Причем не все корректные значения внутреннего
    типа являются допустимыми в рамках внешнего типа.
    \item
    Каков должен быть инвариант внутреннего типа?
    Как доказать, что модификация переменной
    внутреннего типа не нарушает инварианта
    переменной внешнего типа, если нет доступа
    до переменной внешнего типа?
    \item
    До сих пор нет лучшего ответа на этот вопрос.
    \end{itemize}
    \end{frame}
\end{document}
