\documentclass[hyperref={unicode=true}]{beamer}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}

\usepackage{multicol}

\usepackage[pgf]{dot2texi}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows}

\usepackage{listings}
\usepackage{graphicx}

\usepackage{comment}

\title{Лекция 8. Добавление новых типов и функций}
\author{}
\date{}

\usetheme{Warsaw}

\AtBeginSection[] {
	\begin{frame}{Содержание}
		\tableofcontents[currentsection]
	\end{frame}
}
%\overfullrule=5pt

\begin{document}
	\begin{frame}{}
		\titlepage
	\end{frame}

    \begin{frame}{Цель лекции}
    Научиться описывать новые типы данных и
    новые функции, для которых нет теории в SMT-солвере.
    Понять, как моделировать типы языков
    программирования при создании модели программы.
    Увидеть отличия между языком спецификации и
    языком программирования. ((в одном неисполнимые термы и
                символьные преобразования и невыводимость,
                в другом исполнимые конструкции и ошибки с исключениями))
    \end{frame}


% функциональный символ с аксиомами - как квантор существования, только нагляднее
% но при функциональном символе нет явной леммы о непротиворечивости аксиом!
% а при кванторе существования нам нужно было доказать лемму о существовании кв.корня

    \begin{frame}{Добавление типов}
    \begin{itemize}
    \item
    Пока мы использовали только целые числа, но этого
    недостаточно для моделирования памяти программы, например.
    \item
    Можно ли обойтись только теми типами, которые заранее
    определены в библиотеке языка, и не определять свои типы?
    \item
    Мы будем определять типы самостоятельно. Что такое тип?
    \end{itemize}
    \end{frame}

    \begin{frame}{Для чего нужны типы?}
    \begin{itemize}
    \item
    В языке программирования (для компилятора):
    определить, сколько памяти надо выделить под переменную,
    определить нужные коды операций (они могут зависеть
            от типа операндов)
    \item
    В модели программы?
    В языке спецификации?
    Исключительно для методов Флойда: домены, выражения,
    предикаты. Это символьная природа в отличие от
    исполнимой природы типов данных в языках программирования.
    \end{itemize}
    \end{frame}

    \section{Немного матлогики}

    \begin{frame}{Типы-символы, функциональные символы}
    Вспомним из курса математической логики (там были символы):
    \begin{itemize}
    \item
    Есть функциональные символы и символы-константы.
    Из них можно составлять термы.
    \item
    Есть типы-символы. Они ограничивают допустимые термы.
    Каждому символу-константе сопоставлен тип-символ.
    Каждому функциональному символу сопоставлены типы-символы
    для аргументов и результата.
    \item
    Есть предикатные символы, логические связки и кванторы.
    Из них (используя переменные) можно составить формулы.
    \end{itemize}
    \end{frame}

    \begin{frame}{Аксиомы и правила вывода}
    Чисто символьная задача -- проверка выводимости:
    \begin{itemize}
    \item
    Задаются правила получения некоторых формул из некоторых других
    -- правила вывода.
    \item
    Задается множество замкнутых формул -- аксиомы.
    \item
    Задается замкнутая формула -- цель.
    \item
    Надо проверить, можно ли использовать только правила вывода,
    чтобы из аксиом получить цель.
    \end{itemize}
    \end{frame}

    \begin{frame}{Значения формул, модели}
    \begin{itemize}
    \item
    Но пока это лишь символьные преобразования. Оставаясь
    только с символьными преобразованиями, мы не можем
    использовать солверы (можем только пруверы) и трудно
    установить связь с типами данных в языках программирования.
    Нужны значения формулам.
    \item
    Модель -- это сопоставление множеств типам-символам,
    функций -- функциональным символам и предикатным символам,
    констант -- символам-константам. Задав модель, у терма
    и формул появляются значения.
    \item
    Общезначимая формула -- истинная при всех моделях.
    \item
    Выполнимая формула -- истинная хотя бы при одной модели.
    \end{itemize}
    \end{frame}

    \begin{frame}{Логическое следствие}
    \begin{itemize}
    \item
    Формула-цель является логическим следствием формул-аксиом,
    если в любой модели, где истинны все формулы-аксиомы,
    истинна формула-цель.
    \item
    Пример цели -- условие верификации.
    \item
    SMT-солверы умеют <<имитировать>> пруверы, т.е.
    SMT-солвер может решать задачу определения логического следствия.
    \item
    Для этого ищется модель для формул-аксиом и отрицания формулы-цели.
    Есть модель -- нет логического следствия. Нет модели
    -- есть логическое следствие.
    \end{itemize}
    \end{frame}

    \section{Теория неинтерпретируемых функций}

    \begin{frame}{Теория неинтерпретируемых функций}
    \begin{itemize}
    \item
    Обычно в формулах для SMT-солверов используются числа,
    битовые вектора и т.п. То есть домены с операциями,
    определения (модель) которых известны солверу.
    А для функциональных и предикатных символов модели нет.
    \item
    Если SMT-солвер умеет строить модели для символов,
    про него говорят, что он поддерживает
    теорию неинтерпретируемых функций (\textsl{UF}).
    \item
    Продемонстрируем, как может работать такой солвер.
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример работы UF-солвера}
    Надо доказать или опровергнуть следующее
    логическое следствие:
    \begin{itemize}
    \item
    Символы: \texttt{a, b, c} из домена $\mathbb{Z}$,
    \texttt{f} из домена $\mathbb{Z}\times\mathbb{Z}
    \rightarrow \mathbb{Z}$.
    \item
    Аксиомы: \texttt{f(a, f(b, c)) != f(a, b)},
    \texttt{f(b, b) = c}
    \item
    Цель: \texttt{f(a, b) = a}
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример::шаг 1}
    Делаем отрицание цели и получаем множество формул,
    для которых надо искать модель (противоречие):

    \begin{itemize}
    \item \texttt{f(a, f(b, c)) != f(a, b)}
    \item \texttt{f(b, b) = c}
    \item \texttt{f(a, b) != a}
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример::шаг 2}
    Введем новые переменные, чтобы убрать термы с более чем одним
    функциональным символом и чтобы функциональные символы
    входили только в равенства:

    \begin{itemize}
    \item \texttt{v1 = f(b, c), v2 = f(a, v1),
        v3 = f(a, b), c = f(b, b)}
    \item \texttt{v2 != v3, v3 != a}
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример::шаг 3}
    Уберем функциональные символы совсем. Для этого надо
    применить следующее простейшее правило функции:
    $\forall x \forall y ~ x = y \Rightarrow f(x) = f(y)$
    и перебрать только те переменные вместо $x$ и $y$,
    которые являются операндами функциональных символов.

    \begin{itemize}
    \item \texttt{a = b $\land$ c = v1 -> v1 = v2}
    \item \texttt{a = b $\land$ b = c -> v3 = v1}
    \item \texttt{b = c -> c = v1}
    \item \texttt{b = v1 -> v2 = v3}
    \item \texttt{a = b $\land$ v1 = b -> c = v2}
    \item \texttt{a = b -> c = v3}
    \item \texttt{v2 != v3}
    \item \texttt{v3 != a}
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример::шаг 4}
    Осталось перебрать все варианты разбиения множества
    символов \texttt{a, b, c, v1, v2, v3} на классы
    эквивалентности по равенству, чтобы в одном классе
    не оказались переменные, не равные друг другу.
    Если таких разбиений нет, то исходное логическое
    следствие доказано. Если разбиение есть, то найден
    контрпример, исходное логическое следствие не имеет места.

    Обычно эту задачу сводят к задаче SAT, обозначая равенство
    каждой пары переменных отдельной булевской переменной,
    добавляя аксиомы равенства в виде еще одних конъюнктов.
    \end{frame}

    \begin{frame}{Пример::ответ}
    В этом примере есть разбиение на классы эквивалентности:
    \texttt{a = b, c = v3, v1 = v2}. Значит, логического
    следствия нет.
    \end{frame}

    \section{UF в WhyML}

    \begin{frame}{Синтаксис}
    \begin{itemize}
    \item
    Тип-символ: \texttt{type T} (нет равенства после имени типа)
    \item
    Функциональный символ: \texttt{function sqrt (x: int): int}
    (нет равенства после этого заголовка)
    \item
    Предикатный символ: \texttt{predicate empty (x: T)}
    \item
    Аксиома: \texttt{axiom sqrtDef: forall x. sqrt x >= x}
    \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Аксиомы}
    \begin{itemize}
    \item
    Нужно быть крайне осторожными при определении аксиом!
    \item
    Пример аксиомы для символа квадратного корня:
    \begin{lstlisting}
    function sqrt (x: int): int
    axiom sqrtDef: forall x.
         sqrt x * sqrt x <= x
              < (sqrt x + 1) * (sqrt x + 1)
    \end{lstlisting}
    \end{itemize}
    \end{frame}

    \begin{frame}{Проверка аксиомы}
    \begin{itemize}
    \item
    Любая модель для sqrt -- это функция из $\mathbb{Z}$ в $\mathbb{Z}$.
    \item
    Чему равно (sqrt 0) во всех моделях? Используем аксиому:
    sqrt 0 * sqrt 0 <= 0 < (sqrt 0 + 1) * (sqrt 0 + 1).
    Т.к. квадрат sqrt 0 не может быть отрицательным числом, то
    во всех моделях sqrt 0 равно 0. Аксиома правильная.
    \item
    Чему равно (sqrt 10) во всех моделях?
    (sqrt 10) * (sqrt 10) <= 10 < (sqrt 10 + 1) * (sqrt 10 + 1).
    Значит, значение (sqrt 10) может равняться только 3.
    \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Продолжаем проверять аксиому}
    \begin{itemize}
    \item
    Чему равно (sqrt -1) во всех моделях? Аксиома утверждает, что:
    (sqrt -1) * (sqrt -1) <= -1 < (sqrt -1 + 1) * (sqrt -1 + 1).
    Но таких (sqrt -1) не существует. То есть нет ни одной модели
    для символа sqrt с такой аксиомой. Аксиома противоречива. Это плохо.
    \item
    Исправляем аксиому:
    \begin{lstlisting}
    function sqrt (x: int): int
    axiom sqrtDef: forall x. x >= 0 ->
         sqrt x * sqrt x <= x
              < (sqrt x + 1) * (sqrt x + 1)
    \end{lstlisting}
    \end{itemize}
    \end{frame}

    \begin{frame}
    \begin{itemize}
    \item
    Теперь аксиома для (sqrt -1) истинна при любой модели. Что это дает?
    \item
    Может быть надо считать, что (sqrt -1) равно некой $\omega$? Ведь
    нельзя определить квадратный корень от -1. И считать, что в каждом
    типе есть $\omega$.
    \item
    Но добавление $\omega$ усложняет формулы, а для символьных операций
    необходимы как можно более простые формулы.
    \item
    Более того, $\omega$ не нужна, т.к. и без нее при такой аксиоме
    никакие интересные формулы про
    квадратный корень от отрицательных чисел доказать нельзя.
    Далее смотрите примеры.
    \end{itemize}
    \end{frame}

    \begin{frame}{Примеры формул с недоопределенными символами}
    Являются ли логическим следствием указанной выше аксиомы
    следующие формулы?
    \begin{itemize}
    \item
    \texttt{forall x. sqrt x >= 0}?
    Нет.
    \item
    \texttt{forall x. sqrt x < 0}?
    Тоже нет.
    \item
    \texttt{forall x. sqrt x = sqrt x}?
    Да, но она неинтересна.
    \item
    \texttt{forall x. x >= 0 -> sqrt x >= 0}?
    Да, но она не использует sqrt от отрицательных чисел.
    \end{itemize}
    \end{frame}

    \begin{frame}{Интересный вопрос}
    \begin{itemize}
    \item
    Можно ли алгоритмически определить выполнимость аксиом?
    То есть что существует хотя бы одна модель, в которой все аксиомы
    истинны.
    \item
    Если модели нет, то любые формулы будут логическими следствиями
    этого набора аксиом. Но какой смысл в таком следствии?..
    \end{itemize}
    \end{frame}

    \section{UF в блок-схемах}

    \begin{frame}{Частично-определенные символы в формулах}
    \begin{itemize}
    \item
    Нет ли ошибки в этой формуле? Если такая формула будет
    целью (например, это условие верификации), то надо ли
    генерировать дополнительную цель, что все <<вызовы>>
    sqrt делаются только для неотрицательных аргументов?
    \texttt{forall x a. a = sqrt x -> a * a <= x}
    \item
    Ответ: в формуле ошибки нет, формула -- это просто <<текст>>.
    Ошибка в формуле может быть лишь синтаксической (например,
    аргументов больше, чем в заголовке функционального символа sqrt).
    Эта формула не является логическим следствием аксиомы.
    Генерировать дополнительные условия не нужно, т.к. нет
    какой-либо последовательности действий, вычислений.
    \end{itemize}
    \end{frame}

    \begin{frame}{Частично-определенные символы в блок-схемах}
    \begin{itemize}
    \item
    А вот в блок-схемах есть последовательность действий.
    Например, если в операторе ASSIGN надо использовать
    квадратный корень. Тогда в блок-схеме надо перед этим ASSIGN
    добавить CALL со взятием квадратного корня. Сопоставить
    квадратному корню спецификацию с предусловием. И тогда
    согласно методам Флойда будет построено условие верификации
    о том, что квадратный корень не берется от отрицательных чисел.
    \item
    Это же касается машинной арифметики (предотвращение арифметического
            переполнения), адресной арифметики (разыменование
                невалидного указателя) и т.п.
    \end{itemize}
    \end{frame}

    \begin{frame}{val-примитивы}
    \begin{itemize}
    \item
    Что надо написать, чтобы в блок-схеме (let-функции) пользоваться
    типами данных, которые мы дополнительно определяем?
    \item
    Наличия \texttt{type}, \texttt{function}, \texttt{predicate}
    недостаточно, если надо доказывать корректность использования
    операций над типом данных
    \item
    Тогда надо написать val объявления (\emph{val-примитивы}) - простейшие
    операции, необходимые для программирования с этим типом данных
    \item
    У каждого val-примитива должна быть спецификация -- указываем
    у нее предусловие -- и будут генерироваться условия верификации
    о корректности каждого использования этого примитива (предусловие
    val-объявления выполнено)
    \end{itemize}
    \end{frame}

\end{document}
