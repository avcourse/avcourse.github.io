\documentclass[hyperref={unicode=true}]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}

%\usepackage{listings}
%\usepackage{graphicx}

%\usepackage{comment}

\title{Лекция 7. Некоторые специальные методы доказательства в AstraVer}
\author{}
\date{}

\usetheme{Warsaw}

\AtBeginSection[] {
	\begin{frame}{Содержание}
		\tableofcontents[currentsection]
	\end{frame}
}
%\overfullrule=5pt

\begin{document}
	\begin{frame}{}
		\titlepage
	\end{frame}

    \begin{frame}{Цель лекции}
    Показать ряд приемов доказательства, поддерживающих инструментом AstraVer, остающихся
    в рамках (автоматических) солверов. Основная идея --- добавлять в код аннотации, которые
    нужны только для верификации. Такой подход называется \texttt{auto-active verification}.
    \end{frame}

    \section{Ghost-функции}

    \begin{frame}{Методы Флойда для доказательства по индукции}
    \begin{itemize}
    \item Ранее у нас оставалось недоказанными много лемм, которые можно доказать методом
    математической индукции (ММИ).
    \item Проблема в том, что солверы не могут применять ММИ.
    \item ММИ использовался при доказательстве теоремы корректности метода индуктивных утверждений.
    \item Пусть нам надо доказать некоторое утверждение ММИ. Если можно подобрать функцию на Си,
    полная корректность которой эквивалентна доказываемому утверждению и эту корректность мы доказали
    МИУ, то мы доказали исходное утверждение ММИ.
    \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Ghost-функции}
    Такие дополнительные функции оформляются в ghost-коде. Их спецификация пишется в комментариях
    вида \texttt{/@ ... @/}.

    Пример: тут доказывается, что для любого \texttt{n} типа \texttt{int}, для которого выполнено
    \texttt{R(n)}, выполнено \texttt{E(n)}.

    \begin{verbatim}
    /*@ ghost /@ requires R(n);
                 ensures E(n);
               @/
        void proof(int n) {
            ...
        }
    */
    \end{verbatim}
    \end{frame}

    \begin{frame}{Использование доказанных утверждений}
    Чтобы воспользоваться доказанным утверждением, нужно в определенном месте в коде на Си вызвать
    ghost-функцию. Поскольку она ghost, то это надо делать внутри ghost-кода:
    \texttt{/*@ ghost proof(a * b);*/} Для этого вызова будет сгенерировано safety-условие о выполнении
    \texttt{R(a * b);}, а в предикат пути, проходящий через этот вызов функции, будет вставлено
    \texttt{E(a * b);}
    \end{frame}

    \begin{frame}{Пример}
    \begin{itemize}
    \item \texttt{examples\textbackslash what\_more\textbackslash what\_more.c} --- функция подсчета
    количества вхождений. Мы верифицировали эту функцию, но оставили недоказанными одну лемму.
    \item \texttt{examples\textbackslash auto-av\textbackslash what\_more\_ghost.c} --- лемма доказана
    при помощи ghost-функции.
    \end{itemize}
    \end{frame}

    \begin{frame}{Ограничения ghost-функций}
    \begin{itemize}
    \item Они -- все еще Си-функции. Поэтому типами их аргументов должны быть Си-типы (в примере выше
            мы не можем доказать лемму для всех целочисленных \texttt{n}, а лишь для тех, которые
            принадлежат типу \texttt{int}).
    \item Ghost-функция не должна менять состояние памяти (иначе ее нельзя использовать как ghost-функцию,
            так как ее вызов изменит поведение верифицируемой функции). То есть она может работать только
    с одной меткой памяти. А у нас было много утверждений с двумя метками памяти.
    \item Чтобы воспользоваться доказанным утверждением, необходимо вызвать функцию. То есть это нельзя
    сделать в спецификационном коде, т.е. внутри assert, loop invariant.
    \end{itemize}
    \end{frame}

    \begin{frame}{Лемма-функции}
    \begin{itemize}
    \item Это попытка справиться с 3-м ограничением. Это ghost-функция, вначале спецификации которой есть
    ключевое слово \texttt{lemma}. Тогда, помимо прочего, генерируется аксиома с тем же утверждением, что и
    доказывает ghost-функция. Аксиома может быть автоматически применена солвером в разных местах.
    \item Вызов лемма-функции (как ghost-функции) тоже возможен.
    \item \texttt{examples\textbackslash auto-av\textbackslash what\_more\_lf.c} --- доказательство
    леммы при помощи лемма-функции.
    \end{itemize}
    \end{frame}

    \begin{frame}{Дублирование структур данных}
    \begin{itemize}
    \item Чтобы частично справиться с проблемой единственности метки памяти у ghost-функции, можно попробовать
    дублировать структуру данных в ghost-переменную и передавать в ghost-функцию неё вместо метки памяти.
    \item \texttt{examples\textbackslash auto-av\textbackslash selsort.c} --- доказательство леммы в
    сортировке выбором при помощи дублирования структуры данных.
    \end{itemize}
    \end{frame}

    \section{Повышение эффективности солверов}

    \begin{frame}{Почему солвер не справляется?}
    \begin{itemize}
    \item большая цель теории (делаем Split, увеличиваем ограничение по времени на верификацию)
    \item большое условие верификации (много лишнего -- как убрать лишнее?)
    \item неподходящие эвристики в солвере (попробовать другой солвер)
    \item неподходящие формулы, солвер <<зацикливается>> на казалось бы небольших условиях верификации
    \end{itemize}
    \end{frame}

    \begin{frame}{Почему солвер зацикливается?}
    \begin{itemize}
    \item Как солвер <<доказывает>> условия верификации (т.е. что из аксиом следует цель)? Строит отрицание
    цели, составляет его в конъюнкцию с аксиомами и пытается вывести противоречивый конъюнкт.
    \item Если аксиома -- это выражение под квантором всеобщности, то надо <<инстанцировать>> аксиому,
    т.е. подставить какие-то термы вместо подкванторных переменных.
    \item Основная причина <<зацикливания>> солвера --- это постоянное и безуспешное инстанцирование аксиом.
    \end{itemize}
    \end{frame}

    \begin{frame}{Как помочь солверу?}
    \begin{itemize}
    \item Уменьшить количество аксиом с квантором всеобщности
    \item Написать аксиомы по-другому, чтобы сработали эвристики подбора термов для подкванторных переменных
    \end{itemize}
    \end{frame}

    \begin{frame}{Триггеры}
    \begin{itemize}
    \item Это одна из эвристик подбор термов для подкванторных переменных
    \item \emph{Триггер} аксиомы --- это набор нетривиальных шаблонов термов, позволяющий получить термы для всех подкванторных
    переменных этой аксиомы. Тривиальный шаблон --- это просто переменная.
    \item Пример: \texttt{\textbackslash forall integer a, b, c; mul(a, sum(b, c)) == sum(mul(a, b), mul(a, c));}
    --- для этой аксиомы триггером может быть шаблон \texttt{mul(X, sum(Y, Z))}.
    \item Триггер сравнивается со всеми термами (точнее, термами из E-графа), которые получил солвер на данный момент.
    \item В верификации сортировки выбором есть примеры использования триггеров (термы вводятся в assert и ghost-коде).
    \end{itemize}
    \end{frame}

    \begin{frame}{Matching loop}
    \begin{itemize}
    \item Неудачный триггер может привести к зацикливанию солвера.
    \item Пример: \texttt{forall integer x; h(x) ==> h(k(x))}. Если в качестве триггера выбрать \texttt{h(x)}, то как только
    он сработает (\texttt{x := E}), появится формула \texttt{h(E) ==> h(k(E))} и значит терм \texttt{h(k(E))}, который снова
    подходит для триггера и порождается \texttt{h(k(k(E)))} и так до бесконечности.
    \item Такая ситуация называется matching loop.
    \end{itemize}
    \end{frame}

    \begin{frame}{Что можно сделать на уровне ACSL?}
    \begin{itemize}
    \item Уменьшить число assert'ов, совмещая их последовательность в один предикат
    \item Составить лемму, в которой оставить только самые важные утверждения в посылке и цели
    \item Писать аксиомы такого вида, из которых солверы автоматически извлекут полезные триггеры. Синтаксис ACSL
    не позволяет задать триггер в аксиоме или лемме.
    \item Упростить утверждения при помощи ghost-переменных
    \item Разделить assert'ы по \emph{behavior}'ам.
    \end{itemize}
    \end{frame}

    \begin{frame}{Проект VerKer}
    \begin{itemize}
    \item В ИСП РАН ведется дедуктивная верификация исходного кода ядер некоторых операционных систем.
    \item В проекте VerKer верифицированы некоторые функции, оперирующие с буферами (\texttt{string.h}).
    \item Репозиторий проекта --- \url{https://github.com/evdenis/verker}.
    \item Обратите внимание на верификацию функции \texttt{sysfs\_streq} --- ghost-переменные там существенно упрощают условия верификации.
    \end{itemize}
    \end{frame}

    \begin{frame}{Behavior}
    \begin{itemize}
    \item Это синтаксическая конструкция, позволяющая дать имя части спецификации, а затем ссылаться на нее в доказательстве.
    \item Синтаксис см. в ACSL Language Reference.
    \item Можно пометить assert, loop invariant именем behavior (\texttt{for B: ...}), и тогда этот assert и loop invariant будут исключены из
    условий верификации для остальных behavior'ов.
    \item К сожалению, нельзя пометить вызов ghost-функции именем behavior'a.
    \end{itemize}
    \end{frame}

    \begin{frame}{Проекции}
    Если никакие методы сокращения не работают или к тому есть технические препятствия, то можно пробовать генерировать специальные
    варианты верифицируемого кода для доказательства определенного условия верификации, из которых убрано все лишнее. Но тут никакой
    поддержки инструмент уже не окажет.
    \end{frame}
\end{document}
