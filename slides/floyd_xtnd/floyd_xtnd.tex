\documentclass[hyperref={unicode=true}]{beamer}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}

\usepackage{multicol}

\usepackage[pgf]{dot2texi}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows}

\usepackage{listings}
\usepackage{graphicx}

\usepackage{comment}

\title{Лекция 4. Расширение моделей}
\author{}
\date{}

\usetheme{Warsaw}

\AtBeginSection[] {
	\begin{frame}{Содержание}
		\tableofcontents[currentsection]
	\end{frame}
}
%\overfullrule=5pt

\begin{document}
	\begin{frame}{}
		\titlepage
	\end{frame}

    \begin{frame}{Цель лекции}
    Расширить модель программы и модель требований, чтобы приблизить их к Си-программам и требованиям к ним.
    \end{frame}

    \section{Модель программы с вызовами}

    \begin{frame}{Процедурная абстракция}
    <<Процедура -- как черный ящик, в котором скрыт алгоритм за заголовком процедуры. При этом задача, которую должна решать процедура, должна быть известна. Вызывая процедуру, неизвестно, какой из алгоритмов будет в ней. Но в любом случае этот алгоритм должен решать задачу.>>
    \end{frame}

    \begin{frame}{Правила программного контракта}
    \begin{enumerate}
    \item при каждом вызове процедуры ее фактические параметры должны удовлетворять предусловию процедуры.
    \item при каждом возврате из процедуры ее возвращаемое значение удовлетворяет постусловию процедуры.
    \end{enumerate}

    Первое должна обеспечить вызывающая процедура (вызываяемая процедура пользуется этим), второе -- вызываемая процедура (вызывающая процедура этим пользуется).
    \end{frame}

    \begin{frame}{Новый оператор CALL}
    Оператор CALL означает вызов процедуры. Ему приписана имя вызываемой процедуры, функция получения вектора значений входных переменных вызываемой процедуры, функция обработки вектора значений выходных переменных в значения промежуточных переменных вызывающей процедуры. Семантика: вычисление продолжается в вызванную процедуру с поддержкой стека вызовов.

    Предикат пути и функция пути, если в пути встречаются операторы CALL, получают по 1 дополнительному аргументу для каждого возвращаемого значения операторов CALL в этом пути. Предикат пути дополняется постусловиями для каждого оператора CALL.
    \end{frame}

    \begin{frame}{Пример доказательства}
    TBD
    \end{frame}

    \begin{frame}[fragile]{Пример для доказательства}
$D_x = D_y = D_z = \mathbb{Z}$. Доказать, что блок-схема завершается при всех значениях входных переменных таких, что выполнено $\varphi(x) \equiv x \geq 0$. Метод доказательства должен быть автоматизируемым.

\begin{center}
\huge
\begin{dot2tex}[options=-traw]

digraph G{
	d2tgraphstyle="scale=0.3, transform shape";

	/* nodes by levels */
	node[shape=rectangle, height=1];
	START[style=rounded, width=3,texlbl="$\begin{matrix}START:\\ y \leftarrow 0\end{matrix}$"];
    JOIN;
	COND[style=rounded, label="$y = x$"];
	INCR[label="$y \\leftarrow y + 1$"];
	HALT[style=rounded, width=3, texlbl="$\begin{matrix}HALT:\\  z \leftarrow y\end{matrix}$"];


	/* edges */
	node [shape=point, width=0];
	START:s -> JOIN:n;
    JOIN:s -> COND:n;
	COND:w -> HALT:n [label="T"];
    COND:e -> INCR:n [label="F"];
	{ rank=same; INCR; HALT; }
	INCR:s -> JOIN:e;
}

\end{dot2tex}
\end{center}
    \end{frame}

    \begin{frame}{Доказательство частичной корректности}
    Те же шаги метода индуктивных утверждений. Измененные предикат пути и формула пути.
    \end{frame}

    \begin{frame}{Доказательство полной корректности}
    Надо добавить условия корректности вызова процедуры.

	\begin{block}{Шаг 6}
	Выписывание условия корректности вызова процедуры для каждого базового пути между точкой сечения и псевдоточкой в оператор CALL ($r_1,~r_2,~...,~r_N$ --- дополнительные переменные для значений выходных переменных для операторов CALL внутри пути, $D_{r_1},~D_{r_2},~...,~D_{r_N}$ -- выходные домены в операторах CALL, $\varphi'$ --- предусловие оператора CALL в конце пути, $arg$ --- функция построения входных переменных оператора CALL в конце пути):
	$\forall \bar{x} \in D_{\bar{x}} ~ \forall \bar{y} \in D_{\bar{y}} ~r_1 \in D_{r_1}~...\cdot~
	\varphi(\bar{x}) \land p_A(\bar{x},~\bar{y})~\land~R_\alpha(\bar{x},~\bar{y},~r_1,~r_2,~...,~r_N) \Rightarrow
	\varphi'(arg(\bar{x},~r_\alpha(\bar{x},~\bar{y},~r_1,~r_2,~...,r_N)))$.
	\end{block}

    \end{frame}

    \begin{frame}{Рекурсия}
    TBD
    \end{frame}

    \section{Аксиоматический метод расширения языка спецификации}

    \begin{frame}{}
    TBD
    \end{frame}

\end{document}

