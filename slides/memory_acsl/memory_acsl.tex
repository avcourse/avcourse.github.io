\documentclass[hyperref={unicode=true}]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}

%\usepackage{listings}
%\usepackage{graphicx}

%\usepackage{comment}

\title{Лекция 5. Спецификация и верификация программ с указателями}
\author{}
\date{}

\usetheme{Warsaw}

\AtBeginSection[] {
	\begin{frame}{Содержание}
		\tableofcontents[currentsection]
	\end{frame}
}
%\overfullrule=5pt

\begin{document}
	\begin{frame}{}
		\titlepage
	\end{frame}

    \begin{frame}{Цель лекции}
    Узнать особенности спецификации и верификации функций, оперирующих с
    указателями и массивами.
    \end{frame}

    \section{Спецификация сортировки}

    \begin{frame}{Основные конструкции}
    \begin{itemize}
    \item Валидность диапазона указателей лучше специфицировать без квантора
    всеобщности: \texttt{\textbackslash valid(array + (0 .. size - 1));}
    \item Постусловие имеет дело с двумя состояниями памяти: до вызова функции
    и после вызова функции: \emph{метки памяти} - \texttt{Pre} и \texttt{Post}
    \item Чтобы разыменовать указатель, надо указать состояние памяти:
    \texttt{\textbackslash at(expression, label)}
    \item У предиката метку памяти можно указать явно: \texttt{p\{L\}(n)}
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример: сортировка выбором}
    \begin{itemize}
    \item \texttt{sort\_1.c} - спецификация сортировки
    \item \texttt{sort\_2.c} - реализация сортировки выбором
    \item \texttt{sort\_3.c} - доказательство safety
    \item \texttt{sort\_4.c} - доказательство упорядоченности
    \item \texttt{sort\_5.c} - доказательство перестановочности
    \end{itemize}
    \end{frame}

    \begin{frame}{Выводы из примера}
    \begin{itemize}
    \item Солверам надо подсказывать, как нужно инстанцировать аксиомы
    \item Полезна бывает аксиома о том, что значение лоджика или предиката не
    изменится, если такая-то часть памяти между двумя метками не менялась
    \item Предикаты, аксиомы, леммы, лоджики могут иметь несколько меток памяти
    \item Можно задавать имя дополнительной метке памяти при помощи ghost
    \item В начале итерации цикла содержимое памяти надо вручную связывать с
    содержимым памяти до цикла, если в цикле есть присваивание в эту память
    \end{itemize}
    \end{frame}

    \section{Спецификация аллоцирования и деаллоцирования памяти}
    \begin{frame}{Модель памяти}
    \begin{itemize}
    \item Все указатели делятся на классы эквивалентности ---
    \emph{блоки указателей}. Блок указателей --- это все указатели, которые
    можно сравнивать между собой.
    Сравнение указателей разных блоков не определено (стандарт языка Си не
    разрешает сравнивать указатели, полученные разными выделениями памяти).

    \item В каждом блоке указателей есть один выделенный элемент ---
    \emph{базовый указатель}.

    \item Модель памяти сопоставляет каждому блоку указателей число ---
    \emph{размер}. Размер может быть:
    \begin{itemize}
    \item ненулевым - можно разыменовать указатели от базового до базового +
    размер - 1
    \item равным нулю - нельзя разыменовать ни один указатель, но можно вызвать
    функцию \texttt{free()} от базового указателя
    \item отрицательным - разыменовать никакой нельзя, \texttt{free()} нельзя
    \end{itemize}
    \end{itemize}
    \end{frame}

    \begin{frame}{Блоки указателей}
    \begin{itemize}
    \item У указателей нет числового значения. Есть лишь смещение от базового
    указателя.
    \item Нельзя прибавлять по 1 к указателю одного блока и получить
    указатель из другого блока.
    \item Выделение и освобождение памяти - это смена размера блока. Блоки не
    появляются и не исчезают.
    \item Базовые адреса в блоке существуют независимо от того, какие размеры
    им сопоставлены в модели памяти.
    \item Классы эквивалентности указателей не меняются во время всей программы.
    Они вычисляются при помощи статического анализа (значения тех переменных,
    которые сравниваются в коде или спецификации).
    \end{itemize}
    \end{frame}

    \begin{frame}{Внутренние структуры}
    Модель памяти состоит из нескольких таблиц:
    \begin{itemize}
    \item таблицы блоков (\texttt{alloc\_table})
    \item таблицы тегов (\texttt{tag\_table})
    \item таблицы значений (\texttt{map from pointer to value type})
    \end{itemize}

    Таблица блоков нужна для организации соответствия блоков указателей
    размерам. Таблица тегов --- для организации динамических типов указателей.
    Таблица значений -- для определения, на какое значение указывает указатель.
    Валидность проверяется по таблице блоков и тегов, разыменование делается
    при помощи таблицы значений.
    \end{frame}

    \begin{frame}{Нормализация кода}
    Все типы приводятся к указателям на структуру с единственным полем (отсюда
    такие длинные имена типов в теории Why3, которую генерирует AstraVer).

    Делается статический анализ для определения блоков указателей.

    Для упрощения верификации делаются предположения:
    \begin{itemize}
    \item невыровненных указателей нет
    \item указатели разных типов не указывают в одну область памяти (или внутрь
            нее)
    \item указатели не преобразуются между типами указателей
    \item память неограничена
    \end{itemize}
    \end{frame}

    \begin{frame}{Предопределенные предикаты и лоджики}
    \begin{itemize}
    \item \texttt{\textbackslash freeable\{L\}(p)} -
    указатель p равен базовому указателю своего блока и в метке памяти L размер
    этого блока неотрицательный
    \item \texttt{\textbackslash allocable\{L\}(p)} -
    указатель р равен базовому указателю своего блока и в метке памяти L
    размер отрицательный
    \item \texttt{\textbackslash offset\_min\{L\}(p)} - смещение от р до
    базового указателя блока указателей, которому принадлежит p
    \item \texttt{\textbackslash offset\_max\{L\}(p)} - значение
    \texttt{\textbackslash offset\_min\{L\}(p)} плюс размер блока указателей,
    которому принадлежит р, в метке памяти L минус 1, если этот размер
    неотрицательный
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример}
    \begin{itemize}
    \item \texttt{graph\_1.c} --- спецификация функций создания и удаления
    графа
    \item \texttt{graph\_2.c} --- определения функций
    \item \texttt{graph\_3.c} --- доказательство полной корректности
    (обратите внимание, как свойства массива \texttt{g->vertices} после
     первого цикла в функции создания сохранились по окончании второго цикла)
    \end{itemize}
    \end{frame}
\end{document}

