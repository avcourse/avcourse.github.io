\documentclass[hyperref={unicode=true}]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}

%\usepackage{listings}
%\usepackage{graphicx}

%\usepackage{comment}

\title{Лекция 5. Спецификация и верификация программ с указателями}
\author{}
\date{}

\usetheme{Warsaw}

\AtBeginSection[] {
	\begin{frame}{Содержание}
		\tableofcontents[currentsection]
	\end{frame}
}
%\overfullrule=5pt

\begin{document}
	\begin{frame}{}
		\titlepage
	\end{frame}

    \begin{frame}{Цель лекции}
    Узнать особенности спецификации и верификации функций, оперирующих с
    указателями и массивами.
    \end{frame}

    \section{Спецификация сортировки}

    \begin{frame}{Основные конструкции}
    \begin{itemize}
    \item Валидность диапазона указателей лучше специфицировать без квантора
    всеобщности: \texttt{\textbackslash valid(array + (0 .. size - 1));}
    \item Постусловие имеет дело с двумя состояниями памяти: до вызова функции
    и после вызова функции: \emph{метки памяти} - \texttt{Pre} и \texttt{Post}
    \item Чтобы разыменовать указатель, надо указать состояние памяти:
    \texttt{\textbackslash at(expression, label)}
    \item У предиката метку памяти можно указать явно: \texttt{p\{L\}(n)}
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример: сортировка выбором}
    \begin{itemize}
    \item \texttt{sort\_1.c} - спецификация сортировки
    \item \texttt{sort\_2.c} - реализация сортировки выбором
    \item \texttt{sort\_3.c} - доказательство safety
    \item \texttt{sort\_4.c} - доказательство упорядоченности
    \item \texttt{sort\_5.c} - доказательство перестановочности
    \end{itemize}
    \end{frame}

    \begin{frame}{Выводы из примера}
    \begin{itemize}
    \item Солверам надо подсказывать, как нужно инстанцировать аксиомы
    \item Полезна бывает аксиома о том, что значение лоджика или предиката не
    изменится, если такая-то часть памяти между двумя метками не менялась
    \item Предикаты, аксиомы, леммы, лоджики могут иметь несколько меток памяти
    \item Можно задавать имя дополнительной метке памяти при помощи ghost
    \item В начале итерации цикла содержимое памяти надо вручную связывать с
    содержимым памяти до цикла, если в цикле есть присваивание в эту память
    \end{itemize}
    \end{frame}

    \section{Спецификация аллоцирования и деаллоцирования памяти}
    \begin{frame}{Модель памяти}
    Модель памяти состоит из бесконечного множества блоков. Блоки бывают:
    \begin{itemize}
    \item выделенными с ненулевым размером
    \item выделенными с нулевым размером
    \item невыделенными (свободными)
    \end{itemize}
    \end{frame}

    \begin{frame}{Блоки и указатели}
    \begin{itemize}
    \item Блок представляется тройкой (<<идентификатор>>, <<адрес начала>>,
    <<размер>>). Все эти атрибуты есть у \textbf{всех} блоков (даже свободных).
    Вид блока можно закодировать в атрибуте <<размер>>: он неотрицательный для
    выделенных блоков и отрицательный для свободных.

    \item Выделение и освобождение памяти - это смена размера блока. Блоки не
    появляются и не исчезают.

    \item Указатель - это блок и смещение от его начала. Смещение может быть любым
    числом (даже выходящим за границы, задаваемые размером, но такие указатели
    нельзя разыменовать). Блок может быть любого вида (даже свободный).
    \end{itemize}
    \end{frame}

    \begin{frame}{Внутренние структуры}
    Модель памяти состоит из нескольких таблиц:
    \begin{itemize}
    \item таблицы блоков (\texttt{alloc\_table})
    \item таблицы тегов (\texttt{tag\_table})
    \item таблицы значений (\texttt{map from pointer to value type})
    \end{itemize}

    Валидность проверяется по таблице блоков и тегов, разыменование делается
    при помощи таблицы значений.
    \end{frame}

    \begin{frame}{Нормализация кода}
    Все типы приводятся к указателям на структуру с единственным полем (отсюда
    такие длинные имена типов в теории Why3, которую генерирует AstraVer).

    Для упрощения верификации делаются предположения:
    \begin{itemize}
    \item невыровненных указателей нет
    \item указатели разных типов не указывают в одну область памяти (или внутрь
            нее)
    \item указатели не преобразуются между типами указателей
    \item память неограничена
    \end{itemize}
    \end{frame}

    \begin{frame}{Предопределенные предикаты и лоджики}
    \begin{itemize}
    \item \texttt{\textbackslash freeable\{L\}(p)} - в метке памяти L указатель p указывает
    на начало выделенного блока (любого размера)
    \item \texttt{\textbackslash allocable\{L\}(p)} - в метке памяти L указатель р указывает
    на начало невыделенного блока
    \item \texttt{\textbackslash offset\_min\{L\}(p)} - в метке памяти L
    значение смещения от р до начала блока указателя р
    \item \texttt{\textbackslash offset\_max\{L\}(p)} - в метке памяти L
    значение смещения от р до конца блока указателя р, если блок выделен
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример}
    \begin{itemize}
    \item \texttt{graph\_1.c} --- спецификация функций создания и удаления
    графа
    \item \texttt{graph\_2.c} --- определения функций
    \item \texttt{graph\_3.c} --- доказательство полной корректности
    (обратите внимание, как свойства массива \texttt{g->vertices} после
     первого цикла в функции создания сохранились по окончании второго цикла)
    \end{itemize}
    \end{frame}
\end{document}

