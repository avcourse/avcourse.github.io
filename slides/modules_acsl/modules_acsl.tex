\documentclass[hyperref={unicode=true}]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}

%\usepackage{listings}
%\usepackage{graphicx}

%\usepackage{comment}

\title{Лекция 6. Спецификация и верификация программ из нескольких функций}
\author{}
\date{}

\usetheme{Warsaw}

\AtBeginSection[] {
	\begin{frame}{Содержание}
		\tableofcontents[currentsection]
	\end{frame}
}
%\overfullrule=5pt

\begin{document}
	\begin{frame}{}
		\titlepage
	\end{frame}

    \begin{frame}{Цель лекции}
    Узнать особенности спецификации и верификации рекурсивных функций,
    а также функций, вызывающих другие функции. Сформулировать правила
    спецификации интерфейсов.
    \end{frame}

    \section{Верификация рекурсивных функций}

    \begin{frame}{Пример: быстрая сортировка}
    \begin{itemize}
    \item Исходный код примера смотрите в директории \texttt{examples\textbackslash qsort}.
    \item Шаги примера записаны в \texttt{Makefile}.
    \item \texttt{qsort\_1.h} --- заголовок функции \texttt{qsort} и спецификация функции.
    Она должна отсортировать по неубыванию данный массив из целых чисел.
    \item \texttt{qsort\_2.c} --- определение функции \texttt{qsort}. Быстрая сортировка делит
    сортируемый диапазон на 3 части: опорный элемент, все меньшие-или-равные-опорному элементы,
    все большие-или-равные-опорному элементы и сортирует каждый поддиапазон. Разделение на части
    выполняет функция \texttt{partition}.
    \item \texttt{part\_3.h} --- объявление функции \texttt{partition} и ее спецификация.
    \end{itemize}
    \end{frame}

    \begin{frame}{Методы Флойда при наличии вызовов функций}
    \begin{itemize}
    \item Надо доказать полную коррек-ть вызывающей функции относительно
    \textbf{любой} реализации вызываемой функции, полностью корректной относительно своей специф-ции.
    \item Добавить условие в safety: на всех базовых путях из точки сечения к месту вызова функции
    должно быть выполнено предусловие вызываемой функции.
    \item Изменить определение предиката пути: если внутри базового пути встретился вызов функции,
    то в предикате пути, проходящем через него, помещается постусловие функции и дополнительные переменные
    для возвращаемых значений вызываемой функции.
    \item Важно, чтобы существовало хотя бы одно определение вызываемой функции, полностью корректной
    относительно ее спецификации. Иначе доказательство полной корректности вызывающей функции бесполезно.
    \end{itemize}
    \end{frame}

    \begin{frame}{Метод фундированных множеств для рекурсии}
    \begin{itemize}
    \item Вычисление для рекурсивной функции --- это дерево: каждый вызов функции порождает поддерево,
    непосредственные дети узлов - это последовательность конфигураций функции родительского узла.
    \item Классический метод фундированных множеств позволит доказать конечность количества детей у каждого узла. Осталось
    доказать, что количество узлов конечно. Или, что в дереве нет бесконечных путей. Путь --- это цепочка рекурсивных вызовов.
    \item Вводим фундированное множество и оценочную функцию для узла дерева. У каждого дочернего узла оценочная функция
    должна быть меньше оценочной функции родительского узла. И значение оценочной функции должно принадлежать
    фундированному множеству. В роли индуктивных утверждений выступает предусловие ф-ции.
    \end{itemize}
    \end{frame}

    \begin{frame}{qsort: доказательство safety}
    \begin{itemize}
    \item В ACSL фундированное множество для доказательства завершения рекурсии --- неотрицательные целые числа и
    стандартное арифметическое отношение <<меньше>>. Оценочная функция указывается в аннотации \texttt{decreases}.
    \item \texttt{make step1}. Аннотация \texttt{decreases} указана не у заголовка функции \texttt{qsort}, а у
    реализации функции, ведь могут быть и нерекурсивные реализации, а аннотации у заголовка будут относиться ко всем
    реализациям. Аннотации у заголовка и у реализации соединяются вместе.
    \end{itemize}
    \end{frame}

    \begin{frame}{qsort: доказательство перестановочности}
    \begin{itemize}
    \item Многие условия верификации не доказываются. Добавляем \texttt{assert}ы, чтобы понять, почему они не доказываются.
    \item \texttt{make step2} --- добавлены \texttt{assert}ы. Делаем вывод, что для доказательства условий верификации и
    \texttt{assert}ов нужны дополнительные леммы. Возможно, они будут полезны для доказательства условий верификации про
    разные Си-функции. Поэтому имеет смысл разместить леммы в отдельном файле и подключать его по необходимости.
    \item Размещаем леммы в файле \texttt{permut\_min\_theorems.h}. Можно не \#includeить его, а запустить \texttt{frama-c}
    сразу с несколькими файлами. В этом случае еще полезна опция \texttt{-av-file-name}, задающая имя директории для сессии.
    Если этого не сделать, то оно будет выбрано по умолчанию как \texttt{whole\_program}. Посмотреть все опции плагина AstraVer
    можно так: \texttt{frama-c -av-help}.
    \end{itemize}
    \end{frame}

    \begin{frame}{qsort: доказательство перестановочности}
    \begin{itemize}
    \item \texttt{make step3} --- запуск с несколькими файлами.
    \item Не доказывается \texttt{assert} о том, что после второго вызова \texttt{qsort} левый сегмент остался неотронутым. Почему?
    Смотрим в why3: после второго вызова состояние памяти поменялось и известно про нее лишь то, что записано
    в спецификации \texttt{qsort}. Там не записано, что память за пределами сортируемого отрезка не изменилась. Чтобы выразить
    такие свойства, есть аннотация функции \texttt{assigns}. У нее указываются lvalue, за пределами которых память сохраняется
    такой же, какой была до вызова функции. Что происходит с самими lvalue, записывается в аннотации \texttt{ensures}.
    \end{itemize}
    \end{frame}

    \begin{frame}{qsort: доказательство перестановочности}
    \begin{itemize}
    \item Обращайте внимание на требования о том, какая память должна сохраняться неизменной после возврата из функции
    по сравнению с состоянием до вызова функции. Такие требования записываются при помощи аннотации \texttt{assigns}.
    \item \texttt{assigns \textbackslash nothing;} --- вся память не должна измениться.
    \item \texttt{make step4} --- добавили аннотацию \texttt{assigns a[l..u]}.
    \item Куда следует добавить \texttt{assigns}: к спецификации заголовка или реализации? К спецификации заголовка, т.к. это
    требование должно быть справедливо для всех реализаций.
    \item Для доказательства некоторых условий потребовалось сделать один раз inline.
    \end{itemize}
    \end{frame}

    \begin{frame}{qsort: доказательство упорядоченности}
    \begin{itemize}
    \item \texttt{make step5} --- добавляем \texttt{assert}ы для доказательства упорядоченности.
    Не доказано лишь Postcondition-Assigns. То есть, что функция \texttt{qsort} в целом не меняет память вне
    \texttt{[l .. u]}. Это так? Да, если функция \texttt{partition} не меняет память вне этого диапазона. Не указали у нее
    аннотацию \texttt{assigns}, а она оказалась нужна.
    \item \texttt{make step6} --- добавили \texttt{assigns} к функции \texttt{partition}. Доказана полная корректность функции \texttt{qsort}
    относительно всех реализаций \texttt{partition}, полностью корректных относительно ее спецификации.
    \item \texttt{make step7} --- показываем, что существует определение функции \texttt{partition}, полностью корректное
    относительно ее спецификации. В цикле использовали аннотацию \texttt{loop assigns} --- вся память за пределами указанных там lvalue
    не менялась между входом в цикл и текущей итерацией.
    \end{itemize}
    \end{frame}

    \begin{frame}{allocates, frees}
    \begin{itemize}
    \item Нужно обращать внимание на требования о том, какую память не может освобождать и выделять функция.
    \item Такие требования записываются при помощи аннотаций \texttt{allocates} и \texttt{frees}.
    \item У аннотации \texttt{allocates} записываются lvalue типа указатель, вычисляемые в состоянии памяти Post, и функция обязана сохранить
    выделенной всю память, которая была выделена перед вызовом функции, за исключением, быть может, lvalue.
    \item Аннотация \texttt{frees} означает то же, но lvalue определяются в состоянии памяти Pre. Если есть несколько аннотаций \texttt{allocates},
    \texttt{frees}, их области lvalue объединяются.
    \end{itemize}
    \end{frame}

    \begin{frame}{Выводы-1}
    \begin{itemize}
    \item аннотация \texttt{decreases} для доказательства завершаемости рекурсивных функций.
    \item обращать внимание на требования о том, какую память не должна менять функция.
    \item аннотация \texttt{assigns} для спецификации таких требований.
    \item есть еще аннотация цикла \texttt{loop assigns}.
    \item аннотации \texttt{allocates} и \texttt{frees} для спецификации того, какую память не должна освободить или выделить функция.
    \item подробности синтаксиса и семантики этих аннотаций смотрите в документации по ACSL.
    \end{itemize}
    \end{frame}

    \section{Разделение на регионы}

    \begin{frame}{Нужен assigns?}
    \begin{itemize}
    \item Почему на шаге 5 в примере с \texttt{qsort} потребовался \texttt{assigns}? Почему до этого мы не сталкивались с такой аннотацией,
    но условия про сохранение памяти доказывались?
    \item Пример \texttt{examples\_regions}. В файле \texttt{graph\_1.c} размещена функция \texttt{insert\_edge}, спецификация и реализация.
    \item Там же размещена функция \texttt{insert\_double\_edge}, которая вызывает функцию \texttt{insert\_edge}.
    \item В спецификации \texttt{insert\_edge} отсутствуют аннотации \texttt{assigns}, \texttt{allocates}, \texttt{frees}. То есть поведение
    функции дополнительно не ограничивается. По коду функции определяется, какие части памяти изменяются, а какие --- сохраняются.
    \end{itemize}
    \end{frame}

    \begin{frame}{Уточнение assigns}
    \begin{itemize}
    \item В этой
    функции не меняется память под саму переменную \texttt{*graph} и под массив \texttt{graph->vertices}. Но меняется элемент массива
    \texttt{graph->edges}. Поэтому 3-й \texttt{assert} в \texttt{insert\_double\_edge} не доказывается.
    \item Итак, в спецификации функции \texttt{insert\_edge} надо добавить свойство, что изменился только один элемент массива \texttt{graph->edges}.
    \item \texttt{make step2} --- первая идея: добавить аннотацию \texttt{ensures}
    \item \texttt{make step3} --- но она не всегда работает
    \item \texttt{make step4} --- правильная спецификация этого свойства (при помощи \texttt{assigns}) должна учитывать \emph{регионы}.
    \end{itemize}
    \end{frame}

    \begin{frame}{Регион}
    \emph{Регион} --- это множество указательных переменных, которые могут быть синонимами, т.е. их значения могут
    принадлежать одному и тому же блоку. Это значит, что изменение памяти через один из указателей региона может повлиять на указатель из другого региона.

    Если бы не было регионов, то везде пришлось бы писать сложные предикаты о том, какая часть памяти не должна меняться, и иметь другую модель памяти, не
    дающую эффективную верификацию не слишком тривиальных программ.
    \end{frame}

    \begin{frame}{Определение регионов}
    Вычисление регионов --- это статический межпроцедурный анализ. Он изложен в одной из статей в списке литературы курса.

    \begin{itemize}
    \item выделяется память -- это новый регион
    \item указатели разных типов -- из разных регионов
    \item указатели не сравниваются (отдельные два аргумента функции) -- из разных регионов (но если функция вызывается с указателями из одного региона, то
            указатели-аргументы должны принадлежать одному региону)
    \item указатели сравниваются, присваиваются (в частности, как смещения в одном массиве) -- значит их регионы надо объединить
    \item эти правила применяются как к Си коду, так и к спецификации, причем ко всему доступному коду
    \end{itemize}
    \end{frame}

    \begin{frame}{Зачем знать о регионах?}
    При верификации следует прогнозировать результат анализа и писать дополнительные
    утверждения про неизменность части региона. В \texttt{make step3} не обеспечивало точную передачу свойства неизменности при помощи \texttt{ensures}.

    Данное свойство невозможно выразить в виде предиката, если в языке спецификации нет способа выразить регионы. Поскольку разделение на регионы не относится
    к языку спецификации ACSL, а является одной из эвристик инструмента AstraVer, то предикат записать нельзя. Аннотация \texttt{assigns} избавлена от этой
    проблемы: все содержимое региона, кроме указанного в аннотации, сохраняется.
    \end{frame}

    \begin{frame}{same block}
    \begin{itemize}
    \item Полезное замечание: проверка \texttt{\textbackslash base\_addr(p1) != \textbackslash base\_addr(p2)} транслируется во внутренний предикат
    \texttt{same\_block(p1, p2)}. Это не предикат ACSL, его нельзя написать напрямую в спецификации.
    \item Обращайте внимание на то, есть ли требования на разделение по блокам.
    \item \texttt{make step5} --- не доказывается некоторые условия в функции \texttt{insert\_edge\_to\_graphs}, т.к. все массивы \texttt{edges} в графах в
    массиве \texttt{graphs} находятся в одном регионе, значит, должно быть важно, что с разделением их по блокам. А про это ничего не требуется в предусловии.
    \item \texttt{make step6} --- добавлено разделение по блокам. Теперь все условия доказываются.
    \end{itemize}
    \end{frame}

    \begin{frame}{Представление региона}
    \begin{itemize}
    \item таблица значений  --- \texttt{map}, который используется для представления операции разыменования
    \item таблица блоков  --- \texttt{alloc\_table}, который используется для представления блоков, т.е. определения предикатов \texttt{\textbackslash offset\_min},
     \texttt{\textbackslash offset\_max}, \texttt{\textbackslash valid}, \texttt{\textbackslash freeable}, \texttt{\textbackslash allocable}
    \item таблица тегов --- \texttt{tag\_table}, который используется для представления динамических типов объектов в блоке
    \end{itemize}
    \end{frame}

    \section{Спецификация интерфейса}

    \begin{frame}{Интерфейсы}
    \begin{itemize}
    \item Мы уже разделили верификацию программы на верификацию по отдельным функциям. У каждой функции есть спецификация и определение (реализация).
    \item Как сделать разделение, если есть не все реализации. Спецификации для всех функций есть. Задача та же --- доказать полную корректность
    относительно всех реализаций вызываемых функций, полностью корректных относительно их спецификаций.
    \item Здесь нас поджидает одна особенность...
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример}
    \begin{itemize}
    \item Пример с прошлой лекции про создание и удаление графа. У нас будет библиотека работы с графами. Реализация библиотеки будет
    находиться отдельно от кода, использующего эту библиотеку.
    \item Исходный код примера: \texttt{examples\textbackslash interfaces} --- оформили как библиотеку. Написали модуль \texttt{test\_3.c}, использующий библиотеку.
    Модуль кажется странным, т.к. в нем требуется доказать \texttt{assert \textbackslash false;}, т.е. нет ли ошибки в спецификации библиотеки.
    \end{itemize}
    \end{frame}

    \begin{frame}{Пример (2)}
    \begin{itemize}
    \item \texttt{make step1} --- доказываем полную корректность модуля \texttt{test\_3.c} относительно конкретной реализации библиотеки с графами.
    То есть вызываем \texttt{frama-c} с несколькими файлами. Конечно, \texttt{assert} не доказывается, ошибки нет.
    \item \texttt{make step2} --- доказываем полную корректность модуля \texttt{test\_3.c} без указания реализации библиотеки. И теперь \texttt{assert}
    почему-то стал доказываться... Видим, что поведение инструмента отличается, хотя спецификации не менялись.
    \item сравниваем код why3 и видим, что во втором случае AstraVer не видел реализации и не знал, что состояние памяти поменяется.
    \end{itemize}
    \end{frame}

    \begin{frame}{Автоматическое дополнение спецификации по заголовку}
    Если реализации функции нет, то регионы формируются по следующим правилам:
    \begin{itemize}
    \item Неконстантный указатель-аргумент $\rightarrow$ таблица значений региона меняется
    \item Константный указатель-аргумент $\rightarrow$ таблица значений региона не меняется
    \item Нет \texttt{allocates} или \texttt{frees} $\rightarrow$ \texttt{alloc\_table} региона не меняется
    \item Есть \texttt{allocates v;} или \texttt{frees v;} $\rightarrow$ \texttt{alloc\_table} региона переменной \texttt{v} меняется
    \end{itemize}
    \end{frame}

    \begin{frame}{Вопросы}
    \begin{itemize}
    \item можно ли правильно описать спецификацию заголовка функции \texttt{graph\_create} и \texttt{graph\_destroy}?
    \item как писать спецификацию для библиотек, которые сами выбирают свои типы данных? (т.е. имея только заголовок функции, невозможно автоматически
            вычислить регионы)
    \item как понимается модульная верификация? Можно ли верифицировать функции по отдельности? Если можно, то в каких предположениях?
    \end{itemize}
    \end{frame}

\end{document}
