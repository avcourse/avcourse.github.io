
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_intP_safe

  use why3.Bool.Bool 
  
end

module Root_intP_unsafe

  use why3.Bool.Bool 
  
end

theory Root_intP

  use why3.Bool.Bool 
  
  type intP 
  
end

theory Logic_Swap

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate _Swap (a_6 : (pointer intP)) (i_0 : int) (j_0 : int)
  (intP_intM_a_6_5_at_L2 : (memory intP Int32.t)) (intP_intM_a_6_5_at_L1 :
  (memory intP Int32.t))
  =
     ((Int32.(=) (select intP_intM_a_6_5_at_L1 (shift a_6 i_0))
      (select intP_intM_a_6_5_at_L2 (shift a_6 j_0)))
     /\
     ((Int32.(=) (select intP_intM_a_6_5_at_L1 (shift a_6 j_0))
      (select intP_intM_a_6_5_at_L2 (shift a_6 i_0)))
     /\
     (forall k_3 : int.
      (((not ((=) k_3 i_0)) /\ (not ((=) k_3 j_0))) ->
       (Int32.(=) (select intP_intM_a_6_5_at_L1 (shift a_6 k_3))
       (select intP_intM_a_6_5_at_L2 (shift a_6 k_3)))))))
  
  
end

theory Logic_permutation

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_Swap 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  inductive permutation
  (pointer intP) int int (memory intP Int32.t) (memory intP Int32.t)
  =
  |
  _Permut_refl:
  (forall intP_intM_a_1_4_at_L : (memory intP Int32.t).
   (forall a_2_0 : (pointer intP).
    (forall l_0_1 : int.
     (forall h_0 : int.
      (permutation a_2_0 l_0_1 h_0 intP_intM_a_1_4_at_L intP_intM_a_1_4_at_L)))))
  |
  _Permut_sym:
  (forall intP_intM_a_1_4_at_L2 : (memory intP Int32.t).
   (forall intP_intM_a_1_4_at_L1 : (memory intP Int32.t).
    (forall a_3 : (pointer intP).
     (forall l_1 : int.
      (forall h_1 : int.
       ((permutation a_3 l_1 h_1 intP_intM_a_1_4_at_L2 intP_intM_a_1_4_at_L1)
        ->
        (permutation a_3 l_1 h_1 intP_intM_a_1_4_at_L1 intP_intM_a_1_4_at_L2)))))))
  |
  _Permut_trans:
  (forall intP_intM_a_1_4_at_L3 : (memory intP Int32.t).
   (forall intP_intM_a_1_4_at_L2 : (memory intP Int32.t).
    (forall intP_intM_a_1_4_at_L1 : (memory intP Int32.t).
     (forall a_4 : (pointer intP).
      (forall l_2 : int.
       (forall h_2 : int.
        (((permutation a_4 l_2 h_2 intP_intM_a_1_4_at_L2
          intP_intM_a_1_4_at_L1)
         /\
         (permutation a_4 l_2 h_2 intP_intM_a_1_4_at_L3
         intP_intM_a_1_4_at_L2)) ->
         (permutation a_4 l_2 h_2 intP_intM_a_1_4_at_L3
         intP_intM_a_1_4_at_L1))))))))
  |
  _Permut_swap:
  (forall intP_intM_a_1_4_at_L2 : (memory intP Int32.t).
   (forall intP_intM_a_1_4_at_L1 : (memory intP Int32.t).
    (forall a_5 : (pointer intP).
     (forall l_3 : int.
      (forall h_3 : int.
       (forall i_1 : int.
        (forall j_1 : int.
         ((((<=) l_3 i_1) /\
          (((<=) i_1 h_3) /\
          (((<=) l_3 j_1) /\
          (((<=) j_1 h_3) /\
          (_Swap a_5 i_1 j_1 intP_intM_a_1_4_at_L2 intP_intM_a_1_4_at_L1)))))
          ->
          (permutation a_5 l_3 h_3 intP_intM_a_1_4_at_L2
          intP_intM_a_1_4_at_L1)))))))))
  
end

theory Lemma_permutation_reads #"qsort_c.jc" 79 0 372#
"expl:Lemma permutation_reads"

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  lemma Permutation_reads
  #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 32 3 999#
  "expl:Lemma permutation_reads"  :
  (forall intP_intM_a_7_13_at_L2 : (memory intP Int32.t).
   (forall intP_intM_a_7_13_at_L1 : (memory intP Int32.t).
    (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 34 8 162#
    (forall a_7 : (pointer intP).
     (forall n_3 : int.
      (forall m_1 : int.
       ((forall i_1_0 : int.
         ((((<=) n_3 i_1_0) /\ ((<=) i_1_0 m_1)) ->
          (Int32.(=) (select intP_intM_a_7_13_at_L1 (shift a_7 i_1_0))
          (select intP_intM_a_7_13_at_L2 (shift a_7 i_1_0))))) ->
        (permutation a_7 n_3 m_1 intP_intM_a_7_13_at_L2
        intP_intM_a_7_13_at_L1))))))))
  
end

theory Logic_minimum

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate minimum (a_0 : (pointer intP)) (n_2 : int) (m_0 : int) (p : int)
  (intP_intM_a_0_3_at_L : (memory intP Int32.t))
  =
     (forall k_2 : int.
      ((((<=) n_2 k_2) /\ ((<=) k_2 m_0)) ->
       ((<=) p (Int32.to_int (select intP_intM_a_0_3_at_L (shift a_0 k_2))))))
  
  
end

theory Lemma_permutation_saves_min #"qsort_c.jc" 89 0 352#
"expl:Lemma permutation_saves_min"

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  lemma Permutation_saves_min
  #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 36 41 836#
  "expl:Lemma permutation_saves_min"  :
  (forall intP_intM_a_8_14_at_L2 : (memory intP Int32.t).
   (forall intP_intM_a_8_14_at_L1 : (memory intP Int32.t).
    (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 38 8 161#
    (forall a_8 : (pointer intP).
     (forall n_4 : int.
      (forall m_2 : int.
       (forall s : int.
        ((permutation a_8 n_4 m_2 intP_intM_a_8_14_at_L2
         intP_intM_a_8_14_at_L1) ->
         ((minimum a_8 n_4 m_2 s intP_intM_a_8_14_at_L1) ->
          (minimum a_8 n_4 m_2 s intP_intM_a_8_14_at_L2))))))))))
  
end

theory Lemma_permutation_saves_many_min #"qsort_c.jc" 99 0 937#
"expl:Lemma permutation_saves_many_min"

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  lemma Permutation_saves_many_min
  #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 41 36 627#
  "expl:Lemma permutation_saves_many_min"  :
  (forall intP_intM_a_9_15_at_L2 : (memory intP Int32.t).
   (forall intP_intM_a_9_15_at_L1 : (memory intP Int32.t).
    (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 43 8 326#
    (forall a_9 : (pointer intP).
     (forall n_5 : int.
      (forall m_3 : int.
       (forall p_0 : int.
        (forall q : int.
         ((((<) m_3 p_0) \/ ((<) q n_5)) ->
          ((permutation a_9 p_0 q intP_intM_a_9_15_at_L2
           intP_intM_a_9_15_at_L1) ->
           ((permutation a_9 n_5 m_3 intP_intM_a_9_15_at_L2
            intP_intM_a_9_15_at_L1) ->
            ((forall i_2 : int.
              ((((<=) n_5 i_2) /\ ((<=) i_2 m_3)) ->
               (minimum a_9 p_0 q
               (Int32.to_int (select intP_intM_a_9_15_at_L1 (shift a_9 i_2)))
               intP_intM_a_9_15_at_L1))) ->
             (forall i_3 : int.
              ((((<=) n_5 i_3) /\ ((<=) i_3 m_3)) ->
               (minimum a_9 p_0 q
               (Int32.to_int (select intP_intM_a_9_15_at_L2 (shift a_9 i_3)))
               intP_intM_a_9_15_at_L2)))))))))))))))
  
end

theory Lemma_permutation_split #"qsort_c.jc" 119 0 471#
"expl:Lemma permutation_split"

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  lemma Permutation_split
  #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 47 84 301#
  "expl:Lemma permutation_split"  :
  (forall intP_intM_a_10_16_at_L2 : (memory intP Int32.t).
   (forall intP_intM_a_10_16_at_L1 : (memory intP Int32.t).
    (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 49 8 178#
    (forall a_10 : (pointer intP).
     (forall n_6 : int.
      (forall m_4 : int.
       (forall k_4 : int.
        ((((<=) n_6 m_4) /\ ((<=) m_4 k_4)) ->
         (((permutation a_10 n_6 m_4 intP_intM_a_10_16_at_L2
           intP_intM_a_10_16_at_L1)
          /\
          (permutation a_10 (Int.(+) m_4 (1)) k_4 intP_intM_a_10_16_at_L2
          intP_intM_a_10_16_at_L1)) ->
          (permutation a_10 n_6 k_4 intP_intM_a_10_16_at_L2
          intP_intM_a_10_16_at_L1))))))))))
  
end

theory Lemma_middle #"qsort_c.jc" 168 0 176# "expl:Lemma middle"

  use import int.Int 
  
  use int.ComputerDivision 
  
  use why3.Bool.Bool 
  
  lemma Middle #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 66 3 101#
  "expl:Lemma middle"  :
  (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 68 8 78#
  (forall a_11 : int.
   (forall b : int.
    (((<=) a_11
     (Int.(+) (ComputerDivision.div a_11 (2)) (ComputerDivision.div b (2))))
    \/
    ((<=) b
    (Int.(+) (ComputerDivision.div a_11 (2)) (ComputerDivision.div b (2))))))))
  
end

theory Struct_intP

  use import core.Tag_table_type 
  
  use import core.Tag_table 
  
  use import core.Tag_id 
  
  use import core.Tag 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Alloc 
  
  use why3.Bool.Bool 
  
  function intP_tag  : (tag_id intP)
  
  axiom IntP_parenttag_bottom  :
  (parenttag intP_tag bottom_tag)
  
  axiom IntP_is_final  :
  (forall intP_tag_table : (tag_table intP).
   (forall p : (pointer intP).
    ((instanceof intP_tag_table p intP_tag) ->
     ((=) (typeof intP_tag_table p) intP_tag))))
  
  predicate frame_tag_struct_intP (p : (pointer intP)) (old_intP_tag_table :
  (tag_table intP)) (intP_tag_table : (tag_table intP))
  =
     ((tag_extends old_intP_tag_table intP_tag_table) /\
     (alloc_tag_block old_intP_tag_table intP_tag_table p))
  
  predicate frame_free_struct_intP (p : (pointer intP)) (old_intP_alloc_table
  : (alloc_table intP)) (intP_alloc_table : (alloc_table intP))
  =
     ((free_extends old_intP_alloc_table intP_alloc_table) /\
     (free_block old_intP_alloc_table intP_alloc_table p))
  
  predicate frame_alloc_struct_intP (p : (pointer intP)) (n : int)
  (old_intP_alloc_table : (alloc_table intP)) (intP_alloc_table :
  (alloc_table intP))
  =
     ((alloc_extends old_intP_alloc_table intP_alloc_table) /\
     (alloc_block old_intP_alloc_table intP_alloc_table p n))
  
  predicate fresh_tag_struct_intP (p : (pointer intP)) (n : int)
  (intP_tag_table : (tag_table intP)) = (tag_fresh intP_tag_table p)
  
  predicate fresh_alloc_struct_intP (p : (pointer intP)) (n : int)
  (intP_alloc_table : (alloc_table intP))
  = (alloc_fresh intP_alloc_table p)
  
  predicate container_of_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP)) = true
  
  predicate container_of_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP)) = true
  
  predicate typeof_singleton_struct_intP (p : (pointer intP)) (intP_tag_table
  : (tag_table intP)) = ((=) (typeof intP_tag_table p) intP_tag)
  
  predicate typeof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     (((=) (typeof intP_tag_table p) intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof intP_tag_table (shift p i)) intP_tag))))
  
  predicate instanceof_singleton_struct_intP (p : (pointer intP))
  (intP_tag_table : (tag_table intP))
  = (instanceof intP_tag_table p intP_tag)
  
  predicate instanceof_struct_intP (p : (pointer intP)) (l : int) (r : int)
  (intP_tag_table : (tag_table intP))
  =
     ((instanceof intP_tag_table p intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof intP_tag_table (shift p i) intP_tag))))
  
  predicate right_valid_struct_intP (p : (pointer intP)) (b : int)
  (intP_alloc_table : (alloc_table intP))
  = ((>=) (offset_max intP_alloc_table p) b)
  
  predicate left_valid_struct_intP (p : (pointer intP)) (a : int)
  (intP_alloc_table : (alloc_table intP))
  = ((<=) (offset_min intP_alloc_table p) a)
  
  predicate strict_left_valid_struct_intP (p : (pointer intP)) (a : int)
  (intP_alloc_table : (alloc_table intP))
  = ((=) (offset_min intP_alloc_table p) a)
  
  predicate valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((<=) (offset_min intP_alloc_table p) a) /\
     ((>=) (offset_max intP_alloc_table p) b))
  
  predicate strict_valid_struct_intP (p : (pointer intP)) (a : int) (b : int)
  (intP_alloc_table : (alloc_table intP))
  =
     (((=) (offset_min intP_alloc_table p) a) /\
     ((=) (offset_max intP_alloc_table p) b))
  
  axiom IntP_int  : ((=) (int_of_tag intP_tag) (4))
  
end

module Function_swap_safety
#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 60 5 31# "expl:swap, safety"

  use import core.Upd_offset_safe 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import core.Shift_safe 
  
  use Safe_int32 
  
  use import Root_intP 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_offset_safe 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  let swap #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 60 5 31#
  "expl:Function swap, safety" =
  fun
   (a_1_0 : (pointer intP)) (i : Int32.t) (j : Int32.t) (intP_intM_a_1_6 :
   ref (memory intP Int32.t)) (intP_a_1_6_alloc_table : (alloc_table intP))
   (intP_a_1_6_tag_table : (tag_table intP)) 
   requires {
   (((allocated intP_a_1_6_alloc_table a_1_0) ->
     (((=) (typeof intP_a_1_6_tag_table a_1_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_1_6_alloc_table a_1_0) i) /\
       ((<) i (offset_max intP_a_1_6_alloc_table a_1_0))) ->
       ((=) (typeof intP_a_1_6_tag_table (shift a_1_0 i)) intP_tag)))))
   /\
   (#"qsort_c.jc" 133 12 1008#
   ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 55 13 26#
    (#"qsort_c.jc" 133 12 1008#
    ((#"qsort_c.jc" 133 12 1008#
     ((<=) (offset_min intP_a_1_6_alloc_table a_1_0) (Int32.to_int i)))
    /\
    (#"qsort_c.jc" 133 12 1008#
    ((#"qsort_c.jc" 133 12 1008#
     ((>=) (offset_max intP_a_1_6_alloc_table a_1_0) (Int32.to_int i)))
    /\
    (#"qsort_c.jc" 133 12 1008#
    (forall __framac_tmp1 : int.
     ((((<=) (Int32.to_int i) __framac_tmp1) /\
      ((<=) __framac_tmp1 (Int32.to_int i))) -> ((=) true true)))))))))
   /\
   (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 56 13 26#
   (#"qsort_c.jc" 133 12 1008#
   ((#"qsort_c.jc" 133 12 1008#
    ((<=) (offset_min intP_a_1_6_alloc_table a_1_0) (Int32.to_int j)))
   /\
   (#"qsort_c.jc" 133 12 1008#
   ((#"qsort_c.jc" 133 12 1008#
    ((>=) (offset_max intP_a_1_6_alloc_table a_1_0) (Int32.to_int j)))
   /\
   (#"qsort_c.jc" 133 12 1008#
   (forall __framac_tmp2 : int.
    ((((<=) (Int32.to_int j) __framac_tmp2) /\
     ((<=) __framac_tmp2 (Int32.to_int j))) -> ((=) true true)))))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let tmp = ref (Safe_int32.any_  () ) in
    begin
    (tmp :=
     (let _jessie_16 =
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 61 14 18#
     "expl:Pointer dereference"
     (acc_offset_typesafe  intP_a_1_6_alloc_table !intP_intM_a_1_6 a_1_0
      (Safe_int32.to_int  i ) )) in
     begin
     (assert {
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 61 8 11#
     "expl:Pointer index bounds" true) }); _jessie_16 end));
     begin
     (let _jessie_18 =
     (let _jessie_17 =
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 62 11 15#
     "expl:Pointer dereference"
     (acc_offset_typesafe  intP_a_1_6_alloc_table !intP_intM_a_1_6 a_1_0
      (Safe_int32.to_int  j ) )) in
     begin
     (assert {
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 62 4 15#
     "expl:Pointer index bounds" true) }); _jessie_17 end) in
     (let _jessie_19 = a_1_0 in
     (let _jessie_20 = (Safe_int32.to_int  i ) in
     (let _jessie_21 = (shift_typesafe  _jessie_19 _jessie_20 ) in
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 62 4 15#
     "expl:Pointer dereference"
     (upd_offset_typesafe  intP_a_1_6_alloc_table intP_intM_a_1_6 _jessie_19
      _jessie_20 _jessie_18 ))))));
      begin
      (let _jessie_23 =
      (let _jessie_22 = !tmp in
      begin
      (assert {
      (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 63 4 14#
      "expl:Pointer index bounds" true) }); _jessie_22 end) in
      (let _jessie_24 = a_1_0 in
      (let _jessie_25 = (Safe_int32.to_int  j ) in
      (let _jessie_26 = (shift_typesafe  _jessie_24 _jessie_25 ) in
      (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 63 4 14#
      "expl:Pointer dereference"
      (upd_offset_typesafe  intP_a_1_6_alloc_table intP_intM_a_1_6 _jessie_24
       _jessie_25 _jessie_23 )))))); (raise Return) end end end);
     (raise Return) end with Return -> () end
  
end

module Function_swap_behaviors
#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 60 5 31#
"expl:swap, behaviors"

  use import core.Upd_unsafe 
  
  use Unsafe_int32 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import core.Shift_unsafe 
  
  use import Root_intP 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pset_union 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_Swap 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Assigns 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_unsafe 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  let swap_ensures_default
  #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 60 5 31#
  "expl:Function swap, default behavior" =
  fun
   (a_1_0 : (pointer intP)) (i : Int32.t) (j : Int32.t) (intP_intM_a_1_6 :
   ref (memory intP Int32.t)) (intP_a_1_6_alloc_table : (alloc_table intP))
   (intP_a_1_6_tag_table : (tag_table intP)) 
   requires {
   (((allocated intP_a_1_6_alloc_table a_1_0) ->
     (((=) (typeof intP_a_1_6_tag_table a_1_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_1_6_alloc_table a_1_0) i) /\
       ((<) i (offset_max intP_a_1_6_alloc_table a_1_0))) ->
       ((=) (typeof intP_a_1_6_tag_table (shift a_1_0 i)) intP_tag)))))
   /\
   (#"qsort_c.jc" 133 12 1008#
   ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 55 13 26#
    (#"qsort_c.jc" 133 12 1008#
    ((#"qsort_c.jc" 133 12 1008#
     ((<=) (offset_min intP_a_1_6_alloc_table a_1_0) (Int32.to_int i)))
    /\
    (#"qsort_c.jc" 133 12 1008#
    ((#"qsort_c.jc" 133 12 1008#
     ((>=) (offset_max intP_a_1_6_alloc_table a_1_0) (Int32.to_int i)))
    /\
    (#"qsort_c.jc" 133 12 1008#
    (forall __framac_tmp1 : int.
     ((((<=) (Int32.to_int i) __framac_tmp1) /\
      ((<=) __framac_tmp1 (Int32.to_int i))) -> ((=) true true)))))))))
   /\
   (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 56 13 26#
   (#"qsort_c.jc" 133 12 1008#
   ((#"qsort_c.jc" 133 12 1008#
    ((<=) (offset_min intP_a_1_6_alloc_table a_1_0) (Int32.to_int j)))
   /\
   (#"qsort_c.jc" 133 12 1008#
   ((#"qsort_c.jc" 133 12 1008#
    ((>=) (offset_max intP_a_1_6_alloc_table a_1_0) (Int32.to_int j)))
   /\
   (#"qsort_c.jc" 133 12 1008#
   (forall __framac_tmp2 : int.
    ((((<=) (Int32.to_int j) __framac_tmp2) /\
     ((<=) __framac_tmp2 (Int32.to_int j))) -> ((=) true true)))))))))))) }
   ensures {
     ("expl:Postcondition"
     ((#"qsort_c.jc" 150 10 68# "expl:Assigns clause"
      (not_assigns intP_a_1_6_alloc_table intP_a_1_6_alloc_table (old
      !intP_intM_a_1_6) !intP_intM_a_1_6
      (pset_union (pset_singleton (shift a_1_0 (Int32.to_int i)))
      (pset_singleton (shift a_1_0 (Int32.to_int j))))))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 58 12 36#
     "expl:Ensures clause"
     (_Swap a_1_0 (Int32.to_int i) (Int32.to_int j) !intP_intM_a_1_6 (old
     !intP_intM_a_1_6))))) }  ->
   'Init:
   try
    begin
    (let tmp = ref (Unsafe_int32.any_  () ) in
    begin
    (tmp :=
     (acc  !intP_intM_a_1_6 (shift_  a_1_0 (Unsafe_int32.to_int  i ) ) ));
     begin
     (let _jessie_7 =
     (acc  !intP_intM_a_1_6 (shift_  a_1_0 (Unsafe_int32.to_int  j ) ) ) in
     (let _jessie_8 = a_1_0 in
     (let _jessie_9 = (Unsafe_int32.to_int  i ) in
     (let _jessie_10 = (shift_  _jessie_8 _jessie_9 ) in
     (upd  intP_intM_a_1_6 _jessie_10 _jessie_7 )))));
      begin
      (let _jessie_12 = !tmp in
      (let _jessie_13 = a_1_0 in
      (let _jessie_14 = (Unsafe_int32.to_int  j ) in
      (let _jessie_15 = (shift_  _jessie_13 _jessie_14 ) in
      (upd  intP_intM_a_1_6 _jessie_15 _jessie_12 ))))); (raise Return) end
     end end); (raise Return) end with Return -> () end
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_swap_safe

  use import core.Tag_table_type 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pset_union 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_Swap 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  val swap
  (a_1_0 : (pointer intP)) 
   (i : Int32.t) 
    (j : Int32.t) 
     (intP_intM_a_1_6 : ref (memory intP Int32.t)) 
      (intP_a_1_6_alloc_table : (alloc_table intP)) 
       (intP_a_1_6_tag_table : (tag_table intP)) : unit
        requires {
          ("expl:Internal"
          (#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 55 13 26#
           "expl:Requires clause"
           (#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
           ((#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
            ((<=) (offset_min intP_a_1_6_alloc_table a_1_0) (Int32.to_int i)))
           /\
           (#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
           ((#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
            ((>=) (offset_max intP_a_1_6_alloc_table a_1_0) (Int32.to_int i)))
           /\
           (#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
           (forall __framac_tmp1 : int.
            ((((<=) (Int32.to_int i) __framac_tmp1) /\
             ((<=) __framac_tmp1 (Int32.to_int i))) -> ((=) true true)))))))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 56 13 26#
          "expl:Requires clause"
          (#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
          ((#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
           ((<=) (offset_min intP_a_1_6_alloc_table a_1_0) (Int32.to_int j)))
          /\
          (#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
          ((#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
           ((>=) (offset_max intP_a_1_6_alloc_table a_1_0) (Int32.to_int j)))
          /\
          (#"qsort_c.jc" 133 12 1008# "expl:Requires clause"
          (forall __framac_tmp2 : int.
           ((((<=) (Int32.to_int j) __framac_tmp2) /\
            ((<=) __framac_tmp2 (Int32.to_int j))) -> ((=) true true))))))))))))
          }
        reads { intP_intM_a_1_6 } writes { intP_intM_a_1_6 }
        ensures {
          ((#"qsort_c.jc" 150 10 68# "expl:Assigns clause"
           (not_assigns intP_a_1_6_alloc_table intP_a_1_6_alloc_table (old
           !intP_intM_a_1_6) !intP_intM_a_1_6
           (pset_union (pset_singleton (shift a_1_0 (Int32.to_int i)))
           (pset_singleton (shift a_1_0 (Int32.to_int j))))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 58 12 36#
          "expl:Ensures clause"
          (_Swap a_1_0 (Int32.to_int i) (Int32.to_int j) !intP_intM_a_1_6
          (old !intP_intM_a_1_6)))) }
  
end

module Function_partition_safety
#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 81 4 35#
"expl:partition, safety"

  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use Safe_int32 
  
  use import Root_intP 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_swap_safe 
  
  use import Exceptions 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_offset_safe 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  let partition #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 81 4 35#
  "expl:Function partition, safety" =
  fun
   (a_2 : (pointer intP)) (l_0 : Int32.t) (u : Int32.t) (intP_intM_a_7 : ref
   (memory intP Int32.t)) (intP_a_7_alloc_table : (alloc_table intP))
   (intP_a_7_tag_table : (tag_table intP)) 
   requires {
   (((allocated intP_a_7_alloc_table a_2) ->
     (((=) (typeof intP_a_7_tag_table a_2) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_7_alloc_table a_2) i) /\
       ((<) i (offset_max intP_a_7_alloc_table a_2))) ->
       ((=) (typeof intP_a_7_tag_table (shift a_2 i)) intP_tag)))))
   /\
   (#"qsort_c.jc" 175 12 1099#
   ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 73 13 23#
    ((>=) (Int32.to_int u) (Int.(+) (Int32.to_int l_0) (1))))
   /\
   (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 74 13 33#
   (if (Int32.(<=) l_0 u) then
    (((<=) (offset_min intP_a_7_alloc_table a_2) (Int32.to_int l_0)) /\
    (((>=) (offset_max intP_a_7_alloc_table a_2) (Int32.to_int u)) /\
    (forall __framac_tmp3 : int.
     ((((<=) (Int32.to_int l_0) __framac_tmp3) /\
      ((<=) __framac_tmp3 (Int32.to_int u))) -> ((=) true true))))) else
    ((=) true true)))))) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_int32.any_  () ) in
   try
    begin
    (let m_5 = ref (Safe_int32.any_  () ) in
    (let i_0_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (m_5 :=
      (let _jessie_44 = l_0 in
      begin
      (assert {
      (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 82 8 9#
      "expl:Pointer index bounds" true) }); _jessie_44 end));
      begin
      (i_0_0 :=
       (let _jessie_38 = l_0 in
       begin
       (assert {
       (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 82 15 16#
       "expl:Pointer index bounds" true) }); _jessie_38 end));
       'Loop_2:
       loop
       invariant { (#"qsort_c.jc" 215 6 2145# true) }
         variant { (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 95 21 26#
           (Int.(-) (Int32.to_int u) (Int32.to_int !i_0_0))) }
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0, u }
        ensures {
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 93 23 49#
           (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1))
           (Int32.to_int !i_0_0)
           (Int32.to_int
           (select !intP_intM_a_7 (shift a_2 (Int32.to_int l_0))))
           !intP_intM_a_7))
          /\
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 92 23 84#
           (forall k_0 : int.
            ((((<=) (Int.(+) (Int32.to_int l_0) (1)) k_0) /\
             ((<=) k_0 (Int32.to_int !m_5))) ->
             (minimum a_2 (Int32.to_int l_0) (Int32.to_int l_0)
             (Int32.to_int (select !intP_intM_a_7 (shift a_2 k_0)))
             !intP_intM_a_7))))
          /\
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 91 23 84#
           (forall k : int.
            ((((<=) (Int32.to_int l_0) k) /\ ((<=) k (Int32.to_int !m_5))) ->
             (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1))
             (Int32.to_int !i_0_0)
             (Int32.to_int (select !intP_intM_a_7 (shift a_2 k)))
             !intP_intM_a_7))))
          /\
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 23 34#
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 23 34#
           ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 23 29#
            (Int32.(<=) l_0 !i_0_0))
           /\
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 28 34#
           (Int32.(<=) !i_0_0 u)))))
          /\
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 23 34#
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 23 34#
           ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 23 29#
            (Int32.(<=) l_0 !m_5))
           /\
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 28 34#
           (Int32.(<=) !m_5 !i_0_0)))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 88 23 54#
          (permutation a_2 (Int32.to_int l_0) (Int32.to_int u) !intP_intM_a_7
          (at !intP_intM_a_7 'Init)))))))) } ;
         try
          begin
          begin
          (if
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 97 11 16#
          (Safe_int32.(<)  !i_0_0 u )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (i_0_0 :=
            (let _jessie_39 =
            (Safe_int32.(+)  !i_0_0
             (#"qsort_c.jc" 250 57 69# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) in
            begin
            (assert {
            (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 98 8 11#
            "expl:Pointer index bounds" true) }); _jessie_39 end));
            (if
            (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 99 12 23#
            (Safe_int32.(<) 
             (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 99 12 16#
             "expl:Pointer dereference"
             (acc_offset_typesafe  intP_a_7_alloc_table !intP_intM_a_7 a_2
              (Safe_int32.to_int  !i_0_0 ) ))
             (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 99 19 23#
             "expl:Pointer dereference"
             (acc_offset_typesafe  intP_a_7_alloc_table !intP_intM_a_7 a_2
              (Safe_int32.to_int  l_0 ) )) ))
            then
             begin
             begin
             ();
              begin
              (m_5 :=
               (let _jessie_40 =
               (Safe_int32.(+)  !m_5
                (#"qsort_c.jc" 255 59 71# "expl:Integer cast"
                (Safe_int32.of_int (1))) ) in
               begin
               (assert {
               (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 100 20 23#
               "expl:Pointer index bounds" true) }); _jessie_40 end)); () end
             end;
              (let _jessie_43 = a_2 in
              (let _jessie_42 = !m_5 in
              (let _jessie_41 = !i_0_0 in
              (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 100 12 27#
              "expl:Precondition for swap"
              (Function_swap_safe.swap  _jessie_43 _jessie_42 _jessie_41
               intP_intM_a_7 intP_a_7_alloc_table intP_a_7_tag_table )))))
             end else ()) end end; (raise (Loop_continue_exc ())) end with
          Loop_continue_exc _jessie_3 -> () end end end;
       (raise (Goto_while_0_break_exc ())) end end with
     Goto_while_0_break_exc _jessie_1 ->
     'While_0_break:
     'While_0_break:
     begin
     ();
      begin
      any unit
      requires { true } reads { a_2, intP_intM_a_7, l_0 }
      ensures {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 103 15 37#
        (minimum a_2 (Int32.to_int l_0) (Int32.to_int l_0)
        (Int32.to_int
        (select !intP_intM_a_7 (shift a_2 (Int32.to_int !m_5))))
        !intP_intM_a_7)) } ; () end;
      'U__L1:
      begin
      'U__L1: ();
       begin
       (let _jessie_47 = a_2 in
       (let _jessie_46 = l_0 in
       (let _jessie_45 = !m_5 in
       (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 105 4 17#
       "expl:Precondition for swap"
       (Function_swap_safe.swap  _jessie_47 _jessie_46 _jessie_45
        intP_intM_a_7 intP_a_7_alloc_table intP_a_7_tag_table )))));
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 106 15 45#
          (permutation a_2 (Int32.to_int l_0) (Int32.to_int !m_5) (at
          !intP_intM_a_7 'U__L1) !intP_intM_a_7)) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, u }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 107 15 49#
          (permutation a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
          (at !intP_intM_a_7 'U__L1) !intP_intM_a_7)) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 108 15 41#
          (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1))
          (Int32.to_int !i_0_0)
          (Int32.to_int
          (select !intP_intM_a_7 (shift a_2 (Int32.to_int !m_5))))
          !intP_intM_a_7)) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 109 15 37#
          (minimum a_2 (Int32.to_int !m_5) (Int32.to_int !m_5)
          (Int32.to_int
          (select !intP_intM_a_7 (shift a_2 (Int32.to_int l_0))))
          !intP_intM_a_7)) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 110 15 80#
          (forall k_6 : int.
           ((((<=) (Int.(+) (Int32.to_int l_0) (1)) k_6) /\
            ((<=) k_6 (Int.(-) (Int32.to_int !m_5) (1)))) ->
            (minimum a_2 (Int32.to_int !m_5) (Int32.to_int !m_5)
            (Int32.to_int (select !intP_intM_a_7 (shift a_2 k_6)))
            !intP_intM_a_7)))) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0, u }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 111 15 88#
          (forall i_4 : int.
           ((((<=) (Int32.to_int l_0) i_4) /\ ((<=) i_4 (Int32.to_int !m_5)))
            ->
            (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
            (Int32.to_int
            (select (at !intP_intM_a_7 'U__L1) (shift a_2 i_4))) (at
            !intP_intM_a_7 'U__L1))))) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0, u }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 112 15 76#
          (forall i_5 : int.
           ((((<=) (Int32.to_int l_0) i_5) /\ ((<=) i_5 (Int32.to_int !m_5)))
            ->
            (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
            (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_5)))
            !intP_intM_a_7)))) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0, u }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 113 15 80#
          (forall i_6 : int.
           ((((<=) (Int32.to_int l_0) i_6) /\
            ((<=) i_6 (Int.(-) (Int32.to_int !m_5) (1)))) ->
            (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
            (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_6)))
            !intP_intM_a_7)))) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 114 15 76#
          (forall i_7 : int.
           ((((<=) (Int32.to_int l_0) i_7) /\
            ((<=) i_7 (Int.(-) (Int32.to_int !m_5) (1)))) ->
            (minimum a_2 (Int32.to_int !m_5) (Int32.to_int !m_5)
            (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_7)))
            !intP_intM_a_7)))) } ; () end;
        begin
        any unit
        requires { true } reads { a_2, intP_intM_a_7, l_0, u }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 115 15 76#
          (forall i_8 : int.
           ((((<=) (Int32.to_int l_0) i_8) /\
            ((<=) i_8 (Int.(-) (Int32.to_int !m_5) (1)))) ->
            (minimum a_2 (Int32.to_int !m_5) (Int32.to_int u)
            (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_8)))
            !intP_intM_a_7)))) } ; () end;
        begin
        (return :=
         (let _jessie_48 = !m_5 in
         begin
         (assert { (#"qsort_c.jc" 389 7 15# "expl:Pointer index bounds" true)
         }); _jessie_48 end)); (raise Return) end end end end end)); 
     absurd  end with Return -> !return end)
  
end

module Function_swap

  use import core.Tag_table_type 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pset_union 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_Swap 
  
  use enum.Int32 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  val swap
  (a_1_0 : (pointer intP)) 
   (i : Int32.t) 
    (j : Int32.t) 
     (intP_intM_a_1_6 : ref (memory intP Int32.t)) 
      (intP_a_1_6_alloc_table : (alloc_table intP)) 
       (intP_a_1_6_tag_table : (tag_table intP)) : unit
        requires { true } reads { intP_intM_a_1_6 } writes { intP_intM_a_1_6
        }
        ensures {
          ((#"qsort_c.jc" 150 10 68# "expl:Assigns clause"
           (not_assigns intP_a_1_6_alloc_table intP_a_1_6_alloc_table (old
           !intP_intM_a_1_6) !intP_intM_a_1_6
           (pset_union (pset_singleton (shift a_1_0 (Int32.to_int i)))
           (pset_singleton (shift a_1_0 (Int32.to_int j))))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 58 12 36#
          "expl:Ensures clause"
          (_Swap a_1_0 (Int32.to_int i) (Int32.to_int j) !intP_intM_a_1_6
          (old !intP_intM_a_1_6)))) }
  
end

module Function_partition_behaviors
#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 81 4 35#
"expl:partition, behaviors"

  use Unsafe_int32 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import core.Shift_unsafe 
  
  use import Root_intP 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_swap 
  
  use import Exceptions 
  
  use import core.Assigns 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_unsafe 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  let partition_ensures_default
  #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 81 4 35#
  "expl:Function partition, default behavior" =
  fun
   (a_2 : (pointer intP)) (l_0 : Int32.t) (u : Int32.t) (intP_intM_a_7 : ref
   (memory intP Int32.t)) (intP_a_7_alloc_table : (alloc_table intP))
   (intP_a_7_tag_table : (tag_table intP)) 
   requires {
   (((allocated intP_a_7_alloc_table a_2) ->
     (((=) (typeof intP_a_7_tag_table a_2) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_7_alloc_table a_2) i) /\
       ((<) i (offset_max intP_a_7_alloc_table a_2))) ->
       ((=) (typeof intP_a_7_tag_table (shift a_2 i)) intP_tag)))))
   /\
   (#"qsort_c.jc" 175 12 1099#
   ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 73 13 23#
    ((>=) (Int32.to_int u) (Int.(+) (Int32.to_int l_0) (1))))
   /\
   (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 74 13 33#
   (if (Int32.(<=) l_0 u) then
    (((<=) (offset_min intP_a_7_alloc_table a_2) (Int32.to_int l_0)) /\
    (((>=) (offset_max intP_a_7_alloc_table a_2) (Int32.to_int u)) /\
    (forall __framac_tmp3 : int.
     ((((<=) (Int32.to_int l_0) __framac_tmp3) /\
      ((<=) __framac_tmp3 (Int32.to_int u))) -> ((=) true true))))) else
    ((=) true true)))))) }
   ensures {
     ("expl:Postcondition"
     ((#"qsort_c.jc" 189 10 53# "expl:Assigns clause"
      (not_assigns intP_a_7_alloc_table intP_a_7_alloc_table (old
      !intP_intM_a_7) !intP_intM_a_7
      (pset_range (pset_singleton a_2) (Int32.to_int l_0) (Int32.to_int u))))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
     "expl:Ensures clause"
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
     "expl:Ensures clause"
     ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
      "expl:Ensures clause"
      (permutation a_2 (Int32.to_int l_0) (Int32.to_int u) !intP_intM_a_7
      (old !intP_intM_a_7)))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
     "expl:Ensures clause"
     ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 77 12 24#
      "expl:Ensures clause" (Int32.(<=) l_0 result))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
     "expl:Ensures clause"
     ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 77 17 29#
      "expl:Ensures clause" (Int32.(<=) result u))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
     "expl:Ensures clause"
     ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 78 12 85#
      "expl:Ensures clause"
      (forall k_5 : int.
       ((((<=) (Int32.to_int l_0) k_5) /\
        ((<=) k_5 (Int.(-) (Int32.to_int result) (1)))) ->
        (minimum a_2 (Int32.to_int result) (Int32.to_int u)
        (Int32.to_int (select !intP_intM_a_7 (shift a_2 k_5)))
        !intP_intM_a_7))))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 79 12 50#
     "expl:Ensures clause"
     (minimum a_2 (Int.(+) (Int32.to_int result) (1)) (Int32.to_int u)
     (Int32.to_int (select !intP_intM_a_7 (shift a_2 (Int32.to_int result))))
     !intP_intM_a_7))))))))))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_int32.any_  () ) in
   try
    begin
    (let m_5 = ref (Unsafe_int32.any_  () ) in
    (let i_0_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (m_5 := l_0);
      begin
      (i_0_0 := l_0);
       'Loop_1:
       loop
       invariant
         { (((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 88 23 54#
             (permutation a_2 (Int32.to_int l_0) (Int32.to_int u)
             !intP_intM_a_7 (at !intP_intM_a_7 'Init)))
            &&
            ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 23 34#
             (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 23 34#
             ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 23 29#
              (Int32.(<=) l_0 !m_5))
             /\
             (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 89 28 34#
             (Int32.(<=) !m_5 !i_0_0)))))
            &&
            ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 23 34#
             (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 23 34#
             ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 23 29#
              (Int32.(<=) l_0 !i_0_0))
             /\
             (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 90 28 34#
             (Int32.(<=) !i_0_0 u)))))
            &&
            ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 91 23 84#
             (forall k : int.
              ((((<=) (Int32.to_int l_0) k) /\ ((<=) k (Int32.to_int !m_5)))
               ->
               (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1))
               (Int32.to_int !i_0_0)
               (Int32.to_int (select !intP_intM_a_7 (shift a_2 k)))
               !intP_intM_a_7))))
            &&
            ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 92 23 84#
             (forall k_0 : int.
              ((((<=) (Int.(+) (Int32.to_int l_0) (1)) k_0) /\
               ((<=) k_0 (Int32.to_int !m_5))) ->
               (minimum a_2 (Int32.to_int l_0) (Int32.to_int l_0)
               (Int32.to_int (select !intP_intM_a_7 (shift a_2 k_0)))
               !intP_intM_a_7))))
            &&
            (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 93 23 49#
            (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1))
            (Int32.to_int !i_0_0)
            (Int32.to_int
            (select !intP_intM_a_7 (shift a_2 (Int32.to_int l_0))))
            !intP_intM_a_7)))))))
           /\
           ((#"qsort_c.jc" 215 6 2145# "expl:Assigns clause"
            (not_assigns intP_a_7_alloc_table intP_a_7_alloc_table (at
            !intP_intM_a_7 'Loop_1) !intP_intM_a_7
            (pset_range (pset_singleton a_2) (Int32.to_int l_0)
            (Int32.to_int !i_0_0))))
           /\
           (#"qsort_c.jc" 189 10 53# "expl:Assigns clause"
           (not_assigns intP_a_7_alloc_table intP_a_7_alloc_table (at
           !intP_intM_a_7 'Init) !intP_intM_a_7
           (pset_range (pset_singleton a_2) (Int32.to_int l_0)
           (Int32.to_int u)))))) } 
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          (if
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 97 11 16#
          (Unsafe_int32.(<)  !i_0_0 u )) then ()
          else (raise (Goto_while_0_break_exc ())));
           begin
           (i_0_0 :=
            (Unsafe_int32.(+)  !i_0_0
             (#"qsort_c.jc" 250 57 69# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) ));
            (if
            (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 99 12 23#
            (Unsafe_int32.(<) 
             (acc  !intP_intM_a_7
              (shift_  a_2 (Unsafe_int32.to_int  !i_0_0 ) ) )
             (acc  !intP_intM_a_7 (shift_  a_2 (Unsafe_int32.to_int  l_0 ) )
              ) ))
            then
             begin
             begin
             ();
              begin
              (m_5 :=
               (Unsafe_int32.(+)  !m_5
                (#"qsort_c.jc" 255 59 71# "expl:Integer cast"
                (Unsafe_int32.of_int (1))) )); () end end;
              (let _jessie_32 = a_2 in
              (let _jessie_31 = !m_5 in
              (let _jessie_30 = !i_0_0 in
              (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 100 12 27#
              "expl:Precondition for swap"
              (Function_swap.swap  _jessie_32 _jessie_31 _jessie_30
               intP_intM_a_7 intP_a_7_alloc_table intP_a_7_tag_table )))))
             end else ()) end end; (raise (Loop_continue_exc ())) end with
          Loop_continue_exc _jessie_3 -> () end end end;
       (raise (Goto_while_0_break_exc ())) end end with
     Goto_while_0_break_exc _jessie_1 ->
     'While_0_break:
     'While_0_break:
     begin
     ();
      begin
      (assert {
      (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 103 15 37#
      "expl:Assertion in line 103"
      (minimum a_2 (Int32.to_int l_0) (Int32.to_int l_0)
      (Int32.to_int (select !intP_intM_a_7 (shift a_2 (Int32.to_int !m_5))))
      !intP_intM_a_7)) }); () end;
      'U__L1:
      begin
      'U__L1: ();
       begin
       (let _jessie_36 = a_2 in
       (let _jessie_35 = l_0 in
       (let _jessie_34 = !m_5 in
       (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 105 4 17#
       "expl:Precondition for swap"
       (Function_swap.swap  _jessie_36 _jessie_35 _jessie_34 intP_intM_a_7
        intP_a_7_alloc_table intP_a_7_tag_table )))));
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 106 15 45#
        "expl:Assertion in line 106"
        (permutation a_2 (Int32.to_int l_0) (Int32.to_int !m_5) (at
        !intP_intM_a_7 'U__L1) !intP_intM_a_7)) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 107 15 49#
        "expl:Assertion in line 107"
        (permutation a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
        (at !intP_intM_a_7 'U__L1) !intP_intM_a_7)) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 108 15 41#
        "expl:Assertion in line 108"
        (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int !i_0_0)
        (Int32.to_int
        (select !intP_intM_a_7 (shift a_2 (Int32.to_int !m_5))))
        !intP_intM_a_7)) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 109 15 37#
        "expl:Assertion in line 109"
        (minimum a_2 (Int32.to_int !m_5) (Int32.to_int !m_5)
        (Int32.to_int (select !intP_intM_a_7 (shift a_2 (Int32.to_int l_0))))
        !intP_intM_a_7)) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 110 15 80#
        "expl:Assertion in line 110"
        (forall k_6 : int.
         ((((<=) (Int.(+) (Int32.to_int l_0) (1)) k_6) /\
          ((<=) k_6 (Int.(-) (Int32.to_int !m_5) (1)))) ->
          (minimum a_2 (Int32.to_int !m_5) (Int32.to_int !m_5)
          (Int32.to_int (select !intP_intM_a_7 (shift a_2 k_6)))
          !intP_intM_a_7)))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 111 15 88#
        "expl:Assertion in line 111"
        (forall i_4 : int.
         ((((<=) (Int32.to_int l_0) i_4) /\ ((<=) i_4 (Int32.to_int !m_5)))
          ->
          (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
          (Int32.to_int (select (at !intP_intM_a_7 'U__L1) (shift a_2 i_4)))
          (at !intP_intM_a_7 'U__L1))))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 112 15 76#
        "expl:Assertion in line 112"
        (forall i_5 : int.
         ((((<=) (Int32.to_int l_0) i_5) /\ ((<=) i_5 (Int32.to_int !m_5)))
          ->
          (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
          (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_5)))
          !intP_intM_a_7)))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 113 15 80#
        "expl:Assertion in line 113"
        (forall i_6 : int.
         ((((<=) (Int32.to_int l_0) i_6) /\
          ((<=) i_6 (Int.(-) (Int32.to_int !m_5) (1)))) ->
          (minimum a_2 (Int.(+) (Int32.to_int !m_5) (1)) (Int32.to_int u)
          (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_6)))
          !intP_intM_a_7)))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 114 15 76#
        "expl:Assertion in line 114"
        (forall i_7 : int.
         ((((<=) (Int32.to_int l_0) i_7) /\
          ((<=) i_7 (Int.(-) (Int32.to_int !m_5) (1)))) ->
          (minimum a_2 (Int32.to_int !m_5) (Int32.to_int !m_5)
          (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_7)))
          !intP_intM_a_7)))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 115 15 76#
        "expl:Assertion in line 115"
        (forall i_8 : int.
         ((((<=) (Int32.to_int l_0) i_8) /\
          ((<=) i_8 (Int.(-) (Int32.to_int !m_5) (1)))) ->
          (minimum a_2 (Int32.to_int !m_5) (Int32.to_int u)
          (Int32.to_int (select !intP_intM_a_7 (shift a_2 i_8)))
          !intP_intM_a_7)))) }); () end;
        begin (return := !m_5); (raise Return) end end end end end)); 
     absurd  end with Return -> !return end)
  
end

module Function_partition_safe

  use import core.Tag_table_type 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  val partition
  (a_2 : (pointer intP)) 
   (l_0 : Int32.t) 
    (u : Int32.t) 
     (intP_intM_a_7 : ref (memory intP Int32.t)) 
      (intP_a_7_alloc_table : (alloc_table intP)) 
       (intP_a_7_tag_table : (tag_table intP)) : Int32.t
        requires {
          ("expl:Internal"
          (#"qsort_c.jc" 175 12 1099# "expl:Requires clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 73 13 23#
           "expl:Requires clause"
           ((>=) (Int32.to_int u) (Int.(+) (Int32.to_int l_0) (1))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 74 13 33#
          "expl:Requires clause"
          (if (Int32.(<=) l_0 u) then
           (((<=) (offset_min intP_a_7_alloc_table a_2) (Int32.to_int l_0))
           /\
           (((>=) (offset_max intP_a_7_alloc_table a_2) (Int32.to_int u)) /\
           (forall __framac_tmp3 : int.
            ((((<=) (Int32.to_int l_0) __framac_tmp3) /\
             ((<=) __framac_tmp3 (Int32.to_int u))) -> ((=) true true)))))
           else ((=) true true)))))) }
        reads { intP_intM_a_7 } writes { intP_intM_a_7 }
        ensures {
          ((#"qsort_c.jc" 189 10 53# "expl:Assigns clause"
           (not_assigns intP_a_7_alloc_table intP_a_7_alloc_table (old
           !intP_intM_a_7) !intP_intM_a_7
           (pset_range (pset_singleton a_2) (Int32.to_int l_0)
           (Int32.to_int u))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
           "expl:Ensures clause"
           (permutation a_2 (Int32.to_int l_0) (Int32.to_int u)
           !intP_intM_a_7 (old !intP_intM_a_7)))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 77 12 24#
           "expl:Ensures clause" (Int32.(<=) l_0 result))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 77 17 29#
           "expl:Ensures clause" (Int32.(<=) result u))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 78 12 85#
           "expl:Ensures clause"
           (forall k_5 : int.
            ((((<=) (Int32.to_int l_0) k_5) /\
             ((<=) k_5 (Int.(-) (Int32.to_int result) (1)))) ->
             (minimum a_2 (Int32.to_int result) (Int32.to_int u)
             (Int32.to_int (select !intP_intM_a_7 (shift a_2 k_5)))
             !intP_intM_a_7))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 79 12 50#
          "expl:Ensures clause"
          (minimum a_2 (Int.(+) (Int32.to_int result) (1)) (Int32.to_int u)
          (Int32.to_int
          (select !intP_intM_a_7 (shift a_2 (Int32.to_int result))))
          !intP_intM_a_7)))))))))))) }
  
end

theory Logic_ordered

  use import Root_intP 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate ordered (a : (pointer intP)) (n_1 : int) (m : int)
  (intP_intM_a_2_at_L : (memory intP Int32.t))
  =
     (forall k_1 : int.
      ((((<=) n_1 k_1) /\ ((<=) k_1 m)) ->
       (minimum a k_1 m
       (Int32.to_int (select intP_intM_a_2_at_L (shift a k_1)))
       intP_intM_a_2_at_L)))
  
  
end

module Function_qsort_safe

  use import core.Tag_table_type 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_ordered 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  val qsort
  (a_0_0 : (pointer intP)) 
   (l_0_0 : Int32.t) 
    (u_0 : Int32.t) 
     (intP_intM_a_0_8 : ref (memory intP Int32.t)) 
      (intP_a_0_8_alloc_table : (alloc_table intP)) 
       (intP_a_0_8_tag_table : (tag_table intP)) : unit
        requires {
          ("expl:Internal"
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 121 13 33#
          "expl:Requires clause"
          (if (Int32.(<=) l_0_0 u_0) then
           (((<=) (offset_min intP_a_0_8_alloc_table a_0_0)
            (Int32.to_int l_0_0))
           /\
           (((>=) (offset_max intP_a_0_8_alloc_table a_0_0)
            (Int32.to_int u_0))
           /\
           (forall __framac_tmp4 : int.
            ((((<=) (Int32.to_int l_0_0) __framac_tmp4) /\
             ((<=) __framac_tmp4 (Int32.to_int u_0))) -> ((=) true true)))))
           else ((=) true true)))) }
        reads { intP_intM_a_0_8 } writes { intP_intM_a_0_8 }
        ensures {
          ((#"qsort_c.jc" 408 10 59# "expl:Assigns clause"
           (not_assigns intP_a_0_8_alloc_table intP_a_0_8_alloc_table (old
           !intP_intM_a_0_8) !intP_intM_a_0_8
           (pset_range (pset_singleton a_0_0) (Int32.to_int l_0_0)
           (Int32.to_int u_0))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
          "expl:Ensures clause"
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
           "expl:Ensures clause"
           (ordered a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
           !intP_intM_a_0_8))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 125 12 43#
          "expl:Ensures clause"
          (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
          !intP_intM_a_0_8 (old !intP_intM_a_0_8))))))) }
  
end

module Function_qsort_safety
#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 127 5 32# "expl:qsort, safety"

  use import core.Zwf 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use Safe_int32 
  
  use import Root_intP 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_qsort_safe 
  
  use Function_partition_safe 
  
  use import Exceptions 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  let qsort #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 127 5 32#
  "expl:Function qsort, safety" =
  fun
   (a_0_0 : (pointer intP)) (l_0_0 : Int32.t) (u_0 : Int32.t)
   (intP_intM_a_0_8 : ref (memory intP Int32.t)) (intP_a_0_8_alloc_table :
   (alloc_table intP)) (intP_a_0_8_tag_table : (tag_table intP)) 
   requires {
   (((allocated intP_a_0_8_alloc_table a_0_0) ->
     (((=) (typeof intP_a_0_8_tag_table a_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_0_8_alloc_table a_0_0) i) /\
       ((<) i (offset_max intP_a_0_8_alloc_table a_0_0))) ->
       ((=) (typeof intP_a_0_8_tag_table (shift a_0_0 i)) intP_tag)))))
   /\
   (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 121 13 33#
   (if (Int32.(<=) l_0_0 u_0) then
    (((<=) (offset_min intP_a_0_8_alloc_table a_0_0) (Int32.to_int l_0_0)) /\
    (((>=) (offset_max intP_a_0_8_alloc_table a_0_0) (Int32.to_int u_0)) /\
    (forall __framac_tmp4 : int.
     ((((<=) (Int32.to_int l_0_0) __framac_tmp4) /\
      ((<=) __framac_tmp4 (Int32.to_int u_0))) -> ((=) true true))))) else
    ((=) true true)))) } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let m_0_0 = ref (Safe_int32.any_  () ) in
    try
     begin
     (if
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 129 8 14#
     (Safe_int32.(<=)  u_0 l_0_0 )) then (raise (Return_label_exc ()))
     else
      begin
      (m_0_0 :=
       (let _jessie_59 =
       (let _jessie_62 = a_0_0 in
       (let _jessie_61 = l_0_0 in
       (let _jessie_60 = u_0 in
       (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 133 16 34#
       "expl:Precondition for partition"
       (Function_partition_safe.partition  _jessie_62 _jessie_61 _jessie_60
        intP_intM_a_0_8 intP_a_0_8_alloc_table intP_a_0_8_tag_table ))))) in
       begin
       (assert {
       (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 133 16 34#
       "expl:Pointer index bounds" true) }); _jessie_59 end));
       'U__Lb1:
       begin
       'U__Lb1: ();
        (if
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 138 12 17#
        (Safe_int32.(>)  !m_0_0 l_0_0 ))
        then
         (let _jessie_65 = a_0_0 in
         (let _jessie_64 = l_0_0 in
         (let _jessie_63 =
         (Safe_int32.(-)  !m_0_0
          (#"qsort_c.jc" 425 67 79# "expl:Integer cast"
          (Safe_int32.of_int (1))) ) in
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 138 19 37#
         "expl:Variant decreases"
         begin
         (check {
         (zwf_zero (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 122 14 19#
         (Int.(-) (Int32.to_int _jessie_63) (Int32.to_int _jessie_64)))
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 122 14 19#
         (Int.(-) (Int32.to_int u_0) (Int32.to_int l_0_0)))) });
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 138 19 37#
          "expl:Precondition for qsort"
          (Function_qsort_safe.qsort  _jessie_65 _jessie_64 _jessie_63
           intP_intM_a_0_8 intP_a_0_8_alloc_table intP_a_0_8_tag_table )) end))))
        else ());
        begin
        any unit
        requires { true } reads { a_0_0, intP_intM_a_0_8, u_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 139 19 50#
          (permutation a_0_0 (Int32.to_int !m_0_0) (Int32.to_int u_0)
          !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb1))) } ; () end;
        begin
        any unit
        requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 140 19 54#
          (permutation a_0_0 (Int32.to_int l_0_0)
          (Int.(-) (Int32.to_int !m_0_0) (1)) !intP_intM_a_0_8 (at
          !intP_intM_a_0_8 'U__Lb1))) } ; () end;
        begin
        any unit
        requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 141 19 50#
          (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
          !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb1))) } ; () end;
        begin
        any unit
        requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 142 19 90#
          (forall k_7 : int.
           ((((<=) (Int32.to_int l_0_0) k_7) /\
            ((<=) k_7 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
            (minimum a_0_0 (Int32.to_int (at !m_0_0 'U__Lb1))
            (Int32.to_int u_0)
            (Int32.to_int
            (select (at !intP_intM_a_0_8 'U__Lb1) (shift a_0_0 k_7))) (at
            !intP_intM_a_0_8 'U__Lb1))))) } ; () end;
        begin
        any unit
        requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 143 19 80#
          (forall k_8 : int.
           ((((<=) (Int32.to_int l_0_0) k_8) /\
            ((<=) k_8 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
            (minimum a_0_0 (Int32.to_int !m_0_0) (Int32.to_int u_0)
            (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_8)))
            !intP_intM_a_0_8)))) } ; () end;
        begin
        any unit
        requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 144 19 84#
          (forall k_9 : int.
           ((((<=) (Int32.to_int l_0_0) k_9) /\
            ((<=) k_9 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
            (minimum a_0_0 k_9 (Int.(-) (Int32.to_int !m_0_0) (1))
            (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_9)))
            !intP_intM_a_0_8)))) } ; () end;
        begin
        any unit
        requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
        ensures {
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 145 19 80#
          (forall k_10 : int.
           ((((<=) (Int32.to_int l_0_0) k_10) /\
            ((<=) k_10 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
            (minimum a_0_0 k_10 (Int32.to_int u_0)
            (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_10)))
            !intP_intM_a_0_8)))) } ; () end;
        'U__Lb2:
        begin
        'U__Lb2: ();
         (if
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 150 12 17#
         (Safe_int32.(<)  !m_0_0 u_0 ))
         then
          (let _jessie_68 = a_0_0 in
          (let _jessie_67 =
          (Safe_int32.(+)  !m_0_0
           (#"qsort_c.jc" 510 67 79# "expl:Integer cast"
           (Safe_int32.of_int (1))) ) in
          (let _jessie_66 = u_0 in
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 150 19 37#
          "expl:Variant decreases"
          begin
          (check {
          (zwf_zero
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 122 14 19#
          (Int.(-) (Int32.to_int _jessie_66) (Int32.to_int _jessie_67)))
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 122 14 19#
          (Int.(-) (Int32.to_int u_0) (Int32.to_int l_0_0)))) });
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 150 19 37#
           "expl:Precondition for qsort"
           (Function_qsort_safe.qsort  _jessie_68 _jessie_67 _jessie_66
            intP_intM_a_0_8 intP_a_0_8_alloc_table intP_a_0_8_tag_table ))
          end)))) else ());
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, u_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 152 19 54#
           (permutation a_0_0 (Int.(+) (Int32.to_int !m_0_0) (1))
           (Int32.to_int u_0) !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb2)))
           } ; () end;
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 153 19 50#
           (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int !m_0_0)
           !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb2))) } ; () end;
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 154 19 50#
           (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
           !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb2))) } ; () end;
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 155 19 95#
           (forall k_11 : int.
            ((((<=) (Int32.to_int l_0_0) k_11) /\
             ((<=) k_11 (Int32.to_int !m_0_0))) ->
             (minimum a_0_0 (Int.(+) (Int32.to_int !m_0_0) (1))
             (Int32.to_int u_0)
             (Int32.to_int
             (select (at !intP_intM_a_0_8 'U__Lb2) (shift a_0_0 k_11))) (at
             !intP_intM_a_0_8 'U__Lb2))))) } ; () end;
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 156 19 80#
           (forall k_12 : int.
            ((((<=) (Int32.to_int l_0_0) k_12) /\
             ((<=) k_12 (Int32.to_int !m_0_0))) ->
             (minimum a_0_0 (Int.(+) (Int32.to_int !m_0_0) (1))
             (Int32.to_int u_0)
             (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_12)))
             !intP_intM_a_0_8)))) } ; () end;
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 158 19 76#
           (forall k_13 : int.
            ((((<=) (Int32.to_int l_0_0) k_13) /\
             ((<=) k_13 (Int32.to_int !m_0_0))) ->
             (minimum a_0_0 k_13 (Int32.to_int !m_0_0)
             (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_13)))
             !intP_intM_a_0_8)))) } ; () end;
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, l_0_0, u_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 159 19 76#
           (forall k_14 : int.
            ((((<=) (Int32.to_int l_0_0) k_14) /\
             ((<=) k_14 (Int32.to_int !m_0_0))) ->
             (minimum a_0_0 k_14 (Int32.to_int u_0)
             (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_14)))
             !intP_intM_a_0_8)))) } ; () end;
         begin
         any unit
         requires { true } reads { a_0_0, intP_intM_a_0_8, u_0 }
         ensures {
           (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 160 19 80#
           (forall k_15 : int.
            ((((<=) (Int.(+) (Int32.to_int !m_0_0) (1)) k_15) /\
             ((<=) k_15 (Int32.to_int u_0))) ->
             (minimum a_0_0 k_15 (Int32.to_int u_0)
             (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_15)))
             !intP_intM_a_0_8)))) } ; () end end end end);
      (raise (Return_label_exc ())) end with Return_label_exc _jessie_4 ->
     'Return_label: 'Return_label: (raise Return) end); (raise Return) end
    with Return -> () end
  
end

module Function_partition

  use import core.Tag_table_type 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  val partition
  (a_2 : (pointer intP)) 
   (l_0 : Int32.t) 
    (u : Int32.t) 
     (intP_intM_a_7 : ref (memory intP Int32.t)) 
      (intP_a_7_alloc_table : (alloc_table intP)) 
       (intP_a_7_tag_table : (tag_table intP)) : Int32.t
        requires { true } reads { intP_intM_a_7 } writes { intP_intM_a_7 }
        ensures {
          ((#"qsort_c.jc" 189 10 53# "expl:Assigns clause"
           (not_assigns intP_a_7_alloc_table intP_a_7_alloc_table (old
           !intP_intM_a_7) !intP_intM_a_7
           (pset_range (pset_singleton a_2) (Int32.to_int l_0)
           (Int32.to_int u))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
           "expl:Ensures clause"
           (permutation a_2 (Int32.to_int l_0) (Int32.to_int u)
           !intP_intM_a_7 (old !intP_intM_a_7)))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 77 12 24#
           "expl:Ensures clause" (Int32.(<=) l_0 result))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 77 17 29#
           "expl:Ensures clause" (Int32.(<=) result u))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 76 12 43#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 78 12 85#
           "expl:Ensures clause"
           (forall k_5 : int.
            ((((<=) (Int32.to_int l_0) k_5) /\
             ((<=) k_5 (Int.(-) (Int32.to_int result) (1)))) ->
             (minimum a_2 (Int32.to_int result) (Int32.to_int u)
             (Int32.to_int (select !intP_intM_a_7 (shift a_2 k_5)))
             !intP_intM_a_7))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 79 12 50#
          "expl:Ensures clause"
          (minimum a_2 (Int.(+) (Int32.to_int result) (1)) (Int32.to_int u)
          (Int32.to_int
          (select !intP_intM_a_7 (shift a_2 (Int32.to_int result))))
          !intP_intM_a_7)))))))))))) }
  
end

module Function_qsort

  use import core.Tag_table_type 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_ordered 
  
  use enum.Int32 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  val qsort
  (a_0_0 : (pointer intP)) 
   (l_0_0 : Int32.t) 
    (u_0 : Int32.t) 
     (intP_intM_a_0_8 : ref (memory intP Int32.t)) 
      (intP_a_0_8_alloc_table : (alloc_table intP)) 
       (intP_a_0_8_tag_table : (tag_table intP)) : unit
        requires { true } reads { intP_intM_a_0_8 } writes { intP_intM_a_0_8
        }
        ensures {
          ((#"qsort_c.jc" 408 10 59# "expl:Assigns clause"
           (not_assigns intP_a_0_8_alloc_table intP_a_0_8_alloc_table (old
           !intP_intM_a_0_8) !intP_intM_a_0_8
           (pset_range (pset_singleton a_0_0) (Int32.to_int l_0_0)
           (Int32.to_int u_0))))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
          "expl:Ensures clause"
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
          "expl:Ensures clause"
          ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
           "expl:Ensures clause"
           (ordered a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
           !intP_intM_a_0_8))
          /\
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 125 12 43#
          "expl:Ensures clause"
          (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
          !intP_intM_a_0_8 (old !intP_intM_a_0_8))))))) }
  
end

module Function_qsort_behaviors
#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 127 5 32#
"expl:qsort, behaviors"

  use Unsafe_int32 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import Root_intP 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_permutation 
  
  use import Logic_ordered 
  
  use import Logic_minimum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_qsort 
  
  use Function_partition 
  
  use import Exceptions 
  
  use import core.Assigns 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_permutation_split 
  
  use import Lemma_permutation_saves_min 
  
  use import Lemma_permutation_saves_many_min 
  
  use import Lemma_permutation_reads 
  
  use import Lemma_middle 
  
  let qsort_ensures_default
  #"/home/kornevgen/mfsp/examples/qsort/qsort.c" 127 5 32#
  "expl:Function qsort, default behavior" =
  fun
   (a_0_0 : (pointer intP)) (l_0_0 : Int32.t) (u_0 : Int32.t)
   (intP_intM_a_0_8 : ref (memory intP Int32.t)) (intP_a_0_8_alloc_table :
   (alloc_table intP)) (intP_a_0_8_tag_table : (tag_table intP)) 
   requires {
   (((allocated intP_a_0_8_alloc_table a_0_0) ->
     (((=) (typeof intP_a_0_8_tag_table a_0_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min intP_a_0_8_alloc_table a_0_0) i) /\
       ((<) i (offset_max intP_a_0_8_alloc_table a_0_0))) ->
       ((=) (typeof intP_a_0_8_tag_table (shift a_0_0 i)) intP_tag)))))
   /\
   (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 121 13 33#
   (if (Int32.(<=) l_0_0 u_0) then
    (((<=) (offset_min intP_a_0_8_alloc_table a_0_0) (Int32.to_int l_0_0)) /\
    (((>=) (offset_max intP_a_0_8_alloc_table a_0_0) (Int32.to_int u_0)) /\
    (forall __framac_tmp4 : int.
     ((((<=) (Int32.to_int l_0_0) __framac_tmp4) /\
      ((<=) __framac_tmp4 (Int32.to_int u_0))) -> ((=) true true))))) else
    ((=) true true)))) }
   ensures {
     ("expl:Postcondition"
     ((#"qsort_c.jc" 408 10 59# "expl:Assigns clause"
      (not_assigns intP_a_0_8_alloc_table intP_a_0_8_alloc_table (old
      !intP_intM_a_0_8) !intP_intM_a_0_8
      (pset_range (pset_singleton a_0_0) (Int32.to_int l_0_0)
      (Int32.to_int u_0))))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
     "expl:Ensures clause"
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
     "expl:Ensures clause"
     ((#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 124 12 28#
      "expl:Ensures clause"
      (ordered a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
      !intP_intM_a_0_8))
     /\
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 125 12 43#
     "expl:Ensures clause"
     (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
     !intP_intM_a_0_8 (old !intP_intM_a_0_8)))))))) }  ->
   'Init:
   try
    begin
    (let m_0_0 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (if
     (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 129 8 14#
     (Unsafe_int32.(<=)  u_0 l_0_0 )) then (raise (Return_label_exc ()))
     else
      begin
      (m_0_0 :=
       (let _jessie_52 = a_0_0 in
       (let _jessie_51 = l_0_0 in
       (let _jessie_50 = u_0 in
       (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 133 16 34#
       "expl:Precondition for partition"
       (Function_partition.partition  _jessie_52 _jessie_51 _jessie_50
        intP_intM_a_0_8 intP_a_0_8_alloc_table intP_a_0_8_tag_table ))))));
       'U__Lb1:
       begin
       'U__Lb1: ();
        (if
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 138 12 17#
        (Unsafe_int32.(>)  !m_0_0 l_0_0 ))
        then
         (let _jessie_55 = a_0_0 in
         (let _jessie_54 = l_0_0 in
         (let _jessie_53 =
         (Unsafe_int32.(-)  !m_0_0
          (#"qsort_c.jc" 425 67 79# "expl:Integer cast"
          (Unsafe_int32.of_int (1))) ) in
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 138 19 37#
         "expl:Precondition for qsort"
         (Function_qsort.qsort  _jessie_55 _jessie_54 _jessie_53
          intP_intM_a_0_8 intP_a_0_8_alloc_table intP_a_0_8_tag_table )))))
        else ());
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 139 19 50#
        "expl:Assertion in line 139"
        (permutation a_0_0 (Int32.to_int !m_0_0) (Int32.to_int u_0)
        !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb1))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 140 19 54#
        "expl:Assertion in line 140"
        (permutation a_0_0 (Int32.to_int l_0_0)
        (Int.(-) (Int32.to_int !m_0_0) (1)) !intP_intM_a_0_8 (at
        !intP_intM_a_0_8 'U__Lb1))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 141 19 50#
        "expl:Assertion in line 141"
        (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
        !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb1))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 142 19 90#
        "expl:Assertion in line 142"
        (forall k_7 : int.
         ((((<=) (Int32.to_int l_0_0) k_7) /\
          ((<=) k_7 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
          (minimum a_0_0 (Int32.to_int (at !m_0_0 'U__Lb1))
          (Int32.to_int u_0)
          (Int32.to_int
          (select (at !intP_intM_a_0_8 'U__Lb1) (shift a_0_0 k_7))) (at
          !intP_intM_a_0_8 'U__Lb1))))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 143 19 80#
        "expl:Assertion in line 143"
        (forall k_8 : int.
         ((((<=) (Int32.to_int l_0_0) k_8) /\
          ((<=) k_8 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
          (minimum a_0_0 (Int32.to_int !m_0_0) (Int32.to_int u_0)
          (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_8)))
          !intP_intM_a_0_8)))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 144 19 84#
        "expl:Assertion in line 144"
        (forall k_9 : int.
         ((((<=) (Int32.to_int l_0_0) k_9) /\
          ((<=) k_9 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
          (minimum a_0_0 k_9 (Int.(-) (Int32.to_int !m_0_0) (1))
          (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_9)))
          !intP_intM_a_0_8)))) }); () end;
        begin
        (assert {
        (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 145 19 80#
        "expl:Assertion in line 145"
        (forall k_10 : int.
         ((((<=) (Int32.to_int l_0_0) k_10) /\
          ((<=) k_10 (Int.(-) (Int32.to_int !m_0_0) (1)))) ->
          (minimum a_0_0 k_10 (Int32.to_int u_0)
          (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_10)))
          !intP_intM_a_0_8)))) }); () end;
        'U__Lb2:
        begin
        'U__Lb2: ();
         (if
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 150 12 17#
         (Unsafe_int32.(<)  !m_0_0 u_0 ))
         then
          (let _jessie_58 = a_0_0 in
          (let _jessie_57 =
          (Unsafe_int32.(+)  !m_0_0
           (#"qsort_c.jc" 510 67 79# "expl:Integer cast"
           (Unsafe_int32.of_int (1))) ) in
          (let _jessie_56 = u_0 in
          (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 150 19 37#
          "expl:Precondition for qsort"
          (Function_qsort.qsort  _jessie_58 _jessie_57 _jessie_56
           intP_intM_a_0_8 intP_a_0_8_alloc_table intP_a_0_8_tag_table )))))
         else ());
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 152 19 54#
         "expl:Assertion in line 152"
         (permutation a_0_0 (Int.(+) (Int32.to_int !m_0_0) (1))
         (Int32.to_int u_0) !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb2)))
         }); () end;
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 153 19 50#
         "expl:Assertion in line 153"
         (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int !m_0_0)
         !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb2))) }); () end;
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 154 19 50#
         "expl:Assertion in line 154"
         (permutation a_0_0 (Int32.to_int l_0_0) (Int32.to_int u_0)
         !intP_intM_a_0_8 (at !intP_intM_a_0_8 'U__Lb2))) }); () end;
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 155 19 95#
         "expl:Assertion in line 155"
         (forall k_11 : int.
          ((((<=) (Int32.to_int l_0_0) k_11) /\
           ((<=) k_11 (Int32.to_int !m_0_0))) ->
           (minimum a_0_0 (Int.(+) (Int32.to_int !m_0_0) (1))
           (Int32.to_int u_0)
           (Int32.to_int
           (select (at !intP_intM_a_0_8 'U__Lb2) (shift a_0_0 k_11))) (at
           !intP_intM_a_0_8 'U__Lb2))))) }); () end;
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 156 19 80#
         "expl:Assertion in line 156"
         (forall k_12 : int.
          ((((<=) (Int32.to_int l_0_0) k_12) /\
           ((<=) k_12 (Int32.to_int !m_0_0))) ->
           (minimum a_0_0 (Int.(+) (Int32.to_int !m_0_0) (1))
           (Int32.to_int u_0)
           (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_12)))
           !intP_intM_a_0_8)))) }); () end;
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 158 19 76#
         "expl:Assertion in line 158"
         (forall k_13 : int.
          ((((<=) (Int32.to_int l_0_0) k_13) /\
           ((<=) k_13 (Int32.to_int !m_0_0))) ->
           (minimum a_0_0 k_13 (Int32.to_int !m_0_0)
           (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_13)))
           !intP_intM_a_0_8)))) }); () end;
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 159 19 76#
         "expl:Assertion in line 159"
         (forall k_14 : int.
          ((((<=) (Int32.to_int l_0_0) k_14) /\
           ((<=) k_14 (Int32.to_int !m_0_0))) ->
           (minimum a_0_0 k_14 (Int32.to_int u_0)
           (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_14)))
           !intP_intM_a_0_8)))) }); () end;
         begin
         (assert {
         (#"/home/kornevgen/mfsp/examples/qsort/qsort.c" 160 19 80#
         "expl:Assertion in line 160"
         (forall k_15 : int.
          ((((<=) (Int.(+) (Int32.to_int !m_0_0) (1)) k_15) /\
           ((<=) k_15 (Int32.to_int u_0))) ->
           (minimum a_0_0 k_15 (Int32.to_int u_0)
           (Int32.to_int (select !intP_intM_a_0_8 (shift a_0_0 k_15)))
           !intP_intM_a_0_8)))) }); () end end end end);
      (raise (Return_label_exc ())) end with Return_label_exc _jessie_4 ->
     'Return_label: 'Return_label: (raise Return) end); (raise Return) end
    with Return -> () end
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import core.Tag_table 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Alloc 
  
  use why3.Bool.Bool 
  
  use import core.Voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (n : int)
  (voidP_tag_table : (tag_table voidP))
  = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate strict_left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import core.Tag_table 
  
  use import Struct_voidP 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Alloc_table 
  
  use import core.Alloc 
  
  use why3.Bool.Bool 
  
  use import core.Charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (n : int)
  (voidP_tag_table : (tag_table voidP))
  = (fresh_tag_struct_voidP p n voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p n voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate strict_left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (strict_left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_charP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_charP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_charP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_charP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (0) (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (0) (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_intP_unsafe

  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !intP_alloc_table p))
      }
    writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\
      (fresh_alloc_struct_intP p (offset_max (old !intP_alloc_table) p)
      !intP_alloc_table))) }
  
  val allocate_struct_intP_requires
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { ((>=) n (0)) } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (Int.(-) n (1)) (old
        !intP_alloc_table))
       /\
       ((fresh_tag_struct_intP result (Int.(-) n (1)) (old !intP_tag_table))
       /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
end

module Struct_intP_safe

  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import Root_intP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_intP
  (p : (pointer intP)) 
   (intP_alloc_table : ref (alloc_table intP)) : unit
    requires { true } writes { intP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !intP_alloc_table (old !intP_alloc_table))) \/
      ((frame_free_struct_intP p (old !intP_alloc_table) !intP_alloc_table)
      /\
      (fresh_alloc_struct_intP p (offset_max (old !intP_alloc_table) p)
      !intP_alloc_table))) }
  
  val allocate_struct_intP
  (n : int) 
   (intP_alloc_table : ref (alloc_table intP)) 
    (intP_tag_table : ref (tag_table intP)) : (pointer intP)
     requires { true } writes { intP_alloc_table, intP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !intP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !intP_alloc_table)
        !intP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (Int.(-) n (1)) (old
        !intP_alloc_table))
       /\
       ((fresh_tag_struct_intP result (Int.(-) n (1)) (old !intP_tag_table))
       /\
       ((typeof_struct_intP result (0) n !intP_tag_table) /\
       (container_of_struct_intP result (0) n !intP_tag_table))))))) }
  
  val allocate_singleton_struct_intP
  (intP_alloc_table : ref (alloc_table intP)) 
   (intP_tag_table : ref (tag_table intP)) : (pointer intP)
    requires { true } writes { intP_alloc_table, intP_tag_table }
    ensures {
      ((strict_valid_struct_intP result (0) (0) !intP_alloc_table) /\
      ((frame_alloc_struct_intP result (1) (old !intP_alloc_table)
       !intP_alloc_table)
      /\
      ((frame_tag_struct_intP result (old !intP_tag_table) !intP_tag_table)
      /\
      ((fresh_alloc_struct_intP result (0) (old !intP_alloc_table)) /\
      ((fresh_tag_struct_intP result (0) (old !intP_tag_table)) /\
      ((typeof_singleton_struct_intP result !intP_tag_table) /\
      (container_of_singleton_struct_intP result !intP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_voidP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_voidP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_voidP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_voidP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (0) (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (0) (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end
