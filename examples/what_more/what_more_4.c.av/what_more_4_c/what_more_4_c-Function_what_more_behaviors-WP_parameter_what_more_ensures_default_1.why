(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(* this is a prelude for Alt-Ergo integer arithmetic *)
logic comp_div: int, int -> int
axiom comp_div_def: forall x, y:int. x >= 0 and y > 0 -> comp_div(x,y) = x / y
logic comp_mod: int, int -> int
axiom comp_mod_def: forall x, y:int. x >= 0 and y > 0 -> comp_mod(x,y) = x % y
logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

type t

logic to_int : t -> int

logic of_int : int -> t

predicate infix_lseq(a: t, b: t) = (to_int(a) <= to_int(b))

predicate infix_gt(a: t, b: t) = (to_int(b) <  to_int(a))

type 't1 pointer

logic null : 't1 pointer

logic sub_pointer : 't1 pointer, 't1 pointer -> int

logic shift : 't1 pointer, int -> 't1 pointer

logic same_block : 't1 pointer, 't1 pointer -> prop

type 't1 tag_id

logic int_of_tag : 't1 tag_id -> int

logic parenttag : 't1 tag_id, 't1 tag_id -> prop

logic subtag : 't1 tag_id, 't1 tag_id -> prop

logic bottom_tag : 'a tag_id

logic downcast : ('t1 pointer,'t1 tag_id) farray, 't1 pointer,
  't1 tag_id -> 't1 pointer

type intP

type 't1 alloc_table

logic offset_min : 't1 alloc_table, 't1 pointer -> int

logic offset_max : 't1 alloc_table, 't1 pointer -> int

predicate allocated(a: 't1 alloc_table, p: 't1 pointer) = (offset_min(a,
  p) <= offset_max(a, p))

type 't1 pset

logic pset_empty : 't1 pset

logic pset_singleton : 't1 pointer -> 't1 pset

logic in_pset : 't1 pointer, 't1 pset -> prop

logic intP_tag : intP tag_id

logic count : intP pointer, int, int, int, (intP pointer,t) farray -> int

axiom One :
  (forall intP_intM_a_2_at_L:(intP pointer,t) farray.
  (forall a_2:intP pointer.
  (forall i_2:int.
  (forall p_2:int. ((to_int((intP_intM_a_2_at_L[shift(a_2, i_2)])) = p_2) ->
  (count(a_2, i_2, (i_2 + 1), p_2, intP_intM_a_2_at_L) = 1))))))

axiom One1 :
  (forall intP_intM_a_2_at_L:(intP pointer,t) farray.
  (forall a_2:intP pointer.
  (forall i_2:int.
  (forall p_2:int. ((not (to_int((intP_intM_a_2_at_L[shift(a_2,
  i_2)])) = p_2)) -> (count(a_2, i_2, (i_2 + 1), p_2,
  intP_intM_a_2_at_L) = 0))))))

goal WP_parameter_what_more_ensures_default :
  (forall a_0:intP pointer. forall n_9:t. forall x:t. forall y:t.
  forall intP_a_3_alloc_table:intP alloc_table.
  forall intP_a_3_tag_table:(intP pointer,intP tag_id) farray.
  forall intP_intM_a_3:(intP pointer,t) farray.
  (((allocated(intP_a_3_alloc_table, a_0) ->
  (((intP_a_3_tag_table[a_0]) = intP_tag) and
  (forall i:int. (((offset_min(intP_a_3_alloc_table, a_0) <= i) and
  (i <  offset_max(intP_a_3_alloc_table, a_0))) ->
  ((intP_a_3_tag_table[shift(a_0, i)]) = intP_tag))))) and (infix_gt(n_9,
  of_int(0)) and
  (forall i_4:int. (((0 <= i_4) and (i_4 <  to_int(n_9))) ->
  ((offset_min(intP_a_3_alloc_table, a_0) <= i_4) and
  (offset_max(intP_a_3_alloc_table, a_0) >= i_4)))))) -> ((not (x = y)) ->
  (forall o:t. ((to_int(o) = 0) ->
  (forall c_x:t. ((c_x = o) ->
  (forall o1:t. ((to_int(o1) = 0) ->
  (forall c_y:t. ((c_y = o1) ->
  (forall o2:t. ((to_int(o2) = 0) ->
  (forall i_5:t. ((i_5 = o2) ->
  (forall i_51:t. forall c_y1:t. forall c_x1:t. (((infix_lseq(of_int(0),
  i_51) and infix_lseq(i_51, n_9)) and ((to_int(c_x1) = count(a_0, 0,
  to_int(i_51), to_int(x), intP_intM_a_3)) and (to_int(c_y1) = count(a_0, 0,
  to_int(i_51), to_int(y), intP_intM_a_3)))) ->
  (forall result:bool. (((result = true) <->
  (to_int(i_51) <  to_int(n_9))) -> ((result = true) ->
  (((intP_intM_a_3[shift(a_0, to_int(i_51))]) = x) ->
  (forall o3:t. ((to_int(o3) = 1) ->
  (forall o4:t. ((to_int(o4) = (to_int(c_x1) + to_int(o3))) ->
  (forall c_x2:t. ((c_x2 = o4) -> ((count(a_0, 0, (to_int(i_51) + 1),
  to_int(x), intP_intM_a_3) = (count(a_0, 0, to_int(i_51), to_int(x),
  intP_intM_a_3) + count(a_0, to_int(i_51), (to_int(i_51) + 1), to_int(x),
  intP_intM_a_3))) -> ((count(a_0, 0, (to_int(i_51) + 1), to_int(y),
  intP_intM_a_3) = (count(a_0, 0, to_int(i_51), to_int(y),
  intP_intM_a_3) + count(a_0, to_int(i_51), (to_int(i_51) + 1), to_int(y),
  intP_intM_a_3))) -> ((count(a_0, 0, to_int(n_9), to_int(x),
  intP_intM_a_3) = (count(a_0, 0, (to_int(i_51) + 1), to_int(x),
  intP_intM_a_3) + count(a_0, (to_int(i_51) + 1), to_int(n_9), to_int(x),
  intP_intM_a_3))) -> ((count(a_0, 0, to_int(n_9), to_int(y),
  intP_intM_a_3) = (count(a_0, 0, (to_int(i_51) + 1), to_int(y),
  intP_intM_a_3) + count(a_0, (to_int(i_51) + 1), to_int(n_9), to_int(y),
  intP_intM_a_3))) ->
  (forall o5:t. ((to_int(o5) = 1) ->
  (forall o6:t. ((to_int(o6) = (to_int(n_9) - to_int(i_51))) ->
  (forall o7:t. ((to_int(o7) = (to_int(o6) - to_int(o5))) ->
  (forall o8:t. ((to_int(o8) = (to_int(c_y1) + to_int(o7))) ->
  (forall result1:bool. (((result1 = true) <->
  (to_int(o8) <  to_int(c_x2))) -> ((not (result1 = true)) ->
  (forall o9:t. ((to_int(o9) = 1) ->
  (forall o10:t. ((to_int(o10) = (to_int(n_9) - to_int(i_51))) ->
  (forall o11:t. ((to_int(o11) = (to_int(o10) - to_int(o9))) ->
  (forall o12:t. ((to_int(o12) = (to_int(c_x2) + to_int(o11))) ->
  (forall result2:bool. (((result2 = true) <->
  (to_int(o12) <  to_int(c_y1))) -> ((not (result2 = true)) ->
  (forall o13:t. ((to_int(o13) = 1) ->
  (forall o14:t. ((to_int(o14) = (to_int(i_51) + to_int(o13))) ->
  (forall i_52:t. ((i_52 = o14) -> ((infix_lseq(of_int(0), i_52) and
  infix_lseq(i_52, n_9)) -> (to_int(c_x2) = count(a_0, 0, to_int(i_52),
  to_int(x), intP_intM_a_3))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
