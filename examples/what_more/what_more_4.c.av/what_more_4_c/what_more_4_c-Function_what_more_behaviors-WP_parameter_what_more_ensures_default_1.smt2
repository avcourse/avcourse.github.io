;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

;; CompatOrderMult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

(declare-fun abs1 (Int) Int)

;; abs_def
  (assert
  (forall ((x Int)) (ite (>= x 0) (= (abs1 x) x) (= (abs1 x) (- x)))))

;; Abs_le
  (assert
  (forall ((x Int) (y Int))
  (! (= (<= (abs1 x) y) (and (<= (- y) x) (<= x y))) :pattern ((abs1 x) y) )))

;; Abs_pos
  (assert (forall ((x Int)) (>= (abs1 x) 0)))

(declare-fun div1 (Int Int) Int)

(declare-fun mod1 (Int Int) Int)

;; Div_mod
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; Div_bound
  (assert
  (forall ((x Int) (y Int))
  (=> (and (>= x 0) (< 0 y)) (and (<= 0 (div1 x y)) (<= (div1 x y) x)))))

;; Mod_bound
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0))
  (and (< (- (abs1 y)) (mod1 x y)) (< (mod1 x y) (abs1 y))))))

;; Div_sign_pos
  (assert
  (forall ((x Int) (y Int)) (=> (and (>= x 0) (< 0 y)) (>= (div1 x y) 0))))

;; Div_sign_neg
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; Mod_sign_pos
  (assert
  (forall ((x Int) (y Int))
  (=> (and (>= x 0) (not (= y 0))) (>= (mod1 x y) 0))))

;; Mod_sign_neg
  (assert
  (forall ((x Int) (y Int))
  (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; Rounds_toward_zero
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; Div_1
  (assert (forall ((x Int)) (= (div1 x 1) x)))

;; Mod_1
  (assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; Div_inf
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; Mod_inf
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; Div_mult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (! (=> (and (< 0 x) (and (>= y 0) (>= z 0)))
     (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                            (+ (* x y) z) x)) )))

;; Mod_mult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (! (=> (and (< 0 x) (and (>= y 0) (>= z 0)))
     (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1 (+ (* x y) z) x)) )))

;; Div_mult_simplest
  (assert
  (forall ((x Int) (y Int))
  (! (=> (and (>= x 0) (< 0 y)) (= (div1 (* x y) y) x)) :pattern ((div1
                                                                  (* x y) y)) )))

(declare-fun in_bounds (Int) Bool)

;; in_bounds_def
  (assert
  (forall ((n Int))
  (= (in_bounds n) (and (<= (- 2147483648) n) (<= n 2147483647)))))

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun to_int1 (t) Int)

;; To_int_in_bounds
  (assert
  (forall ((a t)) (! (in_bounds (to_int1 a)) :pattern ((to_int1 a)) )))

(declare-fun of_int (Int) t)

;; Of_int
  (assert
  (forall ((a Int))
  (! (=> (in_bounds a) (= (to_int1 (of_int a)) a)) :pattern ((of_int a)) )))

;; Of_int_to_int
  (assert
  (forall ((a t)) (! (= (of_int (to_int1 a)) a) :pattern ((to_int1 a)) )))

(declare-fun infix_lseq (t t) Bool)

;; infix <=_def
  (assert
  (forall ((a t) (b t)) (= (infix_lseq a b) (<= (to_int1 a) (to_int1 b)))))

(declare-fun infix_ls (t t) Bool)

;; infix <_def
  (assert
  (forall ((a t) (b t)) (= (infix_ls a b) (< (to_int1 a) (to_int1 b)))))

(declare-fun infix_gteq (t t) Bool)

;; infix >=_def
  (assert
  (forall ((a t) (b t)) (= (infix_gteq a b) (>= (to_int1 a) (to_int1 b)))))

(declare-fun infix_gt (t t) Bool)

;; infix >_def
  (assert
  (forall ((a t) (b t)) (= (infix_gt a b) (< (to_int1 b) (to_int1 a)))))

(declare-fun map1 (ty ty) ty)

(declare-sort intP 0)

(declare-fun intP1 () ty)

(declare-sort tag_id 1)

(declare-fun tag_id1 (ty) ty)

(declare-sort pointer 1)

(declare-fun pointer1 (ty) ty)

(declare-fun get (ty ty uni uni) uni)

;; get_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort b (get b a x x1)))))

(declare-fun set (ty ty uni uni uni) uni)

;; set_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (map1 a b) (set b a x x1 x2)))))

(declare-fun t2tb ((Array (pointer intP) (tag_id intP))) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array (pointer intP) (tag_id intP)))) (sort
  (map1 (pointer1 intP1) (tag_id1 intP1)) (t2tb x))))

(declare-fun tb2t (uni) (Array (pointer intP) (tag_id intP)))

;; BridgeL
  (assert
  (forall ((i (Array (pointer intP) (tag_id intP))))
  (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (map1 (pointer1 intP1) (tag_id1 intP1)) j)
     (= (t2tb (tb2t j)) j)) :pattern ((t2tb (tb2t j))) )))

(declare-fun t2tb1 ((tag_id intP)) uni)

;; t2tb_sort
  (assert (forall ((x (tag_id intP))) (sort (tag_id1 intP1) (t2tb1 x))))

(declare-fun tb2t1 (uni) (tag_id intP))

;; BridgeL
  (assert
  (forall ((i (tag_id intP)))
  (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (tag_id1 intP1) j) (= (t2tb1 (tb2t1 j)) j)) :pattern (
  (t2tb1 (tb2t1 j))) )))

(declare-fun t2tb2 ((pointer intP)) uni)

;; t2tb_sort
  (assert (forall ((x (pointer intP))) (sort (pointer1 intP1) (t2tb2 x))))

(declare-fun tb2t2 (uni) (pointer intP))

;; BridgeL
  (assert
  (forall ((i (pointer intP)))
  (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (pointer1 intP1) j) (= (t2tb2 (tb2t2 j)) j)) :pattern (
  (t2tb2 (tb2t2 j))) )))

;; Select_eq
  (assert
  (forall ((m (Array (pointer intP) (tag_id intP))))
  (forall ((a1 (pointer intP)) (a2 (pointer intP)))
  (forall ((b (tag_id intP)))
  (! (=> (= a1 a2)
     (= (select (tb2t
                (set (tag_id1 intP1) (pointer1 intP1) (t2tb m) (t2tb2 a1)
                (t2tb1 b))) a2) b)) :pattern ((select (tb2t
                                                      (set (tag_id1 intP1)
                                                      (pointer1 intP1)
                                                      (t2tb m) (t2tb2 a1)
                                                      (t2tb1 b))) a2)) )))))

(declare-fun t2tb3 ((Array (pointer intP) t)) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array (pointer intP) t))) (sort (map1 (pointer1 intP1) t1)
  (t2tb3 x))))

(declare-fun tb2t3 (uni) (Array (pointer intP) t))

;; BridgeL
  (assert
  (forall ((i (Array (pointer intP) t)))
  (! (= (tb2t3 (t2tb3 i)) i) :pattern ((t2tb3 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (map1 (pointer1 intP1) t1) j) (= (t2tb3 (tb2t3 j)) j)) :pattern (
  (t2tb3 (tb2t3 j))) )))

(declare-fun t2tb4 (t) uni)

;; t2tb_sort
  (assert (forall ((x t)) (sort t1 (t2tb4 x))))

(declare-fun tb2t4 (uni) t)

;; BridgeL
  (assert (forall ((i t)) (! (= (tb2t4 (t2tb4 i)) i) :pattern ((t2tb4 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort t1 j) (= (t2tb4 (tb2t4 j)) j)) :pattern ((t2tb4 (tb2t4 j))) )))

;; Select_eq
  (assert
  (forall ((m (Array (pointer intP) t)))
  (forall ((a1 (pointer intP)) (a2 (pointer intP)))
  (forall ((b t))
  (! (=> (= a1 a2)
     (= (select (tb2t3
                (set t1 (pointer1 intP1) (t2tb3 m) (t2tb2 a1) (t2tb4 b))) a2) b)) :pattern ((select 
  (tb2t3 (set t1 (pointer1 intP1) (t2tb3 m) (t2tb2 a1) (t2tb4 b))) a2)) )))))

;; Select_eq
  (assert
  (forall ((a ty) (b ty))
  (forall ((m uni))
  (forall ((a1 uni) (a2 uni))
  (forall ((b1 uni))
  (! (=> (sort b b1) (=> (= a1 a2) (= (get b a (set b a m a1 b1) a2) b1))) :pattern (
  (get b a (set b a m a1 b1) a2)) ))))))

;; Select_neq
  (assert
  (forall ((m (Array (pointer intP) (tag_id intP))))
  (forall ((a1 (pointer intP)) (a2 (pointer intP)))
  (forall ((b (tag_id intP)))
  (! (=> (not (= a1 a2))
     (= (select (tb2t
                (set (tag_id1 intP1) (pointer1 intP1) (t2tb m) (t2tb2 a1)
                (t2tb1 b))) a2) (select m a2))) :pattern ((select (tb2t
                                                                  (set
                                                                  (tag_id1
                                                                  intP1)
                                                                  (pointer1
                                                                  intP1)
                                                                  (t2tb m)
                                                                  (t2tb2 a1)
                                                                  (t2tb1 b))) a2)) )))))

;; Select_neq
  (assert
  (forall ((m (Array (pointer intP) t)))
  (forall ((a1 (pointer intP)) (a2 (pointer intP)))
  (forall ((b t))
  (! (=> (not (= a1 a2))
     (= (select (tb2t3
                (set t1 (pointer1 intP1) (t2tb3 m) (t2tb2 a1) (t2tb4 b))) a2) (select m a2))) :pattern ((select 
  (tb2t3 (set t1 (pointer1 intP1) (t2tb3 m) (t2tb2 a1) (t2tb4 b))) a2)) )))))

;; Select_neq
  (assert
  (forall ((a ty) (b ty))
  (forall ((m uni))
  (forall ((a1 uni) (a2 uni))
  (=> (sort a a1)
  (=> (sort a a2)
  (forall ((b1 uni))
  (! (=> (not (= a1 a2)) (= (get b a (set b a m a1 b1) a2) (get b a m a2))) :pattern (
  (get b a (set b a m a1 b1) a2)) ))))))))

(declare-fun null (ty) uni)

;; null_sort
  (assert (forall ((t2 ty)) (sort (pointer1 t2) (null t2))))

(declare-fun sub_pointer (ty uni uni) Int)

(declare-fun shift (ty uni Int) uni)

;; shift_sort
  (assert
  (forall ((t2 ty))
  (forall ((x uni) (x1 Int)) (sort (pointer1 t2) (shift t2 x x1)))))

(declare-fun shift1 ((pointer intP) Int) (pointer intP))

(declare-fun same_block (ty uni uni) Bool)

;; Sub_pointer_def
  (assert
  (forall ((a (pointer intP)))
  (forall ((i Int) (j Int))
  (! (= (sub_pointer intP1 (t2tb2 (shift1 a i)) (t2tb2 (shift1 a j))) (- i j)) :pattern (
  (shift1 a i) (shift1 a j)) ))))

;; Sub_pointer_def
  (assert
  (forall ((t2 ty))
  (forall ((a uni))
  (forall ((i Int) (j Int))
  (! (= (sub_pointer t2 (shift t2 a i) (shift t2 a j)) (- i j)) :pattern (
  (shift t2 a i) (shift t2 a j)) )))))

;; Shift_def1
  (assert
  (forall ((a (pointer intP)))
  (forall ((i Int))
  (! (forall ((j Int))
     (! (= (shift1 (shift1 a i) j) (shift1 a (+ i j))) :pattern ((shift1
                                                                 (shift1 a i)
                                                                 j)) )) :pattern (
  (shift1 a i)) ))))

;; Shift_def1
  (assert
  (forall ((t2 ty))
  (forall ((a uni))
  (forall ((i Int))
  (! (forall ((j Int))
     (! (= (shift t2 (shift t2 a i) j) (shift t2 a (+ i j))) :pattern (
     (shift t2 (shift t2 a i) j)) )) :pattern ((shift t2 a i)) )))))

;; Shift_def2
  (assert
  (forall ((a (pointer intP)))
  (! (= (shift1 a 0) a) :pattern ((shift1 a 0)) )))

;; Shift_def2
  (assert
  (forall ((t2 ty))
  (forall ((a uni))
  (! (=> (sort (pointer1 t2) a) (= (shift t2 a 0) a)) :pattern ((shift t2 a
                                                                0)) ))))

;; Same_block_def
  (assert
  (forall ((a (pointer intP)) (b (pointer intP)))
  (! (= (same_block intP1 (t2tb2 a) (t2tb2 b))
     (exists ((i Int)) (! (= a (shift1 b i)) :pattern ((shift1 b i)) ))) :pattern ((same_block
  intP1 (t2tb2 a) (t2tb2 b))) )))

;; Same_block_def
  (assert
  (forall ((t2 ty))
  (forall ((a uni) (b uni))
  (! (=> (sort (pointer1 t2) a)
     (= (same_block t2 a b)
     (exists ((i Int)) (! (= a (shift t2 b i)) :pattern ((shift t2 b i)) )))) :pattern ((same_block
  t2 a b)) ))))

;; Sub_pointer_shift
  (assert
  (forall ((p (pointer intP)) (q (pointer intP)))
  (! (=> (same_block intP1 (t2tb2 p) (t2tb2 q))
     (= p (shift1 q (sub_pointer intP1 (t2tb2 p) (t2tb2 q))))) :pattern ((same_block
  intP1 (t2tb2 p)
  (t2tb2 q))) :pattern ((sub_pointer intP1 (t2tb2 p) (t2tb2 q))) )))

;; Sub_pointer_shift
  (assert
  (forall ((t2 ty))
  (forall ((p uni) (q uni))
  (! (=> (sort (pointer1 t2) p)
     (=> (same_block t2 p q) (= p (shift t2 q (sub_pointer t2 p q))))) :pattern ((same_block
  t2 p q)) :pattern ((sub_pointer t2 p q)) ))))

;; Sub_pointer_self
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (! (= (sub_pointer t2 p p) 0) :pattern ((sub_pointer t2 p p)) ))))

;; Sub_pointer_zero
  (assert
  (forall ((t2 ty))
  (forall ((p uni) (q uni))
  (! (=> (sort (pointer1 t2) p)
     (=> (sort (pointer1 t2) q)
     (=> (same_block t2 p q) (=> (= (sub_pointer t2 p q) 0) (= p q))))) :pattern (
  (sub_pointer t2 p q)) ))))

;; Sub_pointer_shift_left
  (assert
  (forall ((p (pointer intP)) (q (pointer intP)) (i Int))
  (! (=> (same_block intP1 (t2tb2 p) (t2tb2 q))
     (= (sub_pointer intP1 (t2tb2 (shift1 p i)) (t2tb2 q)) (+ (sub_pointer
                                                              intP1 (t2tb2 p)
                                                              (t2tb2 q)) i))) :pattern (
  (sub_pointer intP1 (t2tb2 (shift1 p i)) (t2tb2 q))) )))

;; Sub_pointer_shift_left
  (assert
  (forall ((t2 ty))
  (forall ((p uni) (q uni) (i Int))
  (! (=> (same_block t2 p q)
     (= (sub_pointer t2 (shift t2 p i) q) (+ (sub_pointer t2 p q) i))) :pattern (
  (sub_pointer t2 (shift t2 p i) q)) ))))

;; Sub_pointer_shift_right
  (assert
  (forall ((p (pointer intP)) (q (pointer intP)) (i Int))
  (! (=> (same_block intP1 (t2tb2 p) (t2tb2 q))
     (= (sub_pointer intP1 (t2tb2 p) (t2tb2 (shift1 q i))) (- (sub_pointer
                                                              intP1 (t2tb2 p)
                                                              (t2tb2 q)) i))) :pattern (
  (sub_pointer intP1 (t2tb2 p) (t2tb2 (shift1 q i)))) )))

;; Sub_pointer_shift_right
  (assert
  (forall ((t2 ty))
  (forall ((p uni) (q uni) (i Int))
  (! (=> (same_block t2 p q)
     (= (sub_pointer t2 p (shift t2 q i)) (- (sub_pointer t2 p q) i))) :pattern (
  (sub_pointer t2 p (shift t2 q i))) ))))

;; Sub_pointer_neg
  (assert
  (forall ((t2 ty))
  (forall ((p uni) (q uni))
  (! (=> (same_block t2 p q)
     (= (sub_pointer t2 p q) (- (sub_pointer t2 q p)))) :pattern ((sub_pointer
                                                                  t2 p q)) :pattern (
  (sub_pointer t2 q p)) ))))

;; Shift_shift
  (assert
  (forall ((p (pointer intP)))
  (forall ((i Int) (j Int))
  (! (= (shift1 (shift1 p i) j) (shift1 p (+ i j))) :pattern ((shift1
                                                              (shift1 p i) j)) ))))

;; Shift_shift
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (forall ((i Int) (j Int))
  (! (= (shift t2 (shift t2 p i) j) (shift t2 p (+ i j))) :pattern ((shift t2
                                                                    (shift t2
                                                                    p i) j)) )))))

;; Neq_shift
  (assert
  (forall ((p (pointer intP)))
  (forall ((i Int))
  (forall ((j Int))
  (! (=> (not (= i j)) (not (= (shift1 p i) (shift1 p j)))) :pattern (
  (shift1 p i) (shift1 p j)) )))))

;; Neq_shift
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (forall ((i Int))
  (forall ((j Int))
  (! (=> (not (= i j)) (not (= (shift t2 p i) (shift t2 p j)))) :pattern (
  (shift t2 p i) (shift t2 p j)) ))))))

;; Same_block_refl
  (assert (forall ((t2 ty)) (forall ((p uni)) (same_block t2 p p))))

;; Same_block_shift
  (assert
  (forall ((p (pointer intP)))
  (forall ((i Int)) (! (same_block intP1 (t2tb2 p)
  (t2tb2 (shift1 p i))) :pattern ((shift1 p i)) ))))

;; Same_block_shift
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (forall ((i Int)) (! (same_block t2 p
  (shift t2 p i)) :pattern ((shift t2 p i)) )))))

;; Same_block_symm
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (forall ((q uni))
  (! (= (same_block t2 p q) (same_block t2 q p)) :pattern ((same_block t2 p
  q)) :pattern ((same_block t2 q p)) )))))

;; Same_block_trans
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (forall ((q uni))
  (! (forall ((r uni))
     (! (=> (and (same_block t2 p q) (same_block t2 q r)) (same_block t2 p
        r)) :pattern ((same_block
     t2 p r)) )) :pattern ((same_block
  t2 p q)) :pattern ((same_block t2 q p)) )))))

;; Same_block_shift_right
  (assert
  (forall ((p (pointer intP)))
  (forall ((q (pointer intP)))
  (! (forall ((i Int))
     (! (=> (same_block intP1 (t2tb2 p) (t2tb2 q)) (same_block intP1
        (t2tb2 p) (t2tb2 (shift1 q i)))) :pattern ((same_block
     intP1 (t2tb2 p) (t2tb2 (shift1 q i)))) )) :pattern ((same_block
  intP1 (t2tb2 p) (t2tb2 q))) :pattern ((same_block intP1 (t2tb2 q)
  (t2tb2 p))) ))))

;; Same_block_shift_right
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (forall ((q uni))
  (! (forall ((i Int))
     (! (=> (same_block t2 p q) (same_block t2 p (shift t2 q i))) :pattern ((same_block
     t2 p (shift t2 q i))) )) :pattern ((same_block
  t2 p q)) :pattern ((same_block t2 q p)) )))))

;; Same_block_shift_left
  (assert
  (forall ((p (pointer intP)))
  (forall ((q (pointer intP)))
  (! (forall ((i Int))
     (! (=> (same_block intP1 (t2tb2 q) (t2tb2 p)) (same_block intP1
        (t2tb2 (shift1 q i)) (t2tb2 p))) :pattern ((same_block
     intP1 (t2tb2 (shift1 q i)) (t2tb2 p))) )) :pattern ((same_block
  intP1 (t2tb2 p) (t2tb2 q))) :pattern ((same_block intP1 (t2tb2 q)
  (t2tb2 p))) ))))

;; Same_block_shift_left
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (forall ((q uni))
  (! (forall ((i Int))
     (! (=> (same_block t2 q p) (same_block t2 (shift t2 q i) p)) :pattern ((same_block
     t2 (shift t2 q i) p)) )) :pattern ((same_block
  t2 p q)) :pattern ((same_block t2 q p)) )))))

(declare-fun int_of_tag (ty uni) Int)

(declare-fun int_of_tag1 ((tag_id intP)) Int)

(declare-fun parenttag (ty uni uni) Bool)

(declare-fun parenttag1 ((tag_id intP) (tag_id intP)) Bool)

(declare-fun subtag (ty uni uni) Bool)

;; Subtag_refl
  (assert
  (forall ((t2 ty))
  (forall ((t3 uni)) (! (subtag t2 t3 t3) :pattern ((subtag t2 t3 t3)) ))))

;; Subtag_parent
  (assert
  (forall ((t11 (tag_id intP)))
  (forall ((t2 (tag_id intP)))
  (forall ((t3 (tag_id intP)))
  (! (=> (subtag intP1 (t2tb1 t11) (t2tb1 t2))
     (=> (parenttag1 t2 t3) (subtag intP1 (t2tb1 t11) (t2tb1 t3)))) :pattern ((subtag
  intP1 (t2tb1 t11) (t2tb1 t2))) :pattern ((parenttag1 t2
  t3)) :pattern ((subtag intP1 (t2tb1 t11) (t2tb1 t3))) )))))

;; Subtag_parent
  (assert
  (forall ((t2 ty))
  (forall ((t11 uni))
  (forall ((t21 uni))
  (forall ((t3 uni))
  (! (=> (subtag t2 t11 t21) (=> (parenttag t2 t21 t3) (subtag t2 t11 t3))) :pattern ((subtag
  t2 t11 t21)) :pattern ((parenttag t2 t21 t3)) :pattern ((subtag t2 t11
  t3)) ))))))

;; Subtag_antisymmetric
  (assert
  (forall ((t2 ty))
  (forall ((t11 uni) (t21 uni))
  (=> (sort (tag_id1 t2) t11)
  (=> (sort (tag_id1 t2) t21)
  (=> (subtag t2 t11 t21) (=> (subtag t2 t21 t11) (= t11 t21))))))))

(declare-fun bottom_tag (ty) uni)

;; bottom_tag_sort
  (assert (forall ((a ty)) (sort (tag_id1 a) (bottom_tag a))))

(declare-fun bottom_tag1 () (tag_id intP))

;; Bottom_tag
  (assert
  (forall ((t2 (tag_id intP))) (! (subtag intP1 (t2tb1 t2)
  (t2tb1 bottom_tag1)) :pattern ((subtag intP1 (t2tb1 t2)
  (t2tb1 bottom_tag1))) )))

;; Bottom_tag
  (assert
  (forall ((t2 ty))
  (forall ((t3 uni)) (! (subtag t2 t3 (bottom_tag t2)) :pattern ((subtag t2
  t3 (bottom_tag t2))) ))))

;; Bottom_int
  (assert (= (int_of_tag1 bottom_tag1) 0))

;; Bottom_int
  (assert (forall ((a ty)) (= (int_of_tag a (bottom_tag a)) 0)))

;; Root_subtag
  (assert
  (forall ((a (tag_id intP)))
  (forall ((b (tag_id intP)))
  (forall ((c (tag_id intP)))
  (! (=> (parenttag1 a bottom_tag1)
     (=> (parenttag1 b bottom_tag1)
     (=> (not (= a b))
     (=> (subtag intP1 (t2tb1 c) (t2tb1 a))
     (not (subtag intP1 (t2tb1 c) (t2tb1 b))))))) :pattern ((subtag
  intP1 (t2tb1 c) (t2tb1 a)) (parenttag1 a bottom_tag1) (subtag intP1
  (t2tb1 c) (t2tb1 b)) (parenttag1 b bottom_tag1)) )))))

;; Root_subtag
  (assert
  (forall ((t2 ty))
  (forall ((a uni))
  (=> (sort (tag_id1 t2) a)
  (forall ((b uni))
  (=> (sort (tag_id1 t2) b)
  (forall ((c uni))
  (! (=> (parenttag t2 a (bottom_tag t2))
     (=> (parenttag t2 b (bottom_tag t2))
     (=> (not (= a b)) (=> (subtag t2 c a) (not (subtag t2 c b)))))) :pattern ((subtag
  t2 c a) (parenttag t2 a (bottom_tag t2)) (subtag t2 c b) (parenttag t2 b
  (bottom_tag t2))) ))))))))

(declare-fun instanceof (ty uni uni uni) Bool)

(declare-fun instanceof1 ((Array (pointer intP) (tag_id intP)) (pointer intP)
  (tag_id intP)) Bool)

;; instanceof_def
  (assert
  (forall ((t2 (Array (pointer intP) (tag_id intP))) (p (pointer intP))
  (s (tag_id intP)))
  (= (instanceof1 t2 p s) (subtag intP1 (t2tb1 (select t2 p)) (t2tb1 s)))))

;; instanceof_def
  (assert
  (forall ((t2 ty))
  (forall ((t3 uni) (p uni) (s uni))
  (= (instanceof t2 t3 p s) (subtag t2 (get (tag_id1 t2) (pointer1 t2) t3 p)
  s)))))

(declare-fun downcast (ty uni uni uni) uni)

;; downcast_sort
  (assert
  (forall ((t2 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (pointer1 t2)
  (downcast t2 x x1 x2)))))

;; Downcast_instanceof
  (assert
  (forall ((t2 (Array (pointer intP) (tag_id intP))))
  (forall ((p (pointer intP)))
  (forall ((s (tag_id intP)))
  (! (=> (instanceof1 t2 p s)
     (= (tb2t2 (downcast intP1 (t2tb t2) (t2tb2 p) (t2tb1 s))) p)) :pattern ((instanceof1
  t2 p
  s)) :pattern ((tb2t2 (downcast intP1 (t2tb t2) (t2tb2 p) (t2tb1 s)))) )))))

;; Downcast_instanceof
  (assert
  (forall ((t2 ty))
  (forall ((t3 uni))
  (forall ((p uni))
  (=> (sort (pointer1 t2) p)
  (forall ((s uni))
  (! (=> (instanceof t2 t3 p s) (= (downcast t2 t3 p s) p)) :pattern ((instanceof
  t2 t3 p s)) :pattern ((downcast t2 t3 p s)) )))))))

;; Downcast_null
  (assert
  (forall ((t2 ty))
  (forall ((t3 uni))
  (forall ((s uni))
  (! (= (downcast t2 t3 (null t2) s) (null t2)) :pattern ((downcast t2 t3
                                                          (null t2) s)) )))))

(declare-fun ref (ty) ty)

(declare-fun mk_ref (ty uni) uni)

;; mk ref_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (mk_ref a x)))))

(declare-fun contents (ty uni) uni)

;; contents_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; contents_def
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort a u) (= (contents a (mk_ref a u)) u)))))

;; ref_inversion
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort (ref a) u) (= u (mk_ref a (contents a u)))))))

(declare-sort alloc_table 1)

(declare-fun alloc_table1 (ty) ty)

(declare-fun offset_min (ty uni uni) Int)

(declare-fun offset_min1 ((alloc_table intP) (pointer intP)) Int)

(declare-fun offset_max (ty uni uni) Int)

(declare-fun offset_max1 ((alloc_table intP) (pointer intP)) Int)

;; Null_pointer
  (assert
  (forall ((a (alloc_table intP)))
  (! (and (= (offset_max1 a (tb2t2 (null intP1))) (- 2))
     (and (< (- 2) (offset_min1 a (tb2t2 (null intP1))))
     (= (offset_min1 a (tb2t2 (null intP1))) 0))) :pattern ((offset_max1 a
                                                            (tb2t2
                                                            (null intP1)))) :pattern (
  (offset_min1 a (tb2t2 (null intP1)))) )))

;; Null_pointer
  (assert
  (forall ((t2 ty))
  (forall ((a uni))
  (! (and (= (offset_max t2 a (null t2)) (- 2))
     (and (< (- 2) (offset_min t2 a (null t2)))
     (= (offset_min t2 a (null t2)) 0))) :pattern ((offset_max t2 a
                                                   (null t2))) :pattern (
  (offset_min t2 a (null t2))) ))))

;; Offset_max_shift
  (assert
  (forall ((a (alloc_table intP)))
  (forall ((p (pointer intP)))
  (forall ((i Int))
  (! (= (offset_max1 a (shift1 p i)) (- (offset_max1 a p) i)) :pattern (
  (offset_max1 a (shift1 p i))) :pattern ((offset_max1 a p)) )))))

;; Offset_max_shift
  (assert
  (forall ((t2 ty))
  (forall ((a uni))
  (forall ((p uni))
  (forall ((i Int))
  (! (= (offset_max t2 a (shift t2 p i)) (- (offset_max t2 a p) i)) :pattern (
  (offset_max t2 a (shift t2 p i))) :pattern ((offset_max t2 a p)) ))))))

;; Offset_min_shift
  (assert
  (forall ((a (alloc_table intP)))
  (forall ((p (pointer intP)))
  (forall ((i Int))
  (! (= (offset_min1 a (shift1 p i)) (- (offset_min1 a p) i)) :pattern (
  (offset_min1 a (shift1 p i))) :pattern ((offset_min1 a p)) )))))

;; Offset_min_shift
  (assert
  (forall ((t2 ty))
  (forall ((a uni))
  (forall ((p uni))
  (forall ((i Int))
  (! (= (offset_min t2 a (shift t2 p i)) (- (offset_min t2 a p) i)) :pattern (
  (offset_min t2 a (shift t2 p i))) :pattern ((offset_min t2 a p)) ))))))

(declare-fun valid (ty uni uni) Bool)

(declare-fun t2tb5 ((alloc_table intP)) uni)

;; t2tb_sort
  (assert
  (forall ((x (alloc_table intP))) (sort (alloc_table1 intP1) (t2tb5 x))))

(declare-fun tb2t5 (uni) (alloc_table intP))

;; BridgeL
  (assert
  (forall ((i (alloc_table intP)))
  (! (= (tb2t5 (t2tb5 i)) i) :pattern ((t2tb5 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (alloc_table1 intP1) j) (= (t2tb5 (tb2t5 j)) j)) :pattern (
  (t2tb5 (tb2t5 j))) )))

;; valid_def
  (assert
  (forall ((a (alloc_table intP)) (p (pointer intP)))
  (= (valid intP1 (t2tb5 a) (t2tb2 p))
  (and (<= (offset_min1 a p) 0) (<= 0 (offset_max1 a p))))))

;; valid_def
  (assert
  (forall ((t2 ty))
  (forall ((a uni) (p uni))
  (= (valid t2 a p)
  (and (<= (offset_min t2 a p) 0) (<= 0 (offset_max t2 a p)))))))

(declare-fun allocable (ty uni uni) Bool)

;; allocable_def
  (assert
  (forall ((a (alloc_table intP)) (p (pointer intP)))
  (= (allocable intP1 (t2tb5 a) (t2tb2 p))
  (and (= (offset_max1 a p) (- 3))
  (and (< (- 3) (offset_min1 a p)) (= (offset_min1 a p) 0))))))

;; allocable_def
  (assert
  (forall ((t2 ty))
  (forall ((a uni) (p uni))
  (= (allocable t2 a p)
  (and (= (offset_max t2 a p) (- 3))
  (and (< (- 3) (offset_min t2 a p)) (= (offset_min t2 a p) 0)))))))

(declare-fun freeable (ty uni uni) Bool)

;; freeable_def
  (assert
  (forall ((a (alloc_table intP)) (p (pointer intP)))
  (= (freeable intP1 (t2tb5 a) (t2tb2 p))
  (and (= (offset_min1 a p) 0) (<= 0 (+ (offset_max1 a p) 1))))))

;; freeable_def
  (assert
  (forall ((t2 ty))
  (forall ((a uni) (p uni))
  (= (freeable t2 a p)
  (and (= (offset_min t2 a p) 0) (<= 0 (+ (offset_max t2 a p) 1)))))))

(declare-fun allocated (ty uni uni) Bool)

(declare-fun allocated1 ((alloc_table intP) (pointer intP)) Bool)

;; allocated_def
  (assert
  (forall ((a (alloc_table intP)) (p (pointer intP)))
  (= (allocated1 a p) (<= (offset_min1 a p) (offset_max1 a p)))))

;; allocated_def
  (assert
  (forall ((t2 ty))
  (forall ((a uni) (p uni))
  (= (allocated t2 a p) (<= (offset_min t2 a p) (offset_max t2 a p))))))

(declare-fun tag_fresh (ty uni uni) Bool)

;; tag_fresh_def
  (assert
  (forall ((t2 (Array (pointer intP) (tag_id intP))) (p (pointer intP)))
  (= (tag_fresh intP1 (t2tb t2) (t2tb2 p)) (= (select t2 p) bottom_tag1))))

;; tag_fresh_def
  (assert
  (forall ((t2 ty))
  (forall ((t3 uni) (p uni))
  (= (tag_fresh t2 t3 p)
  (= (get (tag_id1 t2) (pointer1 t2) t3 p) (bottom_tag t2))))))

;; Alloc_fresh_not_same_block
  (assert
  (forall ((t2 ty))
  (forall ((p1 uni))
  (forall ((p2 uni))
  (! (forall ((a uni))
     (! (=> (and (allocable t2 a p1) (freeable t2 a p2))
        (not (same_block t2 p1 p2))) :pattern ((allocable
     t2 a p1) (freeable t2 a p2)) )) :pattern ((same_block
  t2 p1 p2)) )))))

(declare-sort pset 1)

(declare-fun pset1 (ty) ty)

(declare-fun pset_empty (ty) uni)

;; pset_empty_sort
  (assert (forall ((t2 ty)) (sort (pset1 t2) (pset_empty t2))))

(declare-fun pset_singleton (ty uni) uni)

;; pset_singleton_sort
  (assert
  (forall ((t2 ty))
  (forall ((x uni)) (sort (pset1 t2) (pset_singleton t2 x)))))

(declare-fun in_pset (ty uni uni) Bool)

;; In_pset_empty
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (! (not (in_pset t2 p (pset_empty t2))) :pattern ((in_pset t2 p
  (pset_empty t2))) ))))

;; In_pset_singleton
  (assert
  (forall ((t2 ty))
  (forall ((p uni))
  (=> (sort (pointer1 t2) p)
  (forall ((q uni))
  (! (=> (sort (pointer1 t2) q)
     (= (in_pset t2 p (pset_singleton t2 q)) (= p q))) :pattern ((in_pset
  t2 p (pset_singleton t2 q))) ))))))

(declare-fun alloc_extends (ty uni uni) Bool)

(declare-fun alloc_extends1 ((alloc_table intP) (alloc_table intP)) Bool)

;; alloc_extends_def
  (assert
  (forall ((a1 (alloc_table intP)) (a2 (alloc_table intP)))
  (= (alloc_extends1 a1 a2)
  (forall ((p (pointer intP)))
  (! (=> (valid intP1 (t2tb5 a1) (t2tb2 p))
     (and (= (offset_min1 a1 p) (offset_min1 a2 p))
     (= (offset_max1 a1 p) (offset_max1 a2 p)))) :pattern ((valid
  intP1 (t2tb5 a1) (t2tb2 p))) :pattern ((valid intP1 (t2tb5 a2)
  (t2tb2 p))) :pattern ((offset_min1 a1 p)) :pattern ((offset_min1 a2 p)) :pattern (
  (offset_max1 a1 p)) :pattern ((offset_max1 a2 p)) )))))

;; alloc_extends_def
  (assert
  (forall ((t2 ty))
  (forall ((a1 uni) (a2 uni))
  (and
  (=> (alloc_extends t2 a1 a2)
  (forall ((p uni))
  (! (=> (valid t2 a1 p)
     (and (= (offset_min t2 a1 p) (offset_min t2 a2 p))
     (= (offset_max t2 a1 p) (offset_max t2 a2 p)))) :pattern ((valid
  t2 a1 p)) :pattern ((valid t2 a2
  p)) :pattern ((offset_min t2 a1 p)) :pattern ((offset_min t2 a2 p)) :pattern (
  (offset_max t2 a1 p)) :pattern ((offset_max t2 a2 p)) )))
  (=>
  (forall ((p uni))
  (! (=> (sort (pointer1 t2) p)
     (=> (valid t2 a1 p)
     (and (= (offset_min t2 a1 p) (offset_min t2 a2 p))
     (= (offset_max t2 a1 p) (offset_max t2 a2 p))))) :pattern ((valid
  t2 a1 p)) :pattern ((valid t2 a2
  p)) :pattern ((offset_min t2 a1 p)) :pattern ((offset_min t2 a2 p)) :pattern (
  (offset_max t2 a1 p)) :pattern ((offset_max t2 a2 p)) )) (alloc_extends t2
  a1 a2))))))

(declare-fun free_extends (ty uni uni) Bool)

(declare-fun free_extends1 ((alloc_table intP) (alloc_table intP)) Bool)

;; free_extends_def
  (assert
  (forall ((a1 (alloc_table intP)) (a2 (alloc_table intP)))
  (= (free_extends1 a1 a2)
  (forall ((p (pointer intP)))
  (! (=> (not (allocated1 a1 p))
     (and (= (offset_min1 a1 p) (offset_min1 a2 p))
     (= (offset_max1 a1 p) (offset_max1 a2 p)))) :pattern ((valid
  intP1 (t2tb5 a1) (t2tb2 p))) :pattern ((valid intP1 (t2tb5 a2)
  (t2tb2 p))) :pattern ((offset_min1 a1 p)) :pattern ((offset_min1 a2 p)) :pattern (
  (offset_max1 a1 p)) :pattern ((offset_max1 a2 p)) )))))

;; free_extends_def
  (assert
  (forall ((t2 ty))
  (forall ((a1 uni) (a2 uni))
  (and
  (=> (free_extends t2 a1 a2)
  (forall ((p uni))
  (! (=> (not (allocated t2 a1 p))
     (and (= (offset_min t2 a1 p) (offset_min t2 a2 p))
     (= (offset_max t2 a1 p) (offset_max t2 a2 p)))) :pattern ((valid
  t2 a1 p)) :pattern ((valid t2 a2
  p)) :pattern ((offset_min t2 a1 p)) :pattern ((offset_min t2 a2 p)) :pattern (
  (offset_max t2 a1 p)) :pattern ((offset_max t2 a2 p)) )))
  (=>
  (forall ((p uni))
  (! (=> (sort (pointer1 t2) p)
     (=> (not (allocated t2 a1 p))
     (and (= (offset_min t2 a1 p) (offset_min t2 a2 p))
     (= (offset_max t2 a1 p) (offset_max t2 a2 p))))) :pattern ((valid
  t2 a1 p)) :pattern ((valid t2 a2
  p)) :pattern ((offset_min t2 a1 p)) :pattern ((offset_min t2 a2 p)) :pattern (
  (offset_max t2 a1 p)) :pattern ((offset_max t2 a2 p)) )) (free_extends t2
  a1 a2))))))

(declare-fun alloc_block (ty uni uni uni Int) Bool)

(declare-fun alloc_block1 ((alloc_table intP) (alloc_table intP)
  (pointer intP) Int) Bool)

;; alloc_block_def
  (assert
  (forall ((a1 (alloc_table intP)) (a2 (alloc_table intP)) (p (pointer intP))
  (n Int))
  (= (alloc_block1 a1 a2 p n)
  (forall ((q (pointer intP)))
  (! (and
     (=> (not (same_block intP1 (t2tb2 q) (t2tb2 p)))
     (and (= (offset_min1 a2 q) (offset_min1 a1 q))
     (= (offset_max1 a2 q) (offset_max1 a1 q))))
     (=> (same_block intP1 (t2tb2 q) (t2tb2 p))
     (and
     (= (offset_min1 a2 q) (- 0 (sub_pointer intP1 (t2tb2 q) (t2tb2 p))))
     (= (offset_max1 a2 q) (- (- n 1) (sub_pointer intP1 (t2tb2 q) (t2tb2 p))))))) :pattern (
  (offset_min1 a2 q)) :pattern ((offset_min1 a1 q)) :pattern ((offset_max1 a1
                                                              q)) :pattern (
  (offset_max1 a1 q)) )))))

;; alloc_block_def
  (assert
  (forall ((t2 ty))
  (forall ((a1 uni) (a2 uni) (p uni) (n Int))
  (and
  (=> (alloc_block t2 a1 a2 p n)
  (forall ((q uni))
  (! (and
     (=> (not (same_block t2 q p))
     (and (= (offset_min t2 a2 q) (offset_min t2 a1 q))
     (= (offset_max t2 a2 q) (offset_max t2 a1 q))))
     (=> (same_block t2 q p)
     (and (= (offset_min t2 a2 q) (- 0 (sub_pointer t2 q p)))
     (= (offset_max t2 a2 q) (- (- n 1) (sub_pointer t2 q p)))))) :pattern (
  (offset_min t2 a2 q)) :pattern ((offset_min t2 a1 q)) :pattern ((offset_max
                                                                  t2 a1 q)) :pattern (
  (offset_max t2 a1 q)) )))
  (=>
  (forall ((q uni))
  (! (=> (sort (pointer1 t2) q)
     (and
     (=> (not (same_block t2 q p))
     (and (= (offset_min t2 a2 q) (offset_min t2 a1 q))
     (= (offset_max t2 a2 q) (offset_max t2 a1 q))))
     (=> (same_block t2 q p)
     (and (= (offset_min t2 a2 q) (- 0 (sub_pointer t2 q p)))
     (= (offset_max t2 a2 q) (- (- n 1) (sub_pointer t2 q p))))))) :pattern (
  (offset_min t2 a2 q)) :pattern ((offset_min t2 a1 q)) :pattern ((offset_max
                                                                  t2 a1 q)) :pattern (
  (offset_max t2 a1 q)) )) (alloc_block t2 a1 a2 p n))))))

(declare-fun free_block (ty uni uni uni) Bool)

(declare-fun free_block1 ((alloc_table intP) (alloc_table intP)
  (pointer intP)) Bool)

;; free_block_def
  (assert
  (forall ((a1 (alloc_table intP)) (a2 (alloc_table intP))
  (p (pointer intP)))
  (= (free_block1 a1 a2 p)
  (forall ((q (pointer intP)))
  (! (and
     (=> (not (same_block intP1 (t2tb2 q) (t2tb2 p)))
     (and (= (offset_min1 a2 q) (offset_min1 a1 q))
     (= (offset_max1 a2 q) (offset_max1 a1 q))))
     (=> (same_block intP1 (t2tb2 q) (t2tb2 p))
     (and
     (= (offset_min1 a2 q) (- 0 (sub_pointer intP1 (t2tb2 q) (t2tb2 p))))
     (= (offset_max1 a2 q) (- (- 3) (sub_pointer intP1 (t2tb2 q) (t2tb2 p))))))) :pattern (
  (offset_min1 a2 q)) :pattern ((offset_min1 a1 q)) :pattern ((offset_max1 a2
                                                              q)) :pattern (
  (offset_max1 a1 q)) )))))

;; free_block_def
  (assert
  (forall ((t2 ty))
  (forall ((a1 uni) (a2 uni) (p uni))
  (and
  (=> (free_block t2 a1 a2 p)
  (forall ((q uni))
  (! (and
     (=> (not (same_block t2 q p))
     (and (= (offset_min t2 a2 q) (offset_min t2 a1 q))
     (= (offset_max t2 a2 q) (offset_max t2 a1 q))))
     (=> (same_block t2 q p)
     (and (= (offset_min t2 a2 q) (- 0 (sub_pointer t2 q p)))
     (= (offset_max t2 a2 q) (- (- 3) (sub_pointer t2 q p)))))) :pattern (
  (offset_min t2 a2 q)) :pattern ((offset_min t2 a1 q)) :pattern ((offset_max
                                                                  t2 a2 q)) :pattern (
  (offset_max t2 a1 q)) )))
  (=>
  (forall ((q uni))
  (! (=> (sort (pointer1 t2) q)
     (and
     (=> (not (same_block t2 q p))
     (and (= (offset_min t2 a2 q) (offset_min t2 a1 q))
     (= (offset_max t2 a2 q) (offset_max t2 a1 q))))
     (=> (same_block t2 q p)
     (and (= (offset_min t2 a2 q) (- 0 (sub_pointer t2 q p)))
     (= (offset_max t2 a2 q) (- (- 3) (sub_pointer t2 q p))))))) :pattern (
  (offset_min t2 a2 q)) :pattern ((offset_min t2 a1 q)) :pattern ((offset_max
                                                                  t2 a2 q)) :pattern (
  (offset_max t2 a1 q)) )) (free_block t2 a1 a2 p))))))

(declare-fun switch_blocks (ty uni uni uni uni Int) Bool)

;; switch_blocks_def
  (assert
  (forall ((a1 (alloc_table intP)) (a2 (alloc_table intP)) (p (pointer intP))
  (q (pointer intP)) (n Int))
  (= (switch_blocks intP1 (t2tb5 a1) (t2tb5 a2) (t2tb2 p) (t2tb2 q) n)
  (forall ((r (pointer intP)))
  (! (and
     (=>
     (and (not (same_block intP1 (t2tb2 r) (t2tb2 p)))
     (not (same_block intP1 (t2tb2 r) (t2tb2 q))))
     (and (= (offset_min1 a2 r) (offset_min1 a1 r))
     (= (offset_max1 a2 r) (offset_max1 a1 r))))
     (and
     (=> (same_block intP1 (t2tb2 r) (t2tb2 p))
     (and
     (= (offset_min1 a2 r) (- 0 (sub_pointer intP1 (t2tb2 r) (t2tb2 p))))
     (= (offset_max1 a2 r) (- (- 3) (sub_pointer intP1 (t2tb2 r) (t2tb2 p))))))
     (=> (same_block intP1 (t2tb2 r) (t2tb2 q))
     (and
     (= (offset_min1 a2 r) (- 0 (sub_pointer intP1 (t2tb2 r) (t2tb2 q))))
     (= (offset_max1 a2 r) (- (- n 1) (sub_pointer intP1 (t2tb2 r) (t2tb2 q)))))))) :pattern (
  (offset_min1 a2 r)) :pattern ((offset_min1 a1 r)) :pattern ((offset_max1 a2
                                                              r)) :pattern (
  (offset_max1 a1 r)) )))))

;; switch_blocks_def
  (assert
  (forall ((t2 ty))
  (forall ((a1 uni) (a2 uni) (p uni) (q uni) (n Int))
  (and
  (=> (switch_blocks t2 a1 a2 p q n)
  (forall ((r uni))
  (! (and
     (=> (and (not (same_block t2 r p)) (not (same_block t2 r q)))
     (and (= (offset_min t2 a2 r) (offset_min t2 a1 r))
     (= (offset_max t2 a2 r) (offset_max t2 a1 r))))
     (and
     (=> (same_block t2 r p)
     (and (= (offset_min t2 a2 r) (- 0 (sub_pointer t2 r p)))
     (= (offset_max t2 a2 r) (- (- 3) (sub_pointer t2 r p)))))
     (=> (same_block t2 r q)
     (and (= (offset_min t2 a2 r) (- 0 (sub_pointer t2 r q)))
     (= (offset_max t2 a2 r) (- (- n 1) (sub_pointer t2 r q))))))) :pattern (
  (offset_min t2 a2 r)) :pattern ((offset_min t2 a1 r)) :pattern ((offset_max
                                                                  t2 a2 r)) :pattern (
  (offset_max t2 a1 r)) )))
  (=>
  (forall ((r uni))
  (! (=> (sort (pointer1 t2) r)
     (and
     (=> (and (not (same_block t2 r p)) (not (same_block t2 r q)))
     (and (= (offset_min t2 a2 r) (offset_min t2 a1 r))
     (= (offset_max t2 a2 r) (offset_max t2 a1 r))))
     (and
     (=> (same_block t2 r p)
     (and (= (offset_min t2 a2 r) (- 0 (sub_pointer t2 r p)))
     (= (offset_max t2 a2 r) (- (- 3) (sub_pointer t2 r p)))))
     (=> (same_block t2 r q)
     (and (= (offset_min t2 a2 r) (- 0 (sub_pointer t2 r q)))
     (= (offset_max t2 a2 r) (- (- n 1) (sub_pointer t2 r q)))))))) :pattern (
  (offset_min t2 a2 r)) :pattern ((offset_min t2 a1 r)) :pattern ((offset_max
                                                                  t2 a2 r)) :pattern (
  (offset_max t2 a1 r)) )) (switch_blocks t2 a1 a2 p q n))))))

(declare-fun alloc_blockset (ty uni uni uni) Bool)

(declare-fun t2tb6 ((pset intP)) uni)

;; t2tb_sort
  (assert (forall ((x (pset intP))) (sort (pset1 intP1) (t2tb6 x))))

(declare-fun tb2t6 (uni) (pset intP))

;; BridgeL
  (assert
  (forall ((i (pset intP)))
  (! (= (tb2t6 (t2tb6 i)) i) :pattern ((t2tb6 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (pset1 intP1) j) (= (t2tb6 (tb2t6 j)) j)) :pattern ((t2tb6
                                                                   (tb2t6 j))) )))

;; alloc_blockset_def
  (assert
  (forall ((a1 (alloc_table intP)) (a2 (alloc_table intP)) (q (pset intP)))
  (= (alloc_blockset intP1 (t2tb5 a1) (t2tb5 a2) (t2tb6 q))
  (forall ((p (pointer intP)))
  (! (=>
     (forall ((r (pointer intP)))
     (=> (in_pset intP1 (t2tb2 r) (t2tb6 q))
     (not (same_block intP1 (t2tb2 p) (t2tb2 r)))))
     (and (= (offset_min1 a1 p) (offset_min1 a2 p))
     (= (offset_max1 a1 p) (offset_max1 a2 p)))) :pattern ((valid
  intP1 (t2tb5 a1) (t2tb2 p))) :pattern ((valid intP1 (t2tb5 a2)
  (t2tb2 p))) :pattern ((offset_min1 a1 p)) :pattern ((offset_min1 a2 p)) :pattern (
  (offset_max1 a1 p)) :pattern ((offset_max1 a2 p)) )))))

;; alloc_blockset_def
  (assert
  (forall ((t2 ty))
  (forall ((a1 uni) (a2 uni) (q uni))
  (and
  (=> (alloc_blockset t2 a1 a2 q)
  (forall ((p uni))
  (! (=>
     (forall ((r uni))
     (=> (sort (pointer1 t2) r)
     (=> (in_pset t2 r q) (not (same_block t2 p r)))))
     (and (= (offset_min t2 a1 p) (offset_min t2 a2 p))
     (= (offset_max t2 a1 p) (offset_max t2 a2 p)))) :pattern ((valid
  t2 a1 p)) :pattern ((valid t2 a2
  p)) :pattern ((offset_min t2 a1 p)) :pattern ((offset_min t2 a2 p)) :pattern (
  (offset_max t2 a1 p)) :pattern ((offset_max t2 a2 p)) )))
  (=>
  (forall ((p uni))
  (! (=> (sort (pointer1 t2) p)
     (=> (forall ((r uni)) (=> (in_pset t2 r q) (not (same_block t2 p r))))
     (and (= (offset_min t2 a1 p) (offset_min t2 a2 p))
     (= (offset_max t2 a1 p) (offset_max t2 a2 p))))) :pattern ((valid
  t2 a1 p)) :pattern ((valid t2 a2
  p)) :pattern ((offset_min t2 a1 p)) :pattern ((offset_min t2 a2 p)) :pattern (
  (offset_max t2 a1 p)) :pattern ((offset_max t2 a2 p)) )) (alloc_blockset t2
  a1 a2 q))))))

(declare-fun tag_extends (ty uni uni) Bool)

(declare-fun tag_extends1 ((Array (pointer intP) (tag_id intP))
  (Array (pointer intP) (tag_id intP))) Bool)

;; tag_extends_def
  (assert
  (forall ((t11 (Array (pointer intP) (tag_id intP)))
  (t2 (Array (pointer intP) (tag_id intP))))
  (= (tag_extends1 t11 t2)
  (forall ((p (pointer intP)))
  (=> (not (= (select t11 p) bottom_tag1)) (= (select t2 p) (select t11 p)))))))

;; tag_extends_def
  (assert
  (forall ((t2 ty))
  (forall ((t11 uni) (t21 uni))
  (and
  (=> (tag_extends t2 t11 t21)
  (forall ((p uni))
  (=> (not (= (get (tag_id1 t2) (pointer1 t2) t11 p) (bottom_tag t2)))
  (= (get (tag_id1 t2) (pointer1 t2) t21 p) (get (tag_id1 t2) (pointer1 t2)
                                            t11 p)))))
  (=>
  (forall ((p uni))
  (=> (sort (pointer1 t2) p)
  (=> (not (= (get (tag_id1 t2) (pointer1 t2) t11 p) (bottom_tag t2)))
  (= (get (tag_id1 t2) (pointer1 t2) t21 p) (get (tag_id1 t2) (pointer1 t2)
                                            t11 p)))))
  (tag_extends t2 t11 t21))))))

(declare-fun alloc_tag_blockset (ty uni uni uni) Bool)

;; alloc_tag_blockset_def
  (assert
  (forall ((t11 (Array (pointer intP) (tag_id intP)))
  (t2 (Array (pointer intP) (tag_id intP))) (q (pset intP)))
  (= (alloc_tag_blockset intP1 (t2tb t11) (t2tb t2) (t2tb6 q))
  (forall ((p (pointer intP)))
  (! (=> (not (= (select t11 p) bottom_tag1))
     (= (select t2 p) (select t11 p))) :pattern ((select t11 p)) :pattern ((select t2 p)) )))))

;; alloc_tag_blockset_def
  (assert
  (forall ((t2 ty))
  (forall ((t11 uni) (t21 uni) (q uni))
  (and
  (=> (alloc_tag_blockset t2 t11 t21 q)
  (forall ((p uni))
  (! (=> (not (= (get (tag_id1 t2) (pointer1 t2) t11 p) (bottom_tag t2)))
     (= (get (tag_id1 t2) (pointer1 t2) t21 p) (get (tag_id1 t2)
                                               (pointer1 t2) t11 p))) :pattern (
  (get (tag_id1 t2) (pointer1 t2) t11 p)) :pattern ((get (tag_id1 t2)
                                                    (pointer1 t2) t21 p)) )))
  (=>
  (forall ((p uni))
  (! (=> (sort (pointer1 t2) p)
     (=> (not (= (get (tag_id1 t2) (pointer1 t2) t11 p) (bottom_tag t2)))
     (= (get (tag_id1 t2) (pointer1 t2) t21 p) (get (tag_id1 t2)
                                               (pointer1 t2) t11 p)))) :pattern (
  (get (tag_id1 t2) (pointer1 t2) t11 p)) :pattern ((get (tag_id1 t2)
                                                    (pointer1 t2) t21 p)) ))
  (alloc_tag_blockset t2 t11 t21 q))))))

(declare-fun intP_tag () (tag_id intP))

;; IntP_parenttag_bottom
  (assert (parenttag1 intP_tag bottom_tag1))

;; IntP_is_final
  (assert
  (forall ((intP_tag_table (Array (pointer intP) (tag_id intP))))
  (forall ((p (pointer intP)))
  (=> (instanceof1 intP_tag_table p intP_tag)
  (= (select intP_tag_table p) intP_tag)))))

(declare-fun frame_tag_struct_intP ((pointer intP)
  (Array (pointer intP) (tag_id intP))
  (Array (pointer intP) (tag_id intP))) Bool)

;; frame_tag_struct_intP_def
  (assert
  (forall ((p (pointer intP))
  (old_intP_tag_table (Array (pointer intP) (tag_id intP)))
  (intP_tag_table (Array (pointer intP) (tag_id intP))))
  (= (frame_tag_struct_intP p old_intP_tag_table intP_tag_table)
  (tag_extends1 old_intP_tag_table intP_tag_table))))

(declare-fun frame_free_struct_intP ((pointer intP) (alloc_table intP)
  (alloc_table intP)) Bool)

;; frame_free_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (old_intP_alloc_table (alloc_table intP))
  (intP_alloc_table (alloc_table intP)))
  (= (frame_free_struct_intP p old_intP_alloc_table intP_alloc_table)
  (and (free_extends1 old_intP_alloc_table intP_alloc_table) (free_block1
  old_intP_alloc_table intP_alloc_table p)))))

(declare-fun frame_alloc_struct_intP ((pointer intP) Int (alloc_table intP)
  (alloc_table intP)) Bool)

;; frame_alloc_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (n Int)
  (old_intP_alloc_table (alloc_table intP))
  (intP_alloc_table (alloc_table intP)))
  (= (frame_alloc_struct_intP p n old_intP_alloc_table intP_alloc_table)
  (and (alloc_extends1 old_intP_alloc_table intP_alloc_table) (alloc_block1
  old_intP_alloc_table intP_alloc_table p n)))))

(declare-fun typeof_singleton_struct_intP ((pointer intP)
  (Array (pointer intP) (tag_id intP))) Bool)

;; typeof_singleton_struct_intP_def
  (assert
  (forall ((p (pointer intP))
  (intP_tag_table (Array (pointer intP) (tag_id intP))))
  (= (typeof_singleton_struct_intP p intP_tag_table)
  (= (select intP_tag_table p) intP_tag))))

(declare-fun typeof_struct_intP ((pointer intP) Int Int
  (Array (pointer intP) (tag_id intP))) Bool)

;; typeof_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (l Int) (r Int)
  (intP_tag_table (Array (pointer intP) (tag_id intP))))
  (= (typeof_struct_intP p l r intP_tag_table)
  (and (= (select intP_tag_table p) intP_tag)
  (forall ((i Int))
  (=> (and (<= l i) (< i r))
  (= (select intP_tag_table (shift1 p i)) intP_tag)))))))

(declare-fun instanceof_struct_intP ((pointer intP) Int Int
  (Array (pointer intP) (tag_id intP))) Bool)

;; instanceof_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (l Int) (r Int)
  (intP_tag_table (Array (pointer intP) (tag_id intP))))
  (= (instanceof_struct_intP p l r intP_tag_table)
  (and (instanceof1 intP_tag_table p intP_tag)
  (forall ((i Int))
  (=> (and (<= l i) (< i r)) (instanceof1 intP_tag_table (shift1 p i)
  intP_tag)))))))

(declare-fun right_valid_struct_intP ((pointer intP) Int
  (alloc_table intP)) Bool)

;; right_valid_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (b Int) (intP_alloc_table (alloc_table intP)))
  (= (right_valid_struct_intP p b intP_alloc_table)
  (>= (offset_max1 intP_alloc_table p) b))))

(declare-fun left_valid_struct_intP ((pointer intP) Int
  (alloc_table intP)) Bool)

;; left_valid_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (a Int) (intP_alloc_table (alloc_table intP)))
  (= (left_valid_struct_intP p a intP_alloc_table)
  (<= (offset_min1 intP_alloc_table p) a))))

(declare-fun strict_left_valid_struct_intP ((pointer intP) Int
  (alloc_table intP)) Bool)

;; strict_left_valid_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (a Int) (intP_alloc_table (alloc_table intP)))
  (= (strict_left_valid_struct_intP p a intP_alloc_table)
  (= (offset_min1 intP_alloc_table p) a))))

(declare-fun valid_struct_intP ((pointer intP) Int Int
  (alloc_table intP)) Bool)

;; valid_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (a Int) (b Int)
  (intP_alloc_table (alloc_table intP)))
  (= (valid_struct_intP p a b intP_alloc_table)
  (and (<= (offset_min1 intP_alloc_table p) a)
  (>= (offset_max1 intP_alloc_table p) b)))))

(declare-fun strict_valid_struct_intP ((pointer intP) Int Int
  (alloc_table intP)) Bool)

;; strict_valid_struct_intP_def
  (assert
  (forall ((p (pointer intP)) (a Int) (b Int)
  (intP_alloc_table (alloc_table intP)))
  (= (strict_valid_struct_intP p a b intP_alloc_table)
  (and (= (offset_min1 intP_alloc_table p) a)
  (= (offset_max1 intP_alloc_table p) b)))))

;; IntP_int
  (assert (= (int_of_tag1 intP_tag) 4))

(declare-fun count ((pointer intP) Int Int Int (Array (pointer intP) t)) Int)

;; Base
  (assert
  (forall ((intP_intM_a_2_at_L (Array (pointer intP) t)))
  (forall ((a_0_0 (pointer intP)))
  (forall ((i_0 Int))
  (forall ((j_0 Int))
  (forall ((p_0 Int))
  (=> (>= i_0 j_0) (= (count a_0_0 i_0 j_0 p_0 intP_intM_a_2_at_L) 0))))))))

;; Split
  (assert
  (forall ((intP_intM_a_2_at_L (Array (pointer intP) t)))
  (forall ((a_1 (pointer intP)))
  (forall ((i_1 Int))
  (forall ((k_1 Int))
  (forall ((j_1 Int))
  (forall ((p_1 Int))
  (=> (and (<= i_1 k_1) (<= k_1 j_1))
  (= (count a_1 i_1 j_1 p_1 intP_intM_a_2_at_L) (+ (count a_1 i_1 k_1 p_1
                                                   intP_intM_a_2_at_L) 
  (count a_1 k_1 j_1 p_1 intP_intM_a_2_at_L)))))))))))

;; One_0
  (assert
  (forall ((intP_intM_a_2_at_L (Array (pointer intP) t)))
  (forall ((a_3 (pointer intP)))
  (forall ((i_2 Int))
  (forall ((p_2 t))
  (= (not (= (count a_3 i_2 (+ i_2 1) (to_int1 p_2) intP_intM_a_2_at_L) 0))
  (= (select intP_intM_a_2_at_L (shift1 a_3 i_2)) p_2)))))))

;; Split_delta
  (assert
  (forall ((intP_intM_a_4_7_at_L (Array (pointer intP) t)))
  (forall ((a_4 (pointer intP)))
  (forall ((i_3 Int))
  (forall ((j_2 Int))
  (forall ((p_3 Int))
  (=> (and (<= 0 i_3) (<= 0 j_2))
  (= (count a_4 0 (+ i_3 j_2) p_3 intP_intM_a_4_7_at_L) (+ (count a_4 0 i_3
                                                           p_3
                                                           intP_intM_a_4_7_at_L) 
  (count a_4 i_3 (+ i_3 j_2) p_3 intP_intM_a_4_7_at_L))))))))))

(assert
;; WP_parameter_what_more_ensures_default
 ;; File "/home/student/mfsp/examples/what_more/what_more_4.c", line 47, characters 4-43
  (not
  (forall ((a_0 (pointer intP)) (n_9 t) (x t) (y t)
  (intP_a_3_alloc_table (alloc_table intP))
  (intP_a_3_tag_table (Array (pointer intP) (tag_id intP)))
  (intP_intM_a_3 (Array (pointer intP) t)))
  (=>
  (and
  (=> (allocated1 intP_a_3_alloc_table a_0)
  (and (= (select intP_a_3_tag_table a_0) intP_tag)
  (forall ((i Int))
  (=>
  (and (<= (offset_min1 intP_a_3_alloc_table a_0) i)
  (< i (offset_max1 intP_a_3_alloc_table a_0)))
  (= (select intP_a_3_tag_table (shift1 a_0 i)) intP_tag)))))
  (and (infix_gt n_9 (of_int 0))
  (forall ((i_4 Int))
  (=> (and (<= 0 i_4) (< i_4 (to_int1 n_9)))
  (and (<= (offset_min1 intP_a_3_alloc_table a_0) i_4)
  (>= (offset_max1 intP_a_3_alloc_table a_0) i_4))))))
  (=> (not (= x y))
  (forall ((o t))
  (=> (= (to_int1 o) 0)
  (forall ((c_x t))
  (=> (= c_x o)
  (forall ((o1 t))
  (=> (= (to_int1 o1) 0)
  (forall ((c_y t))
  (=> (= c_y o1)
  (forall ((o2 t))
  (=> (= (to_int1 o2) 0)
  (forall ((i_5 t))
  (=> (= i_5 o2)
  (forall ((i_51 t) (c_y1 t) (c_x1 t))
  (=>
  (and (and (infix_lseq (of_int 0) i_51) (infix_lseq i_51 n_9))
  (= (to_int1 c_x1) (count a_0 0 (to_int1 i_51) (to_int1 x) intP_intM_a_3)))
  (forall ((result Bool))
  (=> (= (= result true) (< (to_int1 i_51) (to_int1 n_9)))
  (=> (= result true)
  (=> (= (select intP_intM_a_3 (shift1 a_0 (to_int1 i_51))) x)
  (forall ((o3 t))
  (=> (= (to_int1 o3) 1)
  (forall ((o4 t))
  (=> (= (to_int1 o4) (+ (to_int1 c_x1) (to_int1 o3)))
  (forall ((c_x2 t))
  (=> (= c_x2 o4)
  (=>
  (= (count a_0 0 (+ (to_int1 i_51) 1) (to_int1 x) intP_intM_a_3) (count a_0
                                                                  0
                                                                  (+ 1 
                                                                  (to_int1
                                                                  i_51))
                                                                  (to_int1 x)
                                                                  intP_intM_a_3))
  (forall ((o5 t))
  (=> (= (to_int1 o5) 1)
  (forall ((o6 t))
  (=> (= (to_int1 o6) (- (to_int1 n_9) (to_int1 i_51)))
  (forall ((o7 t))
  (=> (= (to_int1 o7) (- (to_int1 o6) (to_int1 o5)))
  (forall ((o8 t))
  (=> (= (to_int1 o8) (+ (to_int1 c_y1) (to_int1 o7)))
  (forall ((result1 Bool))
  (=> (= (= result1 true) (< (to_int1 o8) (to_int1 c_x2)))
  (=> (not (= result1 true))
  (forall ((o9 t))
  (=> (= (to_int1 o9) 1)
  (forall ((o10 t))
  (=> (= (to_int1 o10) (- (to_int1 n_9) (to_int1 i_51)))
  (forall ((o11 t))
  (=> (= (to_int1 o11) (- (to_int1 o10) (to_int1 o9)))
  (forall ((o12 t))
  (=> (= (to_int1 o12) (+ (to_int1 c_x2) (to_int1 o11)))
  (forall ((result2 Bool))
  (=> (= (= result2 true) (< (to_int1 o12) (to_int1 c_y1)))
  (=> (not (= result2 true))
  (forall ((o13 t))
  (=> (= (to_int1 o13) 1)
  (forall ((o14 t))
  (=> (= (to_int1 o14) (+ (to_int1 i_51) (to_int1 o13)))
  (forall ((i_52 t))
  (=> (= i_52 o14)
  (=> (and (infix_lseq (of_int 0) i_52) (infix_lseq i_52 n_9))
  (= (to_int1 c_x2) (count a_0 0 (to_int1 i_52) (to_int1 x) intP_intM_a_3)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(check-sat)
