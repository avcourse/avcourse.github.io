
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

theory Axiomatic_Count

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function count (pointer voidP) int int int (memory voidP Int32.t) :
  int
  
  
  axiom Count_base #"/home/debian/mfsp/examples/auto-av/selsort.c" 2 68 167#
  "expl:Axiom count_base"  :
  (forall intP_intM_a_2_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 4 22 96#
   (forall a_0_0 : (pointer voidP).
    (forall m_0_0 : int.
     (forall n_2_0 : int.
      (forall p_0 : int.
       (((>=) m_0_0 n_2_0) ->
        ((=) (count a_0_0 m_0_0 n_2_0 p_0 intP_intM_a_2_at_L) (0)))))))))
  
  axiom Count_split #"/home/debian/mfsp/examples/auto-av/selsort.c" 5 31 175#
  "expl:Axiom count_split"  :
  (forall intP_intM_a_2_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 7 23 141#
   (forall a_1 : (pointer voidP).
    (forall m_1 : int.
     (forall n_3_0 : int.
      (forall k_1 : int.
       (forall p_1 : int.
        ((((<=) m_1 n_3_0) /\ ((<=) n_3_0 k_1)) ->
         ((=) (count a_1 m_1 k_1 p_1 intP_intM_a_2_at_L)
         (Int.(+) (count a_1 m_1 n_3_0 p_1 intP_intM_a_2_at_L)
         (count a_1 n_3_0 k_1 p_1 intP_intM_a_2_at_L)))))))))))
  
  axiom Count_one #"/home/debian/mfsp/examples/auto-av/selsort.c" 8 67 173#
  "expl:Axiom count_one"  :
  (forall intP_intM_a_2_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 10 21 103#
   (forall a_2 : (pointer voidP).
    (forall m_2 : int.
     (forall p_2 : int.
      ((=) (count a_2 m_2 (Int.(+) m_2 (1)) p_2 intP_intM_a_2_at_L)
      (if
       ((=) (Int32.to_int (select intP_intM_a_2_at_L (shift a_2 m_2))) p_2)
       then (1) else (0))))))))
  
end

theory Axiomatic_Ordered

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use bool.Bool 
  
  use why3.Bool.Bool 
  
  predicate ordered (pointer voidP) int int (memory voidP
  Int32.t)
  
  
  axiom Ordered_base
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 15 55 147#
  "expl:Axiom ordered_base"  :
  (forall intP_intM_a_3_3_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 17 24 89#
   (forall a_4 : (pointer voidP).
    (forall m_4 : int.
     (forall n_5 : int.
      (((>=) m_4 n_5) -> (ordered a_4 m_4 n_5 intP_intM_a_3_3_at_L)))))))
  
  axiom Ordered_split
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 18 25 168#
  "expl:Axiom ordered_split"  :
  (forall intP_intM_a_3_3_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 20 25 140#
   (forall a_5 : (pointer voidP).
    (forall m_5 : int.
     (forall k_2 : int.
      (forall n_6 : int.
       (((((<=) m_5 n_6) /\ ((<=) n_6 k_2)) ->
         (ordered a_5 m_5 k_2 intP_intM_a_3_3_at_L))
       <->
       ((ordered a_5 m_5 n_6 intP_intM_a_3_3_at_L) /\
       (ordered a_5 n_6 k_2 intP_intM_a_3_3_at_L)))))))))
  
  axiom Ordered_two
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 21 67 170#
  "expl:Axiom ordered_two"  :
  (forall intP_intM_a_3_3_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 23 23 100#
   (forall a_6 : (pointer voidP).
    (forall m_6 : int.
     ((ordered a_6 m_6 (Int.(+) m_6 (1)) intP_intM_a_3_3_at_L) <->
     (Int32.(<=) (select intP_intM_a_3_3_at_L (shift a_6 m_6))
     (select intP_intM_a_3_3_at_L (shift a_6 (Int.(+) m_6 (1))))))))))
  
end

theory Logic_count_sum

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use int.Int 
  
  use import Axiomatic_Count 
  
  use why3.Bool.Bool 
  
  function count_sum (a_8 : (pointer voidP)) (i_1 : int) (j_1 : int) (n_10 :
  int) (p_6 : int) (intP_intM_a_8_15_at_L : (memory voidP Int32.t)) : int
  =
     (Int.(+)
     (Int.(+)
     (Int.(+)
     (Int.(+) (count a_8 (0) i_1 p_6 intP_intM_a_8_15_at_L)
     (count a_8 i_1 (Int.(+) i_1 (1)) p_6 intP_intM_a_8_15_at_L))
     (count a_8 (Int.(+) i_1 (1)) j_1 p_6 intP_intM_a_8_15_at_L))
     (count a_8 j_1 (Int.(+) j_1 (1)) p_6 intP_intM_a_8_15_at_L))
     (count a_8 (Int.(+) j_1 (1)) n_10 p_6 intP_intM_a_8_15_at_L))
  
  
end

theory Lemma_count_splitted #"selsort_c.jc" 357 0 2321#
"expl:Lemma count_splitted"

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_sum 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Count 
  
  use why3.Bool.Bool 
  
  lemma Count_splitted
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 138 128 1062#
  "expl:Lemma count_splitted"  :
  (forall intP_intM_a_9_23_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 141 8 905#
   (forall a_9 : (pointer voidP).
    (forall i_2 : int.
     (forall j_2_0 : int.
      (forall n_11 : int.
       ((((<=) (0) i_2) /\
        (((<=) i_2 (Int.(+) i_2 (1))) /\
        (((<=) (Int.(+) i_2 (1)) j_2_0) /\
        (((<=) j_2_0 (Int.(+) j_2_0 (1))) /\ ((<=) (Int.(+) j_2_0 (1)) n_11)))))
        ->
        (forall p_7 : int.
         (((=) (count a_9 (0) n_11 p_7 intP_intM_a_9_23_at_L)
          (Int.(+) (count a_9 (0) i_2 p_7 intP_intM_a_9_23_at_L)
          (count a_9 i_2 n_11 p_7 intP_intM_a_9_23_at_L)))
         /\
         (((=) (count a_9 i_2 n_11 p_7 intP_intM_a_9_23_at_L)
          (Int.(+)
          (count a_9 i_2 (Int.(+) i_2 (1)) p_7 intP_intM_a_9_23_at_L)
          (count a_9 (Int.(+) i_2 (1)) n_11 p_7 intP_intM_a_9_23_at_L)))
         /\
         (((=) (count a_9 (Int.(+) i_2 (1)) n_11 p_7 intP_intM_a_9_23_at_L)
          (Int.(+)
          (count a_9 (Int.(+) i_2 (1)) j_2_0 p_7 intP_intM_a_9_23_at_L)
          (count a_9 j_2_0 n_11 p_7 intP_intM_a_9_23_at_L)))
         /\
         (((=) (count a_9 j_2_0 n_11 p_7 intP_intM_a_9_23_at_L)
          (Int.(+)
          (count a_9 j_2_0 (Int.(+) j_2_0 (1)) p_7 intP_intM_a_9_23_at_L)
          (count a_9 (Int.(+) j_2_0 (1)) n_11 p_7 intP_intM_a_9_23_at_L)))
         /\
         (((=) (count a_9 (Int.(+) i_2 (1)) n_11 p_7 intP_intM_a_9_23_at_L)
          (Int.(+)
          (Int.(+)
          (count a_9 (Int.(+) i_2 (1)) j_2_0 p_7 intP_intM_a_9_23_at_L)
          (count a_9 j_2_0 (Int.(+) j_2_0 (1)) p_7 intP_intM_a_9_23_at_L))
          (count a_9 (Int.(+) j_2_0 (1)) n_11 p_7 intP_intM_a_9_23_at_L)))
         /\
         (((=) (count a_9 i_2 n_11 p_7 intP_intM_a_9_23_at_L)
          (Int.(+)
          (Int.(+)
          (Int.(+)
          (count a_9 i_2 (Int.(+) i_2 (1)) p_7 intP_intM_a_9_23_at_L)
          (count a_9 (Int.(+) i_2 (1)) j_2_0 p_7 intP_intM_a_9_23_at_L))
          (count a_9 j_2_0 (Int.(+) j_2_0 (1)) p_7 intP_intM_a_9_23_at_L))
          (count a_9 (Int.(+) j_2_0 (1)) n_11 p_7 intP_intM_a_9_23_at_L)))
         /\
         (((=) (count a_9 (0) n_11 p_7 intP_intM_a_9_23_at_L)
          (Int.(+)
          (Int.(+)
          (Int.(+)
          (Int.(+) (count a_9 (0) i_2 p_7 intP_intM_a_9_23_at_L)
          (count a_9 i_2 (Int.(+) i_2 (1)) p_7 intP_intM_a_9_23_at_L))
          (count a_9 (Int.(+) i_2 (1)) j_2_0 p_7 intP_intM_a_9_23_at_L))
          (count a_9 j_2_0 (Int.(+) j_2_0 (1)) p_7 intP_intM_a_9_23_at_L))
          (count a_9 (Int.(+) j_2_0 (1)) n_11 p_7 intP_intM_a_9_23_at_L)))
         /\
         ((=) (count a_9 (0) n_11 p_7 intP_intM_a_9_23_at_L)
         (count_sum a_9 i_2 j_2_0 n_11 p_7 intP_intM_a_9_23_at_L)))))))))))))))))
  
end

theory Logic_count_saved

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Count 
  
  use why3.Bool.Bool 
  
  predicate count_saved (a1_0_0 : (pointer voidP)) (a2_0_0 : (pointer voidP))
  (m_8 : int) (n_8 : int) (intP_intM_a2_0_7_at_L2 : (memory voidP Int32.t))
  (intP_intM_a1_0_6_at_L1 : (memory voidP Int32.t))
  =
     (forall p_3 : int.
      ((=) (count a1_0_0 m_8 n_8 p_3 intP_intM_a1_0_6_at_L1)
      (count a2_0_0 m_8 n_8 p_3 intP_intM_a2_0_7_at_L2)))
  
  
end

theory Lemma_count_saved_trans #"selsort_c.jc" 413 0 484#
"expl:Lemma count_saved_trans"

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  lemma Count_saved_trans
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 157 110 301#
  "expl:Lemma count_saved_trans"  :
  (forall intP_intM_c_29_at_L3 : (memory voidP Int32.t).
   (forall intP_intM_b_0_28_at_L2 : (memory voidP Int32.t).
    (forall intP_intM_a_12_27_at_L1 : (memory voidP Int32.t).
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 159 8 148#
     (forall a_12 : (pointer voidP).
      (forall b_0 : (pointer voidP).
       (forall c : (pointer voidP).
        (forall m_12 : int.
         (forall n_14 : int.
          (((count_saved a_12 b_0 m_12 n_14 intP_intM_b_0_28_at_L2
            intP_intM_a_12_27_at_L1)
           /\
           (count_saved b_0 c m_12 n_14 intP_intM_c_29_at_L3
           intP_intM_b_0_28_at_L2)) ->
           (count_saved a_12 c m_12 n_14 intP_intM_c_29_at_L3
           intP_intM_a_12_27_at_L1)))))))))))
  
end

theory Lemma_count_saved_refl #"selsort_c.jc" 397 0 191#
"expl:Lemma count_saved_refl"

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  lemma Count_saved_refl
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 153 3 441#
  "expl:Lemma count_saved_refl"  :
  (forall intP_intM_a_10_24_at_L : (memory voidP Int32.t).
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 155 8 67#
   (forall a_10 : (pointer voidP).
    (forall m_10 : int.
     (forall n_12_0 : int.
      (count_saved a_10 a_10 m_10 n_12_0 intP_intM_a_10_24_at_L
      intP_intM_a_10_24_at_L))))))
  
end

theory Lemma_count_saved_comm #"selsort_c.jc" 403 0 338#
"expl:Lemma count_saved_comm"

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  lemma Count_saved_comm
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 155 68 406#
  "expl:Lemma count_saved_comm"  :
  (forall intP_intM_b_26_at_L2 : (memory voidP Int32.t).
   (forall intP_intM_a_11_25_at_L1 : (memory voidP Int32.t).
    (#"/home/debian/mfsp/examples/auto-av/selsort.c" 157 8 109#
    (forall a_11 : (pointer voidP).
     (forall b : (pointer voidP).
      (forall m_11 : int.
       (forall n_13 : int.
        ((count_saved a_11 b m_11 n_13 intP_intM_b_26_at_L2
         intP_intM_a_11_25_at_L1) ->
         (count_saved b a_11 m_11 n_13 intP_intM_a_11_25_at_L1
         intP_intM_b_26_at_L2)))))))))
  
end

theory Logic_array_saved

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate array_saved (a1_5 : (pointer voidP)) (a2_5 : (pointer voidP))
  (m_7 : int) (n_7 : int) (intP_intM_a2_5_at_L2 : (memory voidP Int32.t))
  (intP_intM_a1_4_at_L1 : (memory voidP Int32.t))
  =
     (forall k_3 : int.
      ((((<=) m_7 k_3) /\ ((<=) k_3 n_7)) ->
       (Int32.(=) (select intP_intM_a1_4_at_L1 (shift a1_5 k_3))
       (select intP_intM_a2_5_at_L2 (shift a2_5 k_3)))))
  
  
end

module Function_count_frame_proof_safe

  use import core.Voidp 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val count_frame_proof
  (a1_1_0 : (pointer voidP)) 
   (a2_1_0 : (pointer voidP)) 
    (m_0 : Int32.t) 
     (n_3 : Int32.t) 
      (voidP_a2_1_9_alloc_table : (alloc_table voidP)) 
       (voidP_a1_1_8_alloc_table : (alloc_table voidP)) 
        (intP_intM_a2_1_9 : (memory voidP Int32.t)) 
         (intP_intM_a1_1_8 : (memory voidP Int32.t)) : unit
          requires {
            ("expl:Internal"
            (#"selsort_c.jc" 131 12 1388# "expl:Requires clause"
            ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 46 14 39#
             "expl:Requires clause"
             (if ((<=) (Int32.to_int m_0) (Int.(-) (Int32.to_int n_3) (1)))
              then
              (((<=) (offset_min voidP_a1_1_8_alloc_table a1_1_0)
               (Int32.to_int m_0))
              /\
              (((>=) (offset_max voidP_a1_1_8_alloc_table a1_1_0)
               (Int.(-) (Int32.to_int n_3) (1)))
              /\
              (forall __framac_tmp1 : int.
               ((((<=) (Int32.to_int m_0) __framac_tmp1) /\
                ((<=) __framac_tmp1 (Int.(-) (Int32.to_int n_3) (1)))) ->
                ((=) true true))))) else ((=) true true)))
            /\
            (#"selsort_c.jc" 131 12 1388# "expl:Requires clause"
            ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 47 14 39#
             "expl:Requires clause"
             (if ((<=) (Int32.to_int m_0) (Int.(-) (Int32.to_int n_3) (1)))
              then
              (((<=) (offset_min voidP_a2_1_9_alloc_table a2_1_0)
               (Int32.to_int m_0))
              /\
              (((>=) (offset_max voidP_a2_1_9_alloc_table a2_1_0)
               (Int.(-) (Int32.to_int n_3) (1)))
              /\
              (forall __framac_tmp2 : int.
               ((((<=) (Int32.to_int m_0) __framac_tmp2) /\
                ((<=) __framac_tmp2 (Int.(-) (Int32.to_int n_3) (1)))) ->
                ((=) true true))))) else ((=) true true)))
            /\
            (#"/home/debian/mfsp/examples/auto-av/selsort.c" 48 14 55#
            "expl:Requires clause"
            (array_saved a1_1_0 a2_1_0 (Int32.to_int m_0)
            (Int.(-) (Int32.to_int n_3) (1)) intP_intM_a2_1_9
            intP_intM_a1_1_8))))))) }
          ensures {
            (#"/home/debian/mfsp/examples/auto-av/selsort.c" 51 13 50#
            "expl:Ensures clause"
            (count_saved a1_1_0 a2_1_0 (Int32.to_int m_0) (Int32.to_int n_3)
            intP_intM_a2_1_9 intP_intM_a1_1_8)) }
  
end

module Function_count_frame_proof_safety
#"/home/debian/mfsp/examples/auto-av/selsort.c" 53 7 56#
"expl:count_frame_proof, safety"

  use import core.Zwf 
  
  use import core.Voidp 
  
  use Safe_int32 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_count_frame_proof_safe 
  
  use import Axiomatic_Count 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let count_frame_proof
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 53 7 56#
  "expl:Function count_frame_proof, safety" =
  fun
   (a1_1_0 : (pointer voidP)) (a2_1_0 : (pointer voidP)) (m_0 : Int32.t) (n_3
   : Int32.t) (voidP_a1_1_8_alloc_table : (alloc_table voidP))
   (voidP_a2_1_9_alloc_table : (alloc_table voidP)) (intP_intM_a1_1_8 :
   (memory voidP Int32.t)) (intP_intM_a2_1_9 : (memory voidP Int32.t)) 
   requires {
   (#"selsort_c.jc" 131 12 1388#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 46 14 39#
    (if ((<=) (Int32.to_int m_0) (Int.(-) (Int32.to_int n_3) (1))) then
     (((<=) (offset_min voidP_a1_1_8_alloc_table a1_1_0) (Int32.to_int m_0))
     /\
     (((>=) (offset_max voidP_a1_1_8_alloc_table a1_1_0)
      (Int.(-) (Int32.to_int n_3) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (Int32.to_int m_0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int n_3) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"selsort_c.jc" 131 12 1388#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 47 14 39#
    (if ((<=) (Int32.to_int m_0) (Int.(-) (Int32.to_int n_3) (1))) then
     (((<=) (offset_min voidP_a2_1_9_alloc_table a2_1_0) (Int32.to_int m_0))
     /\
     (((>=) (offset_max voidP_a2_1_9_alloc_table a2_1_0)
      (Int.(-) (Int32.to_int n_3) (1)))
     /\
     (forall __framac_tmp2 : int.
      ((((<=) (Int32.to_int m_0) __framac_tmp2) /\
       ((<=) __framac_tmp2 (Int.(-) (Int32.to_int n_3) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 48 14 55#
   (array_saved a1_1_0 a2_1_0 (Int32.to_int m_0)
   (Int.(-) (Int32.to_int n_3) (1)) intP_intM_a2_1_9 intP_intM_a1_1_8)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (if
    (#"/home/debian/mfsp/examples/auto-av/selsort.c" 55 12 17#
    (Safe_int32.(<)  m_0 n_3 ))
    then
     begin
     (let _jessie_20 = a1_1_0 in
     (let _jessie_19 = a2_1_0 in
     (let _jessie_18 =
     (Safe_int32.(+)  m_0
      (#"selsort_c.jc" 162 57 69# "expl:Integer cast"
      (Safe_int32.of_int (1))) ) in
     (let _jessie_17 = n_3 in
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 56 12 47#
     "expl:Variant decreases"
     begin
     (check {
     (zwf_zero (#"/home/debian/mfsp/examples/auto-av/selsort.c" 49 15 20#
     (Int.(-) (Int32.to_int _jessie_17) (Int32.to_int _jessie_18)))
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 49 15 20#
     (Int.(-) (Int32.to_int n_3) (Int32.to_int m_0)))) });
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 56 12 47#
      "expl:Precondition for count_frame_proof"
      (Function_count_frame_proof_safe.count_frame_proof  _jessie_20
       _jessie_19 _jessie_18 _jessie_17 voidP_a2_1_9_alloc_table
       voidP_a1_1_8_alloc_table intP_intM_a2_1_9 intP_intM_a1_1_8 )) end)))));
      begin
      any unit
      requires { true } reads { a1_1_0, m_0, n_3 }
      ensures {
        (#"/home/debian/mfsp/examples/auto-av/selsort.c" 57 23 111#
        (forall p_4 : int.
         ((=)
         (count a1_1_0 (Int32.to_int m_0) (Int32.to_int n_3) p_4
         intP_intM_a1_1_8)
         (Int.(+)
         (count a1_1_0 (Int32.to_int m_0) (Int.(+) (Int32.to_int m_0) (1))
         p_4 intP_intM_a1_1_8)
         (count a1_1_0 (Int.(+) (Int32.to_int m_0) (1)) (Int32.to_int n_3)
         p_4 intP_intM_a1_1_8))))) } ; () end;
      begin
      any unit
      requires { true } reads { a2_1_0, m_0, n_3 }
      ensures {
        (#"/home/debian/mfsp/examples/auto-av/selsort.c" 58 23 111#
        (forall p_5 : int.
         ((=)
         (count a2_1_0 (Int32.to_int m_0) (Int32.to_int n_3) p_5
         intP_intM_a2_1_9)
         (Int.(+)
         (count a2_1_0 (Int32.to_int m_0) (Int.(+) (Int32.to_int m_0) (1))
         p_5 intP_intM_a2_1_9)
         (count a2_1_0 (Int.(+) (Int32.to_int m_0) (1)) (Int32.to_int n_3)
         p_5 intP_intM_a2_1_9))))) } ; () end end else ()); (raise Return);
     (raise Return) end with Return -> () end
  
end

module Function_count_frame_proof

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val count_frame_proof
  (a1_1_0 : (pointer voidP)) 
   (a2_1_0 : (pointer voidP)) 
    (m_0 : Int32.t) 
     (n_3 : Int32.t) 
      (voidP_a2_1_9_alloc_table : (alloc_table voidP)) 
       (voidP_a1_1_8_alloc_table : (alloc_table voidP)) 
        (intP_intM_a2_1_9 : (memory voidP Int32.t)) 
         (intP_intM_a1_1_8 : (memory voidP Int32.t)) : unit
          requires { true }
          ensures {
            (#"/home/debian/mfsp/examples/auto-av/selsort.c" 51 13 50#
            "expl:Ensures clause"
            (count_saved a1_1_0 a2_1_0 (Int32.to_int m_0) (Int32.to_int n_3)
            intP_intM_a2_1_9 intP_intM_a1_1_8)) }
  
end

module Function_count_frame_proof_behaviors
#"/home/debian/mfsp/examples/auto-av/selsort.c" 53 7 56#
"expl:count_frame_proof, behaviors"

  use import core.Voidp 
  
  use Unsafe_int32 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_count_frame_proof 
  
  use import Axiomatic_Count 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let count_frame_proof_ensures_default
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 53 7 56#
  "expl:Function count_frame_proof, default behavior" =
  fun
   (a1_1_0 : (pointer voidP)) (a2_1_0 : (pointer voidP)) (m_0 : Int32.t) (n_3
   : Int32.t) (voidP_a1_1_8_alloc_table : (alloc_table voidP))
   (voidP_a2_1_9_alloc_table : (alloc_table voidP)) (intP_intM_a1_1_8 :
   (memory voidP Int32.t)) (intP_intM_a2_1_9 : (memory voidP Int32.t)) 
   requires {
   (#"selsort_c.jc" 131 12 1388#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 46 14 39#
    (if ((<=) (Int32.to_int m_0) (Int.(-) (Int32.to_int n_3) (1))) then
     (((<=) (offset_min voidP_a1_1_8_alloc_table a1_1_0) (Int32.to_int m_0))
     /\
     (((>=) (offset_max voidP_a1_1_8_alloc_table a1_1_0)
      (Int.(-) (Int32.to_int n_3) (1)))
     /\
     (forall __framac_tmp1 : int.
      ((((<=) (Int32.to_int m_0) __framac_tmp1) /\
       ((<=) __framac_tmp1 (Int.(-) (Int32.to_int n_3) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"selsort_c.jc" 131 12 1388#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 47 14 39#
    (if ((<=) (Int32.to_int m_0) (Int.(-) (Int32.to_int n_3) (1))) then
     (((<=) (offset_min voidP_a2_1_9_alloc_table a2_1_0) (Int32.to_int m_0))
     /\
     (((>=) (offset_max voidP_a2_1_9_alloc_table a2_1_0)
      (Int.(-) (Int32.to_int n_3) (1)))
     /\
     (forall __framac_tmp2 : int.
      ((((<=) (Int32.to_int m_0) __framac_tmp2) /\
       ((<=) __framac_tmp2 (Int.(-) (Int32.to_int n_3) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 48 14 55#
   (array_saved a1_1_0 a2_1_0 (Int32.to_int m_0)
   (Int.(-) (Int32.to_int n_3) (1)) intP_intM_a2_1_9 intP_intM_a1_1_8)))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 51 13 50#
     "expl:Ensures clause"
     (count_saved a1_1_0 a2_1_0 (Int32.to_int m_0) (Int32.to_int n_3)
     intP_intM_a2_1_9 intP_intM_a1_1_8))) }  ->
   'Init:
   try
    begin
    (if
    (#"/home/debian/mfsp/examples/auto-av/selsort.c" 55 12 17#
    (Unsafe_int32.(<)  m_0 n_3 ))
    then
     begin
     (let _jessie_16 = a1_1_0 in
     (let _jessie_15 = a2_1_0 in
     (let _jessie_14 =
     (Unsafe_int32.(+)  m_0
      (#"selsort_c.jc" 162 57 69# "expl:Integer cast"
      (Unsafe_int32.of_int (1))) ) in
     (let _jessie_13 = n_3 in
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 56 12 47#
     "expl:Precondition for count_frame_proof"
     (Function_count_frame_proof.count_frame_proof  _jessie_16 _jessie_15
      _jessie_14 _jessie_13 voidP_a2_1_9_alloc_table voidP_a1_1_8_alloc_table
      intP_intM_a2_1_9 intP_intM_a1_1_8 ))))));
      begin
      (assert {
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 57 23 111#
      "expl:Assertion in line 57"
      (forall p_4 : int.
       ((=)
       (count a1_1_0 (Int32.to_int m_0) (Int32.to_int n_3) p_4
       intP_intM_a1_1_8)
       (Int.(+)
       (count a1_1_0 (Int32.to_int m_0) (Int.(+) (Int32.to_int m_0) (1)) p_4
       intP_intM_a1_1_8)
       (count a1_1_0 (Int.(+) (Int32.to_int m_0) (1)) (Int32.to_int n_3) p_4
       intP_intM_a1_1_8))))) }); () end;
      begin
      (assert {
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 58 23 111#
      "expl:Assertion in line 58"
      (forall p_5 : int.
       ((=)
       (count a2_1_0 (Int32.to_int m_0) (Int32.to_int n_3) p_5
       intP_intM_a2_1_9)
       (Int.(+)
       (count a2_1_0 (Int32.to_int m_0) (Int.(+) (Int32.to_int m_0) (1)) p_5
       intP_intM_a2_1_9)
       (count a2_1_0 (Int.(+) (Int32.to_int m_0) (1)) (Int32.to_int n_3) p_5
       intP_intM_a2_1_9))))) }); () end end else ()); (raise Return);
     (raise Return) end with Return -> () end
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Goto_while_0_break_0_exc unit
  
  exception Goto_while_1_break_exc unit
  
  exception Goto_while_1_break_0_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_count_frame2_proof_safety
#"/home/debian/mfsp/examples/auto-av/selsort.c" 74 7 50#
"expl:count_frame2_proof, safety"

  use import core.Voidp 
  
  use Safe_int32 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_count_frame_proof_safe 
  
  use import Exceptions 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let count_frame2_proof
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 74 7 50#
  "expl:Function count_frame2_proof, safety" =
  fun
   (a1_0_1 : (pointer voidP)) (a2_0_1 : (pointer voidP)) (n_2 : Int32.t)
   (voidP_a1_0_10_alloc_table : (alloc_table voidP))
   (voidP_a2_0_11_alloc_table : (alloc_table voidP)) (intP_intM_a1_0_10 :
   (memory voidP Int32.t)) (intP_intM_a2_0_11 : (memory voidP Int32.t)) 
   requires {
   (#"selsort_c.jc" 215 12 1467#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 67 14 20#
    (Int32.(>=) n_2 (#"selsort_c.jc" 215 29 41# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"selsort_c.jc" 215 12 1467#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 68 14 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a1_0_10_alloc_table a1_0_1) (0)) /\
     (((>=) (offset_max voidP_a1_0_10_alloc_table a1_0_1)
      (Int.(-) (Int32.to_int n_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Int32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"selsort_c.jc" 215 12 1467#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 69 14 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a2_0_11_alloc_table a2_0_1) (0)) /\
     (((>=) (offset_max voidP_a2_0_11_alloc_table a2_0_1)
      (Int.(-) (Int32.to_int n_2) (1)))
     /\
     (forall __framac_tmp4 : int.
      ((((<=) (0) __framac_tmp4) /\
       ((<=) __framac_tmp4 (Int.(-) (Int32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 70 14 55#
   (array_saved a1_0_1 a2_0_1 (0) (Int.(-) (Int32.to_int n_2) (1))
   intP_intM_a2_0_11 intP_intM_a1_0_10)))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let i_0 = ref (Safe_int32.any_  () ) in
    (let j = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_0 :=
      (let _jessie_36 =
      (#"selsort_c.jc" 252 20 32# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 76 8 9#
      "expl:Pointer index bounds" true) }); _jessie_36 end));
      'LoopEntry:
      begin
      'LoopEntry:
      'Loop_3:
      loop
      invariant { (#"selsort_c.jc" 254 6 2067# true) }
        variant { (#"/home/debian/mfsp/examples/auto-av/selsort.c" 80 21 26#
          (Int.(-) (Int32.to_int n_2) (Int32.to_int !i_0))) }
       begin
       any unit
       requires { true } reads { a1_0_1, a2_0_1, n_2 }
       ensures {
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 79 23 112#
          (forall k_5 : int.
           (forall j_2 : int.
            ((((<=) (0) k_5) /\
             (((<) k_5 (Int32.to_int !i_0)) /\
             (((<=) (0) j_2) /\ ((<=) j_2 (Int32.to_int n_2))))) ->
             (count_saved a1_0_1 a2_0_1 k_5 j_2 intP_intM_a2_0_11
             intP_intM_a1_0_10)))))
         /\
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 23 34#
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 23 34#
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 23 29#
          (Int32.(<=) (#"selsort_c.jc" 256 38 50# "expl:Integer cast"
          (Int32.of_int (0))) !i_0))
         /\
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 28 34#
         (Int32.(<=) !i_0 n_2)))))) } ;
        try
         begin
         'LoopCurrent:
         'LoopCurrent:
         try
          begin
          (j :=
           (let _jessie_34 =
           (#"selsort_c.jc" 269 26 38# "expl:Integer cast"
           (Safe_int32.of_int (0))) in
           begin
           (assert {
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 84 12 13#
           "expl:Pointer index bounds" true) }); _jessie_34 end));
           'LoopEntry:
           begin
           'LoopEntry:
           'Loop_4:
           loop
           invariant { (#"selsort_c.jc" 271 12 989# true) }
             variant {
               (#"/home/debian/mfsp/examples/auto-av/selsort.c" 88 25 30#
               (Int.(-) (Int32.to_int n_2) (Int32.to_int !j))) }
            begin
            any unit
            requires { true } reads { a1_0_1, a2_0_1, n_2 }
            ensures {
              ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 87 27 98#
               (forall k_4 : int.
                ((((<=) (0) k_4) /\ ((<) k_4 (Int32.to_int !j))) ->
                 (count_saved a1_0_1 a2_0_1 (Int32.to_int !i_0) k_4
                 intP_intM_a2_0_11 intP_intM_a1_0_10))))
              /\
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 27 38#
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 27 38#
              ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 27 33#
               (Int32.(<=) (#"selsort_c.jc" 273 44 56# "expl:Integer cast"
               (Int32.of_int (0))) !j))
              /\
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 32 38#
              (Int32.(<=) !j n_2)))))) } ;
             try
              begin
              'LoopCurrent:
              'LoopCurrent:
              begin
              (let _jessie_32 = a1_0_1 in
              (let _jessie_31 = a2_0_1 in
              (let _jessie_30 = !i_0 in
              (let _jessie_29 = !j in
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 92 12 43#
              "expl:Precondition for count_frame_proof"
              (Function_count_frame_proof_safe.count_frame_proof  _jessie_32
               _jessie_31 _jessie_30 _jessie_29 voidP_a2_0_11_alloc_table
               voidP_a1_0_10_alloc_table intP_intM_a2_0_11 intP_intM_a1_0_10
               ))))));
               (if
               (#"/home/debian/mfsp/examples/auto-av/selsort.c" 94 16 22#
               (Safe_int32.(=)  !j n_2 ))
               then (raise (Goto_while_1_break_exc ()))
               else
                (j :=
                 (let _jessie_33 =
                 (Safe_int32.(+)  !j
                  (#"selsort_c.jc" 287 68 80# "expl:Integer cast"
                  (Safe_int32.of_int (1))) ) in
                 begin
                 (assert {
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 97 16 20#
                 "expl:Pointer index bounds" true) }); _jessie_33 end))) end;
               (raise (Loop_continue_exc ())) end with Loop_continue_exc
              _jessie_4 -> () end end end;
            (raise (Goto_while_1_break_exc ())) end end with
          Goto_while_1_break_exc _jessie_1 ->
          'While_1_break:
          'While_1_break:
          begin
          ();
           (if
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 102 12 18#
           (Safe_int32.(=)  !i_0 n_2 ))
           then (raise (Goto_while_0_break_exc ()))
           else
            (i_0 :=
             (let _jessie_35 =
             (Safe_int32.(+)  !i_0
              (#"selsort_c.jc" 294 64 76# "expl:Integer cast"
              (Safe_int32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/debian/mfsp/examples/auto-av/selsort.c" 105 12 15#
             "expl:Pointer index bounds" true) }); _jessie_35 end))) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc _jessie_6
         -> () end end end; (raise (Goto_while_0_break_exc ())) end end with
     Goto_while_0_break_exc _jessie_2 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end));
     (raise Return) end with Return -> () end
  
end

module Function_count_frame2_proof_behaviors
#"/home/debian/mfsp/examples/auto-av/selsort.c" 74 7 50#
"expl:count_frame2_proof, behaviors"

  use import core.Voidp 
  
  use Unsafe_int32 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_count_frame_proof 
  
  use import Exceptions 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let count_frame2_proof_ensures_default
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 74 7 50#
  "expl:Function count_frame2_proof, default behavior" =
  fun
   (a1_0_1 : (pointer voidP)) (a2_0_1 : (pointer voidP)) (n_2 : Int32.t)
   (voidP_a1_0_10_alloc_table : (alloc_table voidP))
   (voidP_a2_0_11_alloc_table : (alloc_table voidP)) (intP_intM_a1_0_10 :
   (memory voidP Int32.t)) (intP_intM_a2_0_11 : (memory voidP Int32.t)) 
   requires {
   (#"selsort_c.jc" 215 12 1467#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 67 14 20#
    (Int32.(>=) n_2 (#"selsort_c.jc" 215 29 41# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"selsort_c.jc" 215 12 1467#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 68 14 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a1_0_10_alloc_table a1_0_1) (0)) /\
     (((>=) (offset_max voidP_a1_0_10_alloc_table a1_0_1)
      (Int.(-) (Int32.to_int n_2) (1)))
     /\
     (forall __framac_tmp3 : int.
      ((((<=) (0) __framac_tmp3) /\
       ((<=) __framac_tmp3 (Int.(-) (Int32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"selsort_c.jc" 215 12 1467#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 69 14 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int n_2) (1))) then
     (((<=) (offset_min voidP_a2_0_11_alloc_table a2_0_1) (0)) /\
     (((>=) (offset_max voidP_a2_0_11_alloc_table a2_0_1)
      (Int.(-) (Int32.to_int n_2) (1)))
     /\
     (forall __framac_tmp4 : int.
      ((((<=) (0) __framac_tmp4) /\
       ((<=) __framac_tmp4 (Int.(-) (Int32.to_int n_2) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 70 14 55#
   (array_saved a1_0_1 a2_0_1 (0) (Int.(-) (Int32.to_int n_2) (1))
   intP_intM_a2_0_11 intP_intM_a1_0_10)))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 72 13 103#
     "expl:Ensures clause"
     (forall i : int.
      (forall j_0 : int.
       ((((<=) (0) i) /\
        (((<=) i (Int32.to_int n_2)) /\
        (((<=) (0) j_0) /\ ((<=) j_0 (Int32.to_int n_2))))) ->
        (count_saved a1_0_1 a2_0_1 i j_0 intP_intM_a2_0_11 intP_intM_a1_0_10))))))
     } diverges  ->
   'Init:
   try
    begin
    (let i_0 = ref (Unsafe_int32.any_  () ) in
    (let j = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_0 :=
      (#"selsort_c.jc" 252 20 32# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'LoopEntry:
      begin
      'LoopEntry:
      'Loop_1:
      loop
      invariant
        { ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 23 34#
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 23 34#
           ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 23 29#
            (Int32.(<=) (#"selsort_c.jc" 256 38 50# "expl:Integer cast"
            (Int32.of_int (0))) !i_0))
           /\
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 78 28 34#
           (Int32.(<=) !i_0 n_2)))))
          &&
          (#"/home/debian/mfsp/examples/auto-av/selsort.c" 79 23 112#
          (forall k_5 : int.
           (forall j_2 : int.
            ((((<=) (0) k_5) /\
             (((<) k_5 (Int32.to_int !i_0)) /\
             (((<=) (0) j_2) /\ ((<=) j_2 (Int32.to_int n_2))))) ->
             (count_saved a1_0_1 a2_0_1 k_5 j_2 intP_intM_a2_0_11
             intP_intM_a1_0_10)))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         'LoopCurrent:
         'LoopCurrent:
         try
          begin
          (j :=
           (#"selsort_c.jc" 269 26 38# "expl:Integer cast"
           (Unsafe_int32.of_int (0))));
           'LoopEntry:
           begin
           'LoopEntry:
           'Loop_2:
           loop
           invariant
             { ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 27 38#
                (#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 27 38#
                ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 27 33#
                 (Int32.(<=) (#"selsort_c.jc" 273 44 56# "expl:Integer cast"
                 (Int32.of_int (0))) !j))
                /\
                (#"/home/debian/mfsp/examples/auto-av/selsort.c" 86 32 38#
                (Int32.(<=) !j n_2)))))
               &&
               (#"/home/debian/mfsp/examples/auto-av/selsort.c" 87 27 98#
               (forall k_4 : int.
                ((((<=) (0) k_4) /\ ((<) k_4 (Int32.to_int !j))) ->
                 (count_saved a1_0_1 a2_0_1 (Int32.to_int !i_0) k_4
                 intP_intM_a2_0_11 intP_intM_a1_0_10))))) } 
            begin
            any unit requires { true } ensures { true } ;
             try
              begin
              'LoopCurrent:
              'LoopCurrent:
              begin
              (let _jessie_24 = a1_0_1 in
              (let _jessie_23 = a2_0_1 in
              (let _jessie_22 = !i_0 in
              (let _jessie_21 = !j in
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 92 12 43#
              "expl:Precondition for count_frame_proof"
              (Function_count_frame_proof.count_frame_proof  _jessie_24
               _jessie_23 _jessie_22 _jessie_21 voidP_a2_0_11_alloc_table
               voidP_a1_0_10_alloc_table intP_intM_a2_0_11 intP_intM_a1_0_10
               ))))));
               (if
               (#"/home/debian/mfsp/examples/auto-av/selsort.c" 94 16 22#
               (Unsafe_int32.(=)  !j n_2 ))
               then (raise (Goto_while_1_break_exc ()))
               else
                (j :=
                 (Unsafe_int32.(+)  !j
                  (#"selsort_c.jc" 287 68 80# "expl:Integer cast"
                  (Unsafe_int32.of_int (1))) ))) end;
               (raise (Loop_continue_exc ())) end with Loop_continue_exc
              _jessie_4 -> () end end end;
            (raise (Goto_while_1_break_exc ())) end end with
          Goto_while_1_break_exc _jessie_1 ->
          'While_1_break:
          'While_1_break:
          begin
          ();
           (if
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 102 12 18#
           (Unsafe_int32.(=)  !i_0 n_2 ))
           then (raise (Goto_while_0_break_exc ()))
           else
            (i_0 :=
             (Unsafe_int32.(+)  !i_0
              (#"selsort_c.jc" 294 64 76# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) ))) end end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc _jessie_6
         -> () end end end; (raise (Goto_while_0_break_exc ())) end end with
     Goto_while_0_break_exc _jessie_2 ->
     'While_0_break: 'While_0_break: begin (); (raise Return) end end));
     (raise Return) end with Return -> () end
  
end

theory Struct_voidP

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import core.Tag_table 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Alloc 
  
  use why3.Bool.Bool 
  
  use import core.Voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (n : int)
  (voidP_tag_table : (tag_table voidP))
  = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate strict_left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_intP

  use import core.Voidp_tag_id 
  
  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import core.Tag_table 
  
  use import core.Tag_id 
  
  use import core.Tag 
  
  use import Struct_voidP 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Alloc_table 
  
  use import core.Alloc 
  
  use why3.Bool.Bool 
  
  function intP_tag  : (tag_id voidP)
  
  axiom IntP_parenttag_voidP  :
  (parenttag intP_tag voidP_tag)
  
  axiom IntP_is_final  :
  (forall voidP_tag_table : (tag_table voidP).
   (forall p : (pointer voidP).
    ((instanceof voidP_tag_table p intP_tag) ->
     ((=) (typeof voidP_tag_table p) intP_tag))))
  
  predicate frame_tag_struct_intP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_intP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_intP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_intP (p : (pointer voidP)) (n : int)
  (voidP_tag_table : (tag_table voidP))
  = (fresh_tag_struct_voidP p n voidP_tag_table)
  
  predicate fresh_alloc_struct_intP (p : (pointer voidP)) (n : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p n voidP_alloc_table)
  
  predicate container_of_singleton_struct_intP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_intP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_intP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) intP_tag)
  
  predicate typeof_struct_intP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) intP_tag))))
  
  predicate instanceof_singleton_struct_intP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p intP_tag)
  
  predicate instanceof_struct_intP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p intP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) intP_tag))))
  
  predicate right_valid_struct_intP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_intP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate strict_left_valid_struct_intP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (strict_left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_intP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_intP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
  axiom IntP_int  : ((=) (int_of_tag intP_tag) (4))
  
end

module Function_copy_array_safe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val copy_array
  (a1_6 : (pointer voidP)) 
   (a2_6 : (pointer voidP)) 
    (n_1_0 : Int32.t) 
     (intP_intM_a2_13 : ref (memory voidP Int32.t)) 
      (voidP_a2_13_alloc_table : (alloc_table voidP)) 
       (voidP_a1_12_alloc_table : (alloc_table voidP)) 
        (voidP_a2_13_tag_table : (tag_table voidP)) 
         (voidP_a1_12_tag_table : (tag_table voidP)) 
          (intP_intM_a1_12 : (memory voidP Int32.t)) : unit
           requires {
             ("expl:Internal"
             (#"selsort_c.jc" 304 12 1338# "expl:Requires clause"
             ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 113 14 20#
              "expl:Requires clause"
              (Int32.(>=) n_1_0 (#"selsort_c.jc" 304 29 41#
              "expl:Integer cast" (Int32.of_int (0)))))
             /\
             (#"selsort_c.jc" 304 12 1338# "expl:Requires clause"
             ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 114 14 39#
              "expl:Requires clause"
              (if ((<=) (0) (Int.(-) (Int32.to_int n_1_0) (1))) then
               (((<=) (offset_min voidP_a1_12_alloc_table a1_6) (0)) /\
               (((>=) (offset_max voidP_a1_12_alloc_table a1_6)
                (Int.(-) (Int32.to_int n_1_0) (1)))
               /\
               (forall __framac_tmp5 : int.
                ((((<=) (0) __framac_tmp5) /\
                 ((<=) __framac_tmp5 (Int.(-) (Int32.to_int n_1_0) (1)))) ->
                 ((=) true true))))) else ((=) true true)))
             /\
             (#"/home/debian/mfsp/examples/auto-av/selsort.c" 115 14 39#
             "expl:Requires clause"
             (if ((<=) (0) (Int.(-) (Int32.to_int n_1_0) (1))) then
              (((<=) (offset_min voidP_a2_13_alloc_table a2_6) (0)) /\
              (((>=) (offset_max voidP_a2_13_alloc_table a2_6)
               (Int.(-) (Int32.to_int n_1_0) (1)))
              /\
              (forall __framac_tmp6 : int.
               ((((<=) (0) __framac_tmp6) /\
                ((<=) __framac_tmp6 (Int.(-) (Int32.to_int n_1_0) (1)))) ->
                ((=) true true))))) else ((=) true true)))))))) }
           reads { intP_intM_a2_13 } writes { intP_intM_a2_13 }
           ensures {
             ((#"selsort_c.jc" 327 10 49# "expl:Assigns clause"
              (not_assigns voidP_a2_13_alloc_table voidP_a2_13_alloc_table
              (old !intP_intM_a2_13) !intP_intM_a2_13
              (pset_range (pset_singleton a2_6) (0)
              (Int.(-) (Int32.to_int n_1_0) (1)))))
             /\
             (#"/home/debian/mfsp/examples/auto-av/selsort.c" 118 13 53#
             "expl:Ensures clause"
             (array_saved a1_6 a2_6 (0) (Int.(-) (Int32.to_int n_1_0) (1))
             !intP_intM_a2_13 intP_intM_a1_12))) }
  
end

module Function_copy_array_safety
#"/home/debian/mfsp/examples/auto-av/selsort.c" 120 7 42#
"expl:copy_array, safety"

  use import core.Zwf 
  
  use import core.Voidp 
  
  use import core.Upd_offset_safe 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import core.Shift_safe 
  
  use Safe_int32 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_copy_array_safe 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_offset_safe 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let copy_array #"/home/debian/mfsp/examples/auto-av/selsort.c" 120 7 42#
  "expl:Function copy_array, safety" =
  fun
   (a1_6 : (pointer voidP)) (a2_6 : (pointer voidP)) (n_1_0 : Int32.t)
   (intP_intM_a2_13 : ref (memory voidP Int32.t)) (voidP_a1_12_alloc_table :
   (alloc_table voidP)) (voidP_a2_13_alloc_table : (alloc_table voidP))
   (voidP_a2_13_tag_table : (tag_table voidP)) (voidP_a1_12_tag_table :
   (tag_table voidP)) (intP_intM_a1_12 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a2_13_alloc_table a2_6) ->
     (((=) (typeof voidP_a2_13_tag_table a2_6) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a2_13_alloc_table a2_6) i) /\
       ((<) i (offset_max voidP_a2_13_alloc_table a2_6))) ->
       ((=) (typeof voidP_a2_13_tag_table (shift a2_6 i)) intP_tag)))))
   /\
   (((allocated voidP_a1_12_alloc_table a1_6) ->
     (((=) (typeof voidP_a1_12_tag_table a1_6) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a1_12_alloc_table a1_6) i) /\
       ((<) i (offset_max voidP_a1_12_alloc_table a1_6))) ->
       ((=) (typeof voidP_a1_12_tag_table (shift a1_6 i)) intP_tag)))))
   /\
   (#"selsort_c.jc" 304 12 1338#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 113 14 20#
    (Int32.(>=) n_1_0 (#"selsort_c.jc" 304 29 41# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"selsort_c.jc" 304 12 1338#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 114 14 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int n_1_0) (1))) then
     (((<=) (offset_min voidP_a1_12_alloc_table a1_6) (0)) /\
     (((>=) (offset_max voidP_a1_12_alloc_table a1_6)
      (Int.(-) (Int32.to_int n_1_0) (1)))
     /\
     (forall __framac_tmp5 : int.
      ((((<=) (0) __framac_tmp5) /\
       ((<=) __framac_tmp5 (Int.(-) (Int32.to_int n_1_0) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 115 14 39#
   (if ((<=) (0) (Int.(-) (Int32.to_int n_1_0) (1))) then
    (((<=) (offset_min voidP_a2_13_alloc_table a2_6) (0)) /\
    (((>=) (offset_max voidP_a2_13_alloc_table a2_6)
     (Int.(-) (Int32.to_int n_1_0) (1)))
    /\
    (forall __framac_tmp6 : int.
     ((((<=) (0) __framac_tmp6) /\
      ((<=) __framac_tmp6 (Int.(-) (Int32.to_int n_1_0) (1)))) ->
      ((=) true true))))) else ((=) true true))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (if
    (#"/home/debian/mfsp/examples/auto-av/selsort.c" 122 8 14#
    (Safe_int32.(=)  n_1_0
     (#"selsort_c.jc" 331 27 39# "expl:Integer cast" (Safe_int32.of_int (0)))
     )) then ()
    else
     begin
     (let _jessie_46 =
     (let _jessie_45 =
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 125 20 29#
     "expl:Pointer dereference"
     (acc_offset_typesafe  voidP_a1_12_alloc_table intP_intM_a1_12 a1_6
      (Safe_int32.to_int 
       (Safe_int32.(-)  n_1_0
        (#"selsort_c.jc" 336 55 67# "expl:Integer cast"
        (Safe_int32.of_int (1))) ) ) )) in
     begin
     (assert {
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 125 8 29#
     "expl:Pointer index bounds" true) }); _jessie_45 end) in
     (let _jessie_47 = a2_6 in
     (let _jessie_48 =
     (Safe_int32.to_int 
      (Safe_int32.(-)  n_1_0
       (#"selsort_c.jc" 334 60 72# "expl:Integer cast"
       (Safe_int32.of_int (1))) ) ) in
     (let _jessie_49 = (shift_typesafe  _jessie_47 _jessie_48 ) in
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 125 8 29#
     "expl:Pointer dereference"
     (upd_offset_typesafe  voidP_a2_13_alloc_table intP_intM_a2_13 _jessie_47
      _jessie_48 _jessie_46 ))))));
      (let _jessie_52 = a1_6 in
      (let _jessie_51 = a2_6 in
      (let _jessie_50 =
      (Safe_int32.(-)  n_1_0
       (#"selsort_c.jc" 338 55 67# "expl:Integer cast"
       (Safe_int32.of_int (1))) ) in
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 126 8 33#
      "expl:Variant decreases"
      begin
      (check {
      (zwf_zero (#"/home/debian/mfsp/examples/auto-av/selsort.c" 116 15 16#
      (Int32.to_int
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 116 15 16#
      _jessie_50)))
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 116 15 16#
      (Int32.to_int
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 116 15 16# n_1_0))))
      });
       (#"/home/debian/mfsp/examples/auto-av/selsort.c" 126 8 33#
       "expl:Precondition for copy_array"
       (Function_copy_array_safe.copy_array  _jessie_52 _jessie_51 _jessie_50
        intP_intM_a2_13 voidP_a2_13_alloc_table voidP_a1_12_alloc_table
        voidP_a2_13_tag_table voidP_a1_12_tag_table intP_intM_a1_12 )) end))))
     end); (raise Return); (raise Return) end with Return -> () end
  
end

module Function_copy_array

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use int.Int 
  
  use import core.Assigns 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val copy_array
  (a1_6 : (pointer voidP)) 
   (a2_6 : (pointer voidP)) 
    (n_1_0 : Int32.t) 
     (intP_intM_a2_13 : ref (memory voidP Int32.t)) 
      (voidP_a2_13_alloc_table : (alloc_table voidP)) 
       (voidP_a1_12_alloc_table : (alloc_table voidP)) 
        (voidP_a2_13_tag_table : (tag_table voidP)) 
         (voidP_a1_12_tag_table : (tag_table voidP)) 
          (intP_intM_a1_12 : (memory voidP Int32.t)) : unit
           requires { true } reads { intP_intM_a2_13 } writes {
           intP_intM_a2_13 }
           ensures {
             ((#"selsort_c.jc" 327 10 49# "expl:Assigns clause"
              (not_assigns voidP_a2_13_alloc_table voidP_a2_13_alloc_table
              (old !intP_intM_a2_13) !intP_intM_a2_13
              (pset_range (pset_singleton a2_6) (0)
              (Int.(-) (Int32.to_int n_1_0) (1)))))
             /\
             (#"/home/debian/mfsp/examples/auto-av/selsort.c" 118 13 53#
             "expl:Ensures clause"
             (array_saved a1_6 a2_6 (0) (Int.(-) (Int32.to_int n_1_0) (1))
             !intP_intM_a2_13 intP_intM_a1_12))) }
  
end

module Function_copy_array_behaviors
#"/home/debian/mfsp/examples/auto-av/selsort.c" 120 7 42#
"expl:copy_array, behaviors"

  use import core.Voidp 
  
  use import core.Upd_unsafe 
  
  use Unsafe_int32 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import core.Shift_unsafe 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pset_range 
  
  use import core.Pset 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_copy_array 
  
  use import core.Assigns 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_unsafe 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let copy_array_ensures_default
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 120 7 42#
  "expl:Function copy_array, default behavior" =
  fun
   (a1_6 : (pointer voidP)) (a2_6 : (pointer voidP)) (n_1_0 : Int32.t)
   (intP_intM_a2_13 : ref (memory voidP Int32.t)) (voidP_a1_12_alloc_table :
   (alloc_table voidP)) (voidP_a2_13_alloc_table : (alloc_table voidP))
   (voidP_a2_13_tag_table : (tag_table voidP)) (voidP_a1_12_tag_table :
   (tag_table voidP)) (intP_intM_a1_12 : (memory voidP Int32.t)) 
   requires {
   (((allocated voidP_a2_13_alloc_table a2_6) ->
     (((=) (typeof voidP_a2_13_tag_table a2_6) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a2_13_alloc_table a2_6) i) /\
       ((<) i (offset_max voidP_a2_13_alloc_table a2_6))) ->
       ((=) (typeof voidP_a2_13_tag_table (shift a2_6 i)) intP_tag)))))
   /\
   (((allocated voidP_a1_12_alloc_table a1_6) ->
     (((=) (typeof voidP_a1_12_tag_table a1_6) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a1_12_alloc_table a1_6) i) /\
       ((<) i (offset_max voidP_a1_12_alloc_table a1_6))) ->
       ((=) (typeof voidP_a1_12_tag_table (shift a1_6 i)) intP_tag)))))
   /\
   (#"selsort_c.jc" 304 12 1338#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 113 14 20#
    (Int32.(>=) n_1_0 (#"selsort_c.jc" 304 29 41# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"selsort_c.jc" 304 12 1338#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 114 14 39#
    (if ((<=) (0) (Int.(-) (Int32.to_int n_1_0) (1))) then
     (((<=) (offset_min voidP_a1_12_alloc_table a1_6) (0)) /\
     (((>=) (offset_max voidP_a1_12_alloc_table a1_6)
      (Int.(-) (Int32.to_int n_1_0) (1)))
     /\
     (forall __framac_tmp5 : int.
      ((((<=) (0) __framac_tmp5) /\
       ((<=) __framac_tmp5 (Int.(-) (Int32.to_int n_1_0) (1)))) ->
       ((=) true true))))) else ((=) true true)))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 115 14 39#
   (if ((<=) (0) (Int.(-) (Int32.to_int n_1_0) (1))) then
    (((<=) (offset_min voidP_a2_13_alloc_table a2_6) (0)) /\
    (((>=) (offset_max voidP_a2_13_alloc_table a2_6)
     (Int.(-) (Int32.to_int n_1_0) (1)))
    /\
    (forall __framac_tmp6 : int.
     ((((<=) (0) __framac_tmp6) /\
      ((<=) __framac_tmp6 (Int.(-) (Int32.to_int n_1_0) (1)))) ->
      ((=) true true))))) else ((=) true true))))))))) }
   ensures {
     ("expl:Postcondition"
     ((#"selsort_c.jc" 327 10 49# "expl:Assigns clause"
      (not_assigns voidP_a2_13_alloc_table voidP_a2_13_alloc_table (old
      !intP_intM_a2_13) !intP_intM_a2_13
      (pset_range (pset_singleton a2_6) (0)
      (Int.(-) (Int32.to_int n_1_0) (1)))))
     /\
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 118 13 53#
     "expl:Ensures clause"
     (array_saved a1_6 a2_6 (0) (Int.(-) (Int32.to_int n_1_0) (1))
     !intP_intM_a2_13 intP_intM_a1_12)))) }  ->
   'Init:
   try
    begin
    (if
    (#"/home/debian/mfsp/examples/auto-av/selsort.c" 122 8 14#
    (Unsafe_int32.(=)  n_1_0
     (#"selsort_c.jc" 331 27 39# "expl:Integer cast"
     (Unsafe_int32.of_int (0))) )) then ()
    else
     begin
     (let _jessie_38 =
     (acc  intP_intM_a1_12
      (shift_  a1_6
       (Unsafe_int32.to_int 
        (Unsafe_int32.(-)  n_1_0
         (#"selsort_c.jc" 336 55 67# "expl:Integer cast"
         (Unsafe_int32.of_int (1))) ) ) ) ) in
     (let _jessie_39 = a2_6 in
     (let _jessie_40 =
     (Unsafe_int32.to_int 
      (Unsafe_int32.(-)  n_1_0
       (#"selsort_c.jc" 334 60 72# "expl:Integer cast"
       (Unsafe_int32.of_int (1))) ) ) in
     (let _jessie_41 = (shift_  _jessie_39 _jessie_40 ) in
     (upd  intP_intM_a2_13 _jessie_41 _jessie_38 )))));
      (let _jessie_44 = a1_6 in
      (let _jessie_43 = a2_6 in
      (let _jessie_42 =
      (Unsafe_int32.(-)  n_1_0
       (#"selsort_c.jc" 338 55 67# "expl:Integer cast"
       (Unsafe_int32.of_int (1))) ) in
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 126 8 33#
      "expl:Precondition for copy_array"
      (Function_copy_array.copy_array  _jessie_44 _jessie_43 _jessie_42
       intP_intM_a2_13 voidP_a2_13_alloc_table voidP_a1_12_alloc_table
       voidP_a2_13_tag_table voidP_a1_12_tag_table intP_intM_a1_12 ))))) end);
     (raise Return); (raise Return) end with Return -> () end
  
end

theory Logic_minimum

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate minimum (a_7 : (pointer voidP)) (m_9 : int) (n_9 : int) (k_6 :
  int) (intP_intM_a_7_14_at_L : (memory voidP Int32.t))
  =
     (forall i_0_0 : int.
      ((((<=) m_9 i_0_0) /\ ((<) i_0_0 n_9)) ->
       (Int32.(<=) (select intP_intM_a_7_14_at_L (shift a_7 k_6))
       (select intP_intM_a_7_14_at_L (shift a_7 i_0_0)))))
  
  
end

module Struct_intP_unsafe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val free_struct_intP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_intP p (old !voidP_alloc_table) !voidP_alloc_table)
      /\
      (fresh_alloc_struct_intP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_intP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_intP result (Int.(-) n (1)) (old !voidP_tag_table))
       /\
       ((typeof_struct_intP result (0) n !voidP_tag_table) /\
       (container_of_struct_intP result (0) n !voidP_tag_table))))))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Function_count_frame2_proof_safe

  use import core.Voidp 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use import Logic_array_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val count_frame2_proof
  (a1_0_1 : (pointer voidP)) 
   (a2_0_1 : (pointer voidP)) 
    (n_2 : Int32.t) 
     (voidP_a2_0_11_alloc_table : (alloc_table voidP)) 
      (voidP_a1_0_10_alloc_table : (alloc_table voidP)) 
       (intP_intM_a2_0_11 : (memory voidP Int32.t)) 
        (intP_intM_a1_0_10 : (memory voidP Int32.t)) : unit
         requires {
           ("expl:Internal"
           (#"selsort_c.jc" 215 12 1467# "expl:Requires clause"
           ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 67 14 20#
            "expl:Requires clause"
            (Int32.(>=) n_2 (#"selsort_c.jc" 215 29 41# "expl:Integer cast"
            (Int32.of_int (0)))))
           /\
           (#"selsort_c.jc" 215 12 1467# "expl:Requires clause"
           ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 68 14 39#
            "expl:Requires clause"
            (if ((<=) (0) (Int.(-) (Int32.to_int n_2) (1))) then
             (((<=) (offset_min voidP_a1_0_10_alloc_table a1_0_1) (0)) /\
             (((>=) (offset_max voidP_a1_0_10_alloc_table a1_0_1)
              (Int.(-) (Int32.to_int n_2) (1)))
             /\
             (forall __framac_tmp3 : int.
              ((((<=) (0) __framac_tmp3) /\
               ((<=) __framac_tmp3 (Int.(-) (Int32.to_int n_2) (1)))) ->
               ((=) true true))))) else ((=) true true)))
           /\
           (#"selsort_c.jc" 215 12 1467# "expl:Requires clause"
           ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 69 14 39#
            "expl:Requires clause"
            (if ((<=) (0) (Int.(-) (Int32.to_int n_2) (1))) then
             (((<=) (offset_min voidP_a2_0_11_alloc_table a2_0_1) (0)) /\
             (((>=) (offset_max voidP_a2_0_11_alloc_table a2_0_1)
              (Int.(-) (Int32.to_int n_2) (1)))
             /\
             (forall __framac_tmp4 : int.
              ((((<=) (0) __framac_tmp4) /\
               ((<=) __framac_tmp4 (Int.(-) (Int32.to_int n_2) (1)))) ->
               ((=) true true))))) else ((=) true true)))
           /\
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 70 14 55#
           "expl:Requires clause"
           (array_saved a1_0_1 a2_0_1 (0) (Int.(-) (Int32.to_int n_2) (1))
           intP_intM_a2_0_11 intP_intM_a1_0_10))))))))) }
         ensures {
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 72 13 103#
           "expl:Ensures clause"
           (forall i : int.
            (forall j_0 : int.
             ((((<=) (0) i) /\
              (((<=) i (Int32.to_int n_2)) /\
              (((<=) (0) j_0) /\ ((<=) j_0 (Int32.to_int n_2))))) ->
              (count_saved a1_0_1 a2_0_1 i j_0 intP_intM_a2_0_11
              intP_intM_a1_0_10))))) }
  
end

module Function_sort_safety
#"/home/debian/mfsp/examples/auto-av/selsort.c" 170 5 24# "expl:sort, safety"

  use import core.Voidp 
  
  use import core.Upd_offset_safe 
  
  use import core.Tag_table_type 
  
  use import Struct_intP_unsafe 
  
  use import Struct_intP 
  
  use import core.Shift_safe 
  
  use Safe_uint64_of_Safe_int32 
  
  use Safe_uint64 
  
  use Safe_int32 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_minimum 
  
  use import Logic_count_sum 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_count_frame_proof_safe 
  
  use Function_count_frame2_proof_safe 
  
  use Function_copy_array_safe 
  
  use import Exceptions 
  
  use import Axiomatic_Ordered 
  
  use import Axiomatic_Count 
  
  use import core.Any_tag_table 
  
  use import core.Any_pointer 
  
  use import core.Any_memory 
  
  use import core.Any_alloc_table 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_offset_safe 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let sort #"/home/debian/mfsp/examples/auto-av/selsort.c" 170 5 24#
  "expl:Function sort, safety" =
  fun
   (a_0 : (pointer voidP)) (n_12 : Int32.t) (intP_intM_a_16 : ref (memory
   voidP Int32.t)) (voidP_a_16_alloc_table : (alloc_table voidP))
   (voidP_a_16_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_a_16_alloc_table a_0) ->
     (((=) (typeof voidP_a_16_tag_table a_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_16_alloc_table a_0) i) /\
       ((<) i (offset_max voidP_a_16_alloc_table a_0))) ->
       ((=) (typeof voidP_a_16_tag_table (shift a_0 i)) intP_tag)))))
   /\
   (#"selsort_c.jc" 427 12 688#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 163 11 17#
    (Int32.(>=) n_12 (#"selsort_c.jc" 427 31 43# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 164 11 33#
   (if ((<=) (0) (Int.(-) (Int32.to_int n_12) (1))) then
    (((<=) (offset_min voidP_a_16_alloc_table a_0) (0)) /\
    (((>=) (offset_max voidP_a_16_alloc_table a_0)
     (Int.(-) (Int32.to_int n_12) (1)))
    /\
    (forall __framac_tmp7 : int.
     ((((<=) (0) __framac_tmp7) /\
      ((<=) __framac_tmp7 (Int.(-) (Int32.to_int n_12) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let intP_intM_aLiter_30 = ref (any_memory  () : (memory voidP Int32.t))
   in
   (let voidP_aLiter_30_tag_table = ref
   (any_tag_table  () : (tag_table voidP)) in
   (let voidP_aLiter_30_alloc_table = ref
   (any_alloc_table  () : (alloc_table voidP)) in
   try
    begin
    (let i_0_1 = ref (Safe_int32.any_  () ) in
    (let min_pos = ref (Safe_int32.any_  () ) in
    (let j_0_0 = ref (Safe_int32.any_  () ) in
    (let aLiter = ref (any_pointer  () : (pointer voidP)) in
    (let tmp_0 = (any_pointer  () : (pointer voidP)) in
    (let tmp_1 = ref (Safe_int32.any_  () ) in
    try
     begin
     (i_0_1 :=
      (let _jessie_124 =
      (#"selsort_c.jc" 457 22 34# "expl:Integer cast"
      (Safe_int32.of_int (0))) in
      begin
      (assert {
      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 179 13 14#
      "expl:Pointer index bounds" true) }); _jessie_124 end));
      'LoopEntry:
      begin
      'LoopEntry:
      'Loop_7:
      loop
      invariant { (#"selsort_c.jc" 459 6 10969# true) }
        variant { (#"/home/debian/mfsp/examples/auto-av/selsort.c" 177 21 26#
          (Int.(-) (Int32.to_int n_12) (Int32.to_int !i_0_1))) }
       begin
       any unit
       requires { true } reads { a_0, intP_intM_a_16, n_12 }
       ensures {
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 23 34#
          (#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 23 34#
          ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 23 29#
           (Int32.(<=) (#"selsort_c.jc" 471 38 50# "expl:Integer cast"
           (Int32.of_int (0))) !i_0_1))
          /\
          (#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 28 34#
          (Int32.(<=) !i_0_1 n_12)))))
         /\
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 175 23 57#
          (count_saved a_0 a_0 (0) (Int32.to_int n_12) !intP_intM_a_16 (at
          !intP_intM_a_16 'Init)))
         /\
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 174 23 56#
          ((Int32.(>) !i_0_1 (#"selsort_c.jc" 463 35 47# "expl:Integer cast"
           (Int32.of_int (0)))) ->
           (minimum a_0 (Int32.to_int !i_0_1) (Int32.to_int n_12)
           (Int.(-) (Int32.to_int !i_0_1) (1)) !intP_intM_a_16)))
         /\
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 173 23 43#
         (ordered a_0 (0) (Int.(-) (Int32.to_int !i_0_1) (1))
         !intP_intM_a_16))))) } ;
        try
         begin
         'LoopCurrent:
         begin
         'LoopCurrent:
         (if
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 179 20 25#
         (Safe_int32.(<)  !i_0_1 n_12 )) then ()
         else (raise (Goto_while_0_break_0_exc ())));
          begin
          (min_pos :=
           (let _jessie_89 = !i_0_1 in
           begin
           (assert {
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 181 12 19#
           "expl:Pointer index bounds" true) }); _jessie_89 end));
           try
            begin
            (j_0_0 :=
             (let _jessie_92 =
             (Safe_int32.(+)  !i_0_1
              (#"selsort_c.jc" 481 60 72# "expl:Integer cast"
              (Safe_int32.of_int (1))) ) in
             begin
             (assert {
             (#"/home/debian/mfsp/examples/auto-av/selsort.c" 188 17 18#
             "expl:Pointer index bounds" true) }); _jessie_92 end));
             'LoopEntry:
             begin
             'LoopEntry:
             'Loop_8:
             loop
             invariant { (#"selsort_c.jc" 483 18 1464# true) }
               variant {
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 186 25 30#
                 (Int.(-) (Int32.to_int n_12) (Int32.to_int !j_0_0))) }
              begin
              any unit
              requires { true } reads { a_0, intP_intM_a_16, n_12 }
              ensures {
                ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 27 42#
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 27 42#
                 ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 27 37#
                  ((<=) (Int.(+) (Int32.to_int !i_0_1) (1))
                  (Int32.to_int !j_0_0)))
                 /\
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 36 42#
                 (Int32.(<=) !j_0_0 n_12)))))
                /\
                ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 27 43#
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 27 43#
                 ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 27 39#
                  (Int32.(<=) !i_0_1 !min_pos))
                 /\
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 32 43#
                 (Int32.(<) !min_pos n_12)))))
                /\
                (#"/home/debian/mfsp/examples/auto-av/selsort.c" 183 27 52#
                (minimum a_0 (Int32.to_int !i_0_1) (Int32.to_int !j_0_0)
                (Int32.to_int !min_pos) !intP_intM_a_16)))) } ;
               try
                begin
                'LoopCurrent:
                begin
                'LoopCurrent:
                (if
                (#"/home/debian/mfsp/examples/auto-av/selsort.c" 188 28 33#
                (Safe_int32.(<)  !j_0_0 n_12 )) then ()
                else (raise (Goto_while_1_break_0_exc ())));
                 (if
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 189 16 33#
                 (Safe_int32.(<) 
                  (#"/home/debian/mfsp/examples/auto-av/selsort.c" 189 16 20#
                  "expl:Pointer dereference"
                  (acc_offset_typesafe  voidP_a_16_alloc_table
                   !intP_intM_a_16 a_0 (Safe_int32.to_int  !j_0_0 ) ))
                  (#"/home/debian/mfsp/examples/auto-av/selsort.c" 189 23 33#
                  "expl:Pointer dereference"
                  (acc_offset_typesafe  voidP_a_16_alloc_table
                   !intP_intM_a_16 a_0 (Safe_int32.to_int  !min_pos ) )) ))
                 then
                  (min_pos :=
                   (let _jessie_90 = !j_0_0 in
                   begin
                   (assert {
                   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 190 16 27#
                   "expl:Pointer index bounds" true) }); _jessie_90 end))
                 else ());
                 (j_0_0 :=
                  (let _jessie_91 =
                  (Safe_int32.(+)  !j_0_0
                   (#"selsort_c.jc" 506 61 73# "expl:Integer cast"
                   (Safe_int32.of_int (1))) ) in
                  begin
                  (assert {
                  (#"/home/debian/mfsp/examples/auto-av/selsort.c" 188 35 38#
                  "expl:Pointer index bounds" true) }); _jessie_91 end)) end;
                 (raise (Loop_continue_exc ())) end with Loop_continue_exc
                _jessie_10 -> () end end end;
              (raise (Goto_while_1_break_0_exc ())) end end with
            Goto_while_1_break_0_exc _jessie_7 ->
            'While_1_break_0: 'While_1_break_0: () end;
           (if
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 193 12 24#
           (Safe_int32.(<>)  !min_pos !i_0_1 ))
           then
            begin
            begin
            any unit
            requires { true } reads { a_0, intP_intM_a_16, n_12 }
            ensures {
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 194 23 106#
              (forall p_8 : int.
               ((=)
               (count_sum a_0 (Int32.to_int !i_0_1) (Int32.to_int !min_pos)
               (Int32.to_int n_12) p_8 !intP_intM_a_16)
               (count_sum a_0 (Int32.to_int !i_0_1) (Int32.to_int !min_pos)
               (Int32.to_int n_12) p_8 !intP_intM_a_16)))) } ; () end;
             begin
             (aLiter :=
              (let _jessie_93 =
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 195 38 64#
              "expl:Allocation size"
              (allocate_struct_intP_requires 
               (Safe_uint64.to_int 
                (#"/home/debian/mfsp/examples/auto-av/selsort.c" 195 45 46#
                "expl:Integer cast" (Safe_uint64_of_Safe_int32.cast  n_12 ))
                ) voidP_aLiter_30_alloc_table voidP_aLiter_30_tag_table )) in
              begin
              (assert {
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 195 38 64#
              "expl:Pointer index bounds" true) }); _jessie_93 end));
              begin
              (let _jessie_96 = a_0 in
              (let _jessie_95 = !aLiter in
              (let _jessie_94 = n_12 in
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 195 66 90#
              "expl:Precondition for copy_array"
              (Function_copy_array_safe.copy_array  _jessie_96 _jessie_95
               _jessie_94 intP_intM_aLiter_30 !voidP_aLiter_30_alloc_table
               voidP_a_16_alloc_table !voidP_aLiter_30_tag_table
               voidP_a_16_tag_table !intP_intM_a_16 )))));
               begin
               any unit
               requires { true } reads { intP_intM_aLiter_30, n_12 }
               ensures {
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 196 23 116#
                 (forall p_9 : int.
                  ((=)
                  (count_sum !aLiter (Int32.to_int !i_0_1)
                  (Int32.to_int !min_pos) (Int32.to_int n_12) p_9
                  !intP_intM_aLiter_30)
                  (count_sum !aLiter (Int32.to_int !i_0_1)
                  (Int32.to_int !min_pos) (Int32.to_int n_12) p_9
                  !intP_intM_aLiter_30)))) } ; () end;
               begin
               (let _jessie_99 = a_0 in
               (let _jessie_98 = !aLiter in
               (let _jessie_97 = n_12 in
               (#"/home/debian/mfsp/examples/auto-av/selsort.c" 197 24 56#
               "expl:Precondition for count_frame2_proof"
               (Function_count_frame2_proof_safe.count_frame2_proof 
                _jessie_99 _jessie_98 _jessie_97 !voidP_aLiter_30_alloc_table
                voidP_a_16_alloc_table !intP_intM_aLiter_30 !intP_intM_a_16 )))));
                begin
                (tmp_1 :=
                 (let _jessie_100 =
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 198 22 32#
                 "expl:Pointer dereference"
                 (acc_offset_typesafe  voidP_a_16_alloc_table !intP_intM_a_16
                  a_0 (Safe_int32.to_int  !min_pos ) )) in
                 begin
                 (assert {
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 198 16 19#
                 "expl:Pointer index bounds" true) }); _jessie_100 end));
                 begin
                 (let _jessie_102 =
                 (let _jessie_101 =
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 199 25 29#
                 "expl:Pointer dereference"
                 (acc_offset_typesafe  voidP_a_16_alloc_table !intP_intM_a_16
                  a_0 (Safe_int32.to_int  !i_0_1 ) )) in
                 begin
                 (assert {
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 199 12 29#
                 "expl:Pointer index bounds" true) }); _jessie_101 end) in
                 (let _jessie_103 = a_0 in
                 (let _jessie_104 = (Safe_int32.to_int  !min_pos ) in
                 (let _jessie_105 =
                 (shift_typesafe  _jessie_103 _jessie_104 ) in
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 199 12 29#
                 "expl:Pointer dereference"
                 (upd_offset_typesafe  voidP_a_16_alloc_table intP_intM_a_16
                  _jessie_103 _jessie_104 _jessie_102 ))))));
                  begin
                  (let _jessie_107 =
                  (let _jessie_106 = !tmp_1 in
                  begin
                  (assert {
                  (#"/home/debian/mfsp/examples/auto-av/selsort.c" 200 12 22#
                  "expl:Pointer index bounds" true) }); _jessie_106 end) in
                  (let _jessie_108 = a_0 in
                  (let _jessie_109 = (Safe_int32.to_int  !i_0_1 ) in
                  (let _jessie_110 =
                  (shift_typesafe  _jessie_108 _jessie_109 ) in
                  (#"/home/debian/mfsp/examples/auto-av/selsort.c" 200 12 22#
                  "expl:Pointer dereference"
                  (upd_offset_typesafe  voidP_a_16_alloc_table intP_intM_a_16
                   _jessie_108 _jessie_109 _jessie_107 ))))));
                   begin
                   (let _jessie_114 = a_0 in
                   (let _jessie_113 = !aLiter in
                   (let _jessie_112 =
                   (#"selsort_c.jc" 553 57 69# "expl:Integer cast"
                   (Safe_int32.of_int (0))) in
                   (let _jessie_111 = !i_0_1 in
                   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 201 22 56#
                   "expl:Precondition for count_frame_proof"
                   (Function_count_frame_proof_safe.count_frame_proof 
                    _jessie_114 _jessie_113 _jessie_112 _jessie_111
                    !voidP_aLiter_30_alloc_table voidP_a_16_alloc_table
                    !intP_intM_aLiter_30 !intP_intM_a_16 ))))));
                    begin
                    (let _jessie_118 = a_0 in
                    (let _jessie_117 = !aLiter in
                    (let _jessie_116 =
                    (Safe_int32.(+)  !i_0_1
                     (#"selsort_c.jc" 556 68 80# "expl:Integer cast"
                     (Safe_int32.of_int (1))) ) in
                    (let _jessie_115 = !min_pos in
                    (#"/home/debian/mfsp/examples/auto-av/selsort.c" 202 22 66#
                    "expl:Precondition for count_frame_proof"
                    (Function_count_frame_proof_safe.count_frame_proof 
                     _jessie_118 _jessie_117 _jessie_116 _jessie_115
                     !voidP_aLiter_30_alloc_table voidP_a_16_alloc_table
                     !intP_intM_aLiter_30 !intP_intM_a_16 ))))));
                     begin
                     (let _jessie_122 = a_0 in
                     (let _jessie_121 = !aLiter in
                     (let _jessie_120 =
                     (Safe_int32.(+)  !min_pos
                      (#"selsort_c.jc" 560 68 80# "expl:Integer cast"
                      (Safe_int32.of_int (1))) ) in
                     (let _jessie_119 = n_12 in
                     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 203 22 66#
                     "expl:Precondition for count_frame_proof"
                     (Function_count_frame_proof_safe.count_frame_proof 
                      _jessie_122 _jessie_121 _jessie_120 _jessie_119
                      !voidP_aLiter_30_alloc_table voidP_a_16_alloc_table
                      !intP_intM_aLiter_30 !intP_intM_a_16 ))))));
                      begin
                      any unit
                      requires { true } reads { a_0, intP_intM_aLiter_30,
                      intP_intM_a_16 }
                      ensures {
                        (#"/home/debian/mfsp/examples/auto-av/selsort.c" 204 23 172#
                        (forall p_10 : int.
                         (((=)
                          (count a_0 (Int32.to_int !min_pos)
                          (Int.(+) (Int32.to_int !min_pos) (1)) p_10
                          !intP_intM_a_16)
                          (count !aLiter (Int32.to_int !i_0_1)
                          (Int.(+) (Int32.to_int !i_0_1) (1)) p_10
                          !intP_intM_aLiter_30))
                         /\
                         ((=)
                         (count !aLiter (Int32.to_int !min_pos)
                         (Int.(+) (Int32.to_int !min_pos) (1)) p_10
                         !intP_intM_aLiter_30)
                         (count a_0 (Int32.to_int !i_0_1)
                         (Int.(+) (Int32.to_int !i_0_1) (1)) p_10
                         !intP_intM_a_16))))) } ; () end;
                      begin
                      any unit
                      requires { true } reads { a_0, intP_intM_aLiter_30,
                      intP_intM_a_16, n_12 }
                      ensures {
                        (#"/home/debian/mfsp/examples/auto-av/selsort.c" 205 23 158#
                        (forall p_11 : int.
                         (((=)
                          (count a_0 (0) (Int32.to_int n_12) p_11
                          !intP_intM_a_16)
                          (count_sum a_0 (Int32.to_int !i_0_1)
                          (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                          !intP_intM_a_16))
                         /\
                         (((=)
                          (count_sum a_0 (Int32.to_int !i_0_1)
                          (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                          !intP_intM_a_16)
                          (count_sum !aLiter (Int32.to_int !i_0_1)
                          (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                          !intP_intM_aLiter_30))
                         /\
                         ((=)
                         (count_sum !aLiter (Int32.to_int !i_0_1)
                         (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                         !intP_intM_aLiter_30)
                         (count !aLiter (0) (Int32.to_int n_12) p_11
                         !intP_intM_aLiter_30)))))) } ; () end end end end
                  end end end end end end end else ()) end;
          (i_0_1 :=
           (let _jessie_123 =
           (Safe_int32.(+)  !i_0_1
            (#"selsort_c.jc" 627 57 69# "expl:Integer cast"
            (Safe_int32.of_int (1))) ) in
           begin
           (assert {
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 179 27 30#
           "expl:Pointer index bounds" true) }); _jessie_123 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_12 -> () end end end; (raise (Goto_while_0_break_0_exc ()))
      end end with Goto_while_0_break_0_exc _jessie_8 ->
     'While_0_break_0: 'While_0_break_0: begin (); (raise Return) end end))))));
     (raise Return) end with Return -> () end)))
  
end

module Struct_intP_safe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_intP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_intP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_intP p (old !voidP_alloc_table) !voidP_alloc_table)
      /\
      (fresh_alloc_struct_intP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_intP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_intP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_intP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_intP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_intP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_intP result (Int.(-) n (1)) (old !voidP_tag_table))
       /\
       ((typeof_struct_intP result (0) n !voidP_tag_table) /\
       (container_of_struct_intP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_intP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_intP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_intP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_intP result (old !voidP_tag_table) !voidP_tag_table)
      /\
      ((fresh_alloc_struct_intP result (0) (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_intP result (0) (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_intP result !voidP_tag_table) /\
      (container_of_singleton_struct_intP result !voidP_tag_table))))))) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Function_count_frame2_proof

  use import core.Voidp 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val count_frame2_proof
  (a1_0_1 : (pointer voidP)) 
   (a2_0_1 : (pointer voidP)) 
    (n_2 : Int32.t) 
     (voidP_a2_0_11_alloc_table : (alloc_table voidP)) 
      (voidP_a1_0_10_alloc_table : (alloc_table voidP)) 
       (intP_intM_a2_0_11 : (memory voidP Int32.t)) 
        (intP_intM_a1_0_10 : (memory voidP Int32.t)) : unit
         requires { true }
         ensures {
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 72 13 103#
           "expl:Ensures clause"
           (forall i : int.
            (forall j_0 : int.
             ((((<=) (0) i) /\
              (((<=) i (Int32.to_int n_2)) /\
              (((<=) (0) j_0) /\ ((<=) j_0 (Int32.to_int n_2))))) ->
              (count_saved a1_0_1 a2_0_1 i j_0 intP_intM_a2_0_11
              intP_intM_a1_0_10))))) }
  
end

module Function_sort_behaviors
#"/home/debian/mfsp/examples/auto-av/selsort.c" 170 5 24#
"expl:sort, behaviors"

  use import core.Voidp 
  
  use import core.Upd_unsafe 
  
  use Unsafe_uint64_of_Unsafe_int32 
  
  use Unsafe_uint64 
  
  use Unsafe_int32 
  
  use import core.Tag_table_type 
  
  use import Struct_intP_safe 
  
  use import Struct_intP 
  
  use import core.Shift_unsafe 
  
  use import core.Return 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_minimum 
  
  use import Logic_count_sum 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Function_count_frame_proof 
  
  use Function_count_frame2_proof 
  
  use Function_copy_array 
  
  use import Exceptions 
  
  use import Axiomatic_Ordered 
  
  use import Axiomatic_Count 
  
  use import core.Any_tag_table 
  
  use import core.Any_pointer 
  
  use import core.Any_memory 
  
  use import core.Any_alloc_table 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use import core.Acc_unsafe 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  let sort_ensures_default
  #"/home/debian/mfsp/examples/auto-av/selsort.c" 170 5 24#
  "expl:Function sort, default behavior" =
  fun
   (a_0 : (pointer voidP)) (n_12 : Int32.t) (intP_intM_a_16 : ref (memory
   voidP Int32.t)) (voidP_a_16_alloc_table : (alloc_table voidP))
   (voidP_a_16_tag_table : (tag_table voidP)) 
   requires {
   (((allocated voidP_a_16_alloc_table a_0) ->
     (((=) (typeof voidP_a_16_tag_table a_0) intP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_a_16_alloc_table a_0) i) /\
       ((<) i (offset_max voidP_a_16_alloc_table a_0))) ->
       ((=) (typeof voidP_a_16_tag_table (shift a_0 i)) intP_tag)))))
   /\
   (#"selsort_c.jc" 427 12 688#
   ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 163 11 17#
    (Int32.(>=) n_12 (#"selsort_c.jc" 427 31 43# "expl:Integer cast"
    (Int32.of_int (0)))))
   /\
   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 164 11 33#
   (if ((<=) (0) (Int.(-) (Int32.to_int n_12) (1))) then
    (((<=) (offset_min voidP_a_16_alloc_table a_0) (0)) /\
    (((>=) (offset_max voidP_a_16_alloc_table a_0)
     (Int.(-) (Int32.to_int n_12) (1)))
    /\
    (forall __framac_tmp7 : int.
     ((((<=) (0) __framac_tmp7) /\
      ((<=) __framac_tmp7 (Int.(-) (Int32.to_int n_12) (1)))) ->
      ((=) true true))))) else ((=) true true)))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
     "expl:Ensures clause"
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
     "expl:Ensures clause"
     ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
      "expl:Ensures clause"
      (ordered a_0 (0) (Int.(-) (Int32.to_int n_12) (1)) !intP_intM_a_16))
     /\
     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 166 10 44#
     "expl:Ensures clause"
     (count_saved a_0 a_0 (0) (Int32.to_int n_12) !intP_intM_a_16 (old
     !intP_intM_a_16))))))) } diverges  ->
   'Init:
   (let intP_intM_aLiter_30 = ref (any_memory  () : (memory voidP Int32.t))
   in
   (let voidP_aLiter_30_tag_table = ref
   (any_tag_table  () : (tag_table voidP)) in
   (let voidP_aLiter_30_alloc_table = ref
   (any_alloc_table  () : (alloc_table voidP)) in
   try
    begin
    (let i_0_1 = ref (Unsafe_int32.any_  () ) in
    (let min_pos = ref (Unsafe_int32.any_  () ) in
    (let j_0_0 = ref (Unsafe_int32.any_  () ) in
    (let aLiter = ref (any_pointer  () : (pointer voidP)) in
    (let tmp_0 = (any_pointer  () : (pointer voidP)) in
    (let tmp_1 = ref (Unsafe_int32.any_  () ) in
    try
     begin
     (i_0_1 :=
      (#"selsort_c.jc" 457 22 34# "expl:Integer cast"
      (Unsafe_int32.of_int (0))));
      'LoopEntry:
      begin
      'LoopEntry:
      'Loop_5:
      loop
      invariant
        { ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 173 23 43#
           (ordered a_0 (0) (Int.(-) (Int32.to_int !i_0_1) (1))
           !intP_intM_a_16))
          &&
          ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 174 23 56#
           ((Int32.(>) !i_0_1 (#"selsort_c.jc" 463 35 47# "expl:Integer cast"
            (Int32.of_int (0)))) ->
            (minimum a_0 (Int32.to_int !i_0_1) (Int32.to_int n_12)
            (Int.(-) (Int32.to_int !i_0_1) (1)) !intP_intM_a_16)))
          &&
          ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 175 23 57#
           (count_saved a_0 a_0 (0) (Int32.to_int n_12) !intP_intM_a_16 (at
           !intP_intM_a_16 'Init)))
          &&
          (#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 23 34#
          (#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 23 34#
          ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 23 29#
           (Int32.(<=) (#"selsort_c.jc" 471 38 50# "expl:Integer cast"
           (Int32.of_int (0))) !i_0_1))
          /\
          (#"/home/debian/mfsp/examples/auto-av/selsort.c" 176 28 34#
          (Int32.(<=) !i_0_1 n_12)))))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         'LoopCurrent:
         begin
         'LoopCurrent:
         (if
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 179 20 25#
         (Unsafe_int32.(<)  !i_0_1 n_12 )) then ()
         else (raise (Goto_while_0_break_0_exc ())));
          begin
          (min_pos := !i_0_1);
           try
            begin
            (j_0_0 :=
             (Unsafe_int32.(+)  !i_0_1
              (#"selsort_c.jc" 481 60 72# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) ));
             'LoopEntry:
             begin
             'LoopEntry:
             'Loop_6:
             loop
             invariant
               { ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 183 27 52#
                  (minimum a_0 (Int32.to_int !i_0_1) (Int32.to_int !j_0_0)
                  (Int32.to_int !min_pos) !intP_intM_a_16))
                 &&
                 ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 27 43#
                  (#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 27 43#
                  ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 27 39#
                   (Int32.(<=) !i_0_1 !min_pos))
                  /\
                  (#"/home/debian/mfsp/examples/auto-av/selsort.c" 184 32 43#
                  (Int32.(<) !min_pos n_12)))))
                 &&
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 27 42#
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 27 42#
                 ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 27 37#
                  ((<=) (Int.(+) (Int32.to_int !i_0_1) (1))
                  (Int32.to_int !j_0_0)))
                 /\
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 185 36 42#
                 (Int32.(<=) !j_0_0 n_12))))))) } 
              begin
              any unit requires { true } ensures { true } ;
               try
                begin
                'LoopCurrent:
                begin
                'LoopCurrent:
                (if
                (#"/home/debian/mfsp/examples/auto-av/selsort.c" 188 28 33#
                (Unsafe_int32.(<)  !j_0_0 n_12 )) then ()
                else (raise (Goto_while_1_break_0_exc ())));
                 (if
                 (#"/home/debian/mfsp/examples/auto-av/selsort.c" 189 16 33#
                 (Unsafe_int32.(<) 
                  (acc  !intP_intM_a_16
                   (shift_  a_0 (Unsafe_int32.to_int  !j_0_0 ) ) )
                  (acc  !intP_intM_a_16
                   (shift_  a_0 (Unsafe_int32.to_int  !min_pos ) ) ) ))
                 then (min_pos := !j_0_0) else ());
                 (j_0_0 :=
                  (Unsafe_int32.(+)  !j_0_0
                   (#"selsort_c.jc" 506 61 73# "expl:Integer cast"
                   (Unsafe_int32.of_int (1))) )) end;
                 (raise (Loop_continue_exc ())) end with Loop_continue_exc
                _jessie_10 -> () end end end;
              (raise (Goto_while_1_break_0_exc ())) end end with
            Goto_while_1_break_0_exc _jessie_7 ->
            'While_1_break_0: 'While_1_break_0: () end;
           (if
           (#"/home/debian/mfsp/examples/auto-av/selsort.c" 193 12 24#
           (Unsafe_int32.(<>)  !min_pos !i_0_1 ))
           then
            begin
            begin
            (assert {
            (#"/home/debian/mfsp/examples/auto-av/selsort.c" 194 23 106#
            "expl:Assertion in line 194"
            (forall p_8 : int.
             ((=)
             (count_sum a_0 (Int32.to_int !i_0_1) (Int32.to_int !min_pos)
             (Int32.to_int n_12) p_8 !intP_intM_a_16)
             (count_sum a_0 (Int32.to_int !i_0_1) (Int32.to_int !min_pos)
             (Int32.to_int n_12) p_8 !intP_intM_a_16)))) }); () end;
             begin
             (aLiter :=
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 195 38 64#
              "expl:Allocation size"
              (allocate_struct_intP 
               (Unsafe_uint64.to_int 
                (#"/home/debian/mfsp/examples/auto-av/selsort.c" 195 45 46#
                "expl:Integer cast"
                (Unsafe_uint64_of_Unsafe_int32.cast  n_12 )) )
               voidP_aLiter_30_alloc_table voidP_aLiter_30_tag_table )));
              begin
              (let _jessie_60 = a_0 in
              (let _jessie_59 = !aLiter in
              (let _jessie_58 = n_12 in
              (#"/home/debian/mfsp/examples/auto-av/selsort.c" 195 66 90#
              "expl:Precondition for copy_array"
              (Function_copy_array.copy_array  _jessie_60 _jessie_59
               _jessie_58 intP_intM_aLiter_30 !voidP_aLiter_30_alloc_table
               voidP_a_16_alloc_table !voidP_aLiter_30_tag_table
               voidP_a_16_tag_table !intP_intM_a_16 )))));
               begin
               (assert {
               (#"/home/debian/mfsp/examples/auto-av/selsort.c" 196 23 116#
               "expl:Assertion in line 196"
               (forall p_9 : int.
                ((=)
                (count_sum !aLiter (Int32.to_int !i_0_1)
                (Int32.to_int !min_pos) (Int32.to_int n_12) p_9
                !intP_intM_aLiter_30)
                (count_sum !aLiter (Int32.to_int !i_0_1)
                (Int32.to_int !min_pos) (Int32.to_int n_12) p_9
                !intP_intM_aLiter_30)))) }); () end;
               begin
               (let _jessie_63 = a_0 in
               (let _jessie_62 = !aLiter in
               (let _jessie_61 = n_12 in
               (#"/home/debian/mfsp/examples/auto-av/selsort.c" 197 24 56#
               "expl:Precondition for count_frame2_proof"
               (Function_count_frame2_proof.count_frame2_proof  _jessie_63
                _jessie_62 _jessie_61 !voidP_aLiter_30_alloc_table
                voidP_a_16_alloc_table !intP_intM_aLiter_30 !intP_intM_a_16 )))));
                begin
                (tmp_1 :=
                 (acc  !intP_intM_a_16
                  (shift_  a_0 (Unsafe_int32.to_int  !min_pos ) ) ));
                 begin
                 (let _jessie_66 =
                 (acc  !intP_intM_a_16
                  (shift_  a_0 (Unsafe_int32.to_int  !i_0_1 ) ) ) in
                 (let _jessie_67 = a_0 in
                 (let _jessie_68 = (Unsafe_int32.to_int  !min_pos ) in
                 (let _jessie_69 = (shift_  _jessie_67 _jessie_68 ) in
                 (upd  intP_intM_a_16 _jessie_69 _jessie_66 )))));
                  begin
                  (let _jessie_71 = !tmp_1 in
                  (let _jessie_72 = a_0 in
                  (let _jessie_73 = (Unsafe_int32.to_int  !i_0_1 ) in
                  (let _jessie_74 = (shift_  _jessie_72 _jessie_73 ) in
                  (upd  intP_intM_a_16 _jessie_74 _jessie_71 )))));
                   begin
                   (let _jessie_78 = a_0 in
                   (let _jessie_77 = !aLiter in
                   (let _jessie_76 =
                   (#"selsort_c.jc" 553 57 69# "expl:Integer cast"
                   (Unsafe_int32.of_int (0))) in
                   (let _jessie_75 = !i_0_1 in
                   (#"/home/debian/mfsp/examples/auto-av/selsort.c" 201 22 56#
                   "expl:Precondition for count_frame_proof"
                   (Function_count_frame_proof.count_frame_proof  _jessie_78
                    _jessie_77 _jessie_76 _jessie_75
                    !voidP_aLiter_30_alloc_table voidP_a_16_alloc_table
                    !intP_intM_aLiter_30 !intP_intM_a_16 ))))));
                    begin
                    (let _jessie_82 = a_0 in
                    (let _jessie_81 = !aLiter in
                    (let _jessie_80 =
                    (Unsafe_int32.(+)  !i_0_1
                     (#"selsort_c.jc" 556 68 80# "expl:Integer cast"
                     (Unsafe_int32.of_int (1))) ) in
                    (let _jessie_79 = !min_pos in
                    (#"/home/debian/mfsp/examples/auto-av/selsort.c" 202 22 66#
                    "expl:Precondition for count_frame_proof"
                    (Function_count_frame_proof.count_frame_proof  _jessie_82
                     _jessie_81 _jessie_80 _jessie_79
                     !voidP_aLiter_30_alloc_table voidP_a_16_alloc_table
                     !intP_intM_aLiter_30 !intP_intM_a_16 ))))));
                     begin
                     (let _jessie_86 = a_0 in
                     (let _jessie_85 = !aLiter in
                     (let _jessie_84 =
                     (Unsafe_int32.(+)  !min_pos
                      (#"selsort_c.jc" 560 68 80# "expl:Integer cast"
                      (Unsafe_int32.of_int (1))) ) in
                     (let _jessie_83 = n_12 in
                     (#"/home/debian/mfsp/examples/auto-av/selsort.c" 203 22 66#
                     "expl:Precondition for count_frame_proof"
                     (Function_count_frame_proof.count_frame_proof 
                      _jessie_86 _jessie_85 _jessie_84 _jessie_83
                      !voidP_aLiter_30_alloc_table voidP_a_16_alloc_table
                      !intP_intM_aLiter_30 !intP_intM_a_16 ))))));
                      begin
                      (assert {
                      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 204 23 172#
                      "expl:Assertion in line 204"
                      (forall p_10 : int.
                       (((=)
                        (count a_0 (Int32.to_int !min_pos)
                        (Int.(+) (Int32.to_int !min_pos) (1)) p_10
                        !intP_intM_a_16)
                        (count !aLiter (Int32.to_int !i_0_1)
                        (Int.(+) (Int32.to_int !i_0_1) (1)) p_10
                        !intP_intM_aLiter_30))
                       /\
                       ((=)
                       (count !aLiter (Int32.to_int !min_pos)
                       (Int.(+) (Int32.to_int !min_pos) (1)) p_10
                       !intP_intM_aLiter_30)
                       (count a_0 (Int32.to_int !i_0_1)
                       (Int.(+) (Int32.to_int !i_0_1) (1)) p_10
                       !intP_intM_a_16))))) }); () end;
                      begin
                      (assert {
                      (#"/home/debian/mfsp/examples/auto-av/selsort.c" 205 23 158#
                      "expl:Assertion in line 205"
                      (forall p_11 : int.
                       (((=)
                        (count a_0 (0) (Int32.to_int n_12) p_11
                        !intP_intM_a_16)
                        (count_sum a_0 (Int32.to_int !i_0_1)
                        (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                        !intP_intM_a_16))
                       /\
                       (((=)
                        (count_sum a_0 (Int32.to_int !i_0_1)
                        (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                        !intP_intM_a_16)
                        (count_sum !aLiter (Int32.to_int !i_0_1)
                        (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                        !intP_intM_aLiter_30))
                       /\
                       ((=)
                       (count_sum !aLiter (Int32.to_int !i_0_1)
                       (Int32.to_int !min_pos) (Int32.to_int n_12) p_11
                       !intP_intM_aLiter_30)
                       (count !aLiter (0) (Int32.to_int n_12) p_11
                       !intP_intM_aLiter_30)))))) }); () end end end end end
                 end end end end end end else ()) end;
          (i_0_1 :=
           (Unsafe_int32.(+)  !i_0_1
            (#"selsort_c.jc" 627 57 69# "expl:Integer cast"
            (Unsafe_int32.of_int (1))) )) end; (raise (Loop_continue_exc ()))
         end with Loop_continue_exc _jessie_12 -> () end end end;
       (raise (Goto_while_0_break_0_exc ())) end end with
     Goto_while_0_break_0_exc _jessie_8 ->
     'While_0_break_0: 'While_0_break_0: begin (); (raise Return) end end))))));
     (raise Return) end with Return -> () end)))
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_charP

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import core.Tag_table 
  
  use import Struct_voidP 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Alloc_table 
  
  use import core.Alloc 
  
  use why3.Bool.Bool 
  
  use import core.Charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (n : int)
  (voidP_tag_table : (tag_table voidP))
  = (fresh_tag_struct_voidP p n voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p n voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate strict_left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (strict_left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_charP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_charP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_charP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_charP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (0) (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (0) (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import int.Int 
  
  use import core.Allocable 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_voidP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_voidP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use int.Int 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      (fresh_alloc_struct_voidP p (offset_max (old !voidP_alloc_table) p)
      !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (Int.(-) n (1)) (old
        !voidP_alloc_table))
       /\
       ((fresh_tag_struct_voidP result (Int.(-) n (1)) (old
        !voidP_tag_table))
       /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (0) (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (0) (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

theory Axiomatic_Memory_reinterpretation_predicates

  use Uint8_of_Int8 
  
  use enum.Uint8 
  
  use Uint32_of_Int32 
  
  use enum.Uint32 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use int.ComputerDivision 
  
  use enum.Bit_uint8_of_bit_uint32 
  
  use enum.Bit_uint8_of_bit_int32 
  
  use enum.Bit_uint32_of_bit_uint8 
  
  use enum.Bit_int8_of_bit_int32 
  
  use enum.Bit_int32_of_bit_uint8 
  
  use enum.Bit_int32_of_bit_int8 
  
  use why3.Bool.Bool 
  
  predicate uint32_as_uint8 (d0_1 : Uint32.t) (a0_1 : Uint8.t) (a1_1 :
  Uint8.t) (a2_1 : Uint8.t) (a3_1 : Uint8.t)
  =
     (((=) (Uint8.to_int a0_1)
      (ComputerDivision.mod (Uint32.to_int d0_1) (256)))
     /\
     ((let d1 = (ComputerDivision.div (Uint32.to_int d0_1) (256)) in
       (((=) (Uint8.to_int a1_1) (ComputerDivision.mod d1 (256))) /\
       (let d2 = (ComputerDivision.div d1 (256)) in
        (((=) (Uint8.to_int a2_1) (ComputerDivision.mod d2 (256))) /\
        (let d3 = (ComputerDivision.div d2 (256)) in
         ((=) (Uint8.to_int a3_1) d3))))))
     /\
     (Bit_uint8_of_bit_uint32.bit_uint32_as_bit_uint8 d0_1 a0_1 a1_1 a2_1
     a3_1)))
  
  
  function complement_to_uint32 (v : Int32.t) : Uint32.t
  =
     (if ((>=) (Int32.to_int v) (0)) then (#"selsort_c.jc" 15 20 33#
      "expl:Integer cast" (Uint32_of_Int32.cast v)) else
      (#"selsort_c.jc" 15 39 80# "expl:Integer cast"
      (Uint32.of_int (Int.(+) (Int32.to_int v) (4294967296)))))
  
  
  predicate int32_as_uint8 (d0_2 : Int32.t) (a3_2 : Uint8.t) (a2_2 : Uint8.t)
  (a1_2 : Uint8.t) (a0_2 : Uint8.t)
  =
     ((uint32_as_uint8 (complement_to_uint32 d0_2) a3_2 a2_2 a1_2 a0_2) /\
     (Bit_uint8_of_bit_int32.bit_int32_as_bit_uint8 d0_2 a3_2 a2_2 a1_2 a0_2))
  
  
  function complement_to_uint8 (v_0 : Int8.t) : Uint8.t
  =
     (if ((>=) (Int8.to_int v_0) (0)) then (#"selsort_c.jc" 34 20 32#
      "expl:Integer cast" (Uint8_of_Int8.cast v_0)) else
      (#"selsort_c.jc" 34 38 71# "expl:Integer cast"
      (Uint8.of_int (Int.(+) (Int8.to_int v_0) (256)))))
  
  
  predicate int32_as_int8 (d0_4 : Int32.t) (a3_4 : Int8.t) (a2_4 : Int8.t)
  (a1_4 : Int8.t) (a0_4 : Int8.t)
  =
     ((int32_as_uint8 d0_4 (complement_to_uint8 a3_4)
      (complement_to_uint8 a2_4) (complement_to_uint8 a1_4)
      (complement_to_uint8 a0_4))
     /\
     (Bit_int8_of_bit_int32.bit_int32_as_bit_int8 d0_4 a3_4 a2_4 a1_4 a0_4))
  
  
  predicate uint8_as_uint32 (d0 : Uint32.t) (a0 : Uint8.t) (a1 : Uint8.t) (a2
  : Uint8.t) (a3 : Uint8.t)
  =
     (((=) (Uint32.to_int d0)
      (Int.(+)
      (Int.( *)
      (Int.(+)
      (Int.( *)
      (Int.(+) (Int.( *) (Uint8.to_int a3) (256)) (Uint8.to_int a2)) (256))
      (Uint8.to_int a1)) (256)) (Uint8.to_int a0)))
     /\ (Bit_uint32_of_bit_uint8.bit_uint8_as_bit_uint32 d0 a0 a1 a2 a3))
  
  
  predicate uint8_as_int32 (d0_0 : Int32.t) (a3_0 : Uint8.t) (a2_0 : Uint8.t)
  (a1_0 : Uint8.t) (a0_0 : Uint8.t)
  =
     ((uint8_as_uint32 (complement_to_uint32 d0_0) a3_0 a2_0 a1_0 a0_0) /\
     (Bit_int32_of_bit_uint8.bit_uint8_as_bit_int32 d0_0 a3_0 a2_0 a1_0 a0_0))
  
  
  predicate int8_as_int32 (d0_3 : Int32.t) (a3_3 : Int8.t) (a2_3 : Int8.t)
  (a1_3 : Int8.t) (a0_3 : Int8.t)
  =
     ((uint8_as_int32 d0_3 (complement_to_uint8 a3_3)
      (complement_to_uint8 a2_3) (complement_to_uint8 a1_3)
      (complement_to_uint8 a0_3))
     /\
     (Bit_int32_of_bit_int8.bit_int8_as_bit_int32 d0_3 a3_3 a2_3 a1_3 a0_3))
  
  
end

module Function_sort

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use int.Int 
  
  use import Axiomatic_Ordered 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val sort
  (a_0 : (pointer voidP)) 
   (n_12 : Int32.t) 
    (intP_intM_a_16 : ref (memory voidP Int32.t)) 
     (voidP_a_16_alloc_table : (alloc_table voidP)) 
      (voidP_a_16_tag_table : (tag_table voidP)) : unit
       requires { true } reads { intP_intM_a_16 } writes { intP_intM_a_16 }
       ensures {
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
         "expl:Ensures clause"
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
         "expl:Ensures clause"
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
          "expl:Ensures clause"
          (ordered a_0 (0) (Int.(-) (Int32.to_int n_12) (1)) !intP_intM_a_16))
         /\
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 166 10 44#
         "expl:Ensures clause"
         (count_saved a_0 a_0 (0) (Int32.to_int n_12) !intP_intM_a_16 (old
         !intP_intM_a_16)))))) }
  
end

module Function_sort_safe

  use import core.Voidp 
  
  use import core.Tag_table_type 
  
  use import ref.Ref 
  
  use import core.Pointer 
  
  use import core.Memory 
  
  use import Logic_count_saved 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Axiomatic_Ordered 
  
  use import core.Alloc_table 
  
  use why3.Bool.Bool 
  
  use import Lemma_count_splitted 
  
  use import Lemma_count_saved_trans 
  
  use import Lemma_count_saved_refl 
  
  use import Lemma_count_saved_comm 
  
  val sort
  (a_0 : (pointer voidP)) 
   (n_12 : Int32.t) 
    (intP_intM_a_16 : ref (memory voidP Int32.t)) 
     (voidP_a_16_alloc_table : (alloc_table voidP)) 
      (voidP_a_16_tag_table : (tag_table voidP)) : unit
       requires {
         ("expl:Internal"
         (#"selsort_c.jc" 427 12 688# "expl:Requires clause"
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 163 11 17#
          "expl:Requires clause"
          (Int32.(>=) n_12 (#"selsort_c.jc" 427 31 43# "expl:Integer cast"
          (Int32.of_int (0)))))
         /\
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 164 11 33#
         "expl:Requires clause"
         (if ((<=) (0) (Int.(-) (Int32.to_int n_12) (1))) then
          (((<=) (offset_min voidP_a_16_alloc_table a_0) (0)) /\
          (((>=) (offset_max voidP_a_16_alloc_table a_0)
           (Int.(-) (Int32.to_int n_12) (1)))
          /\
          (forall __framac_tmp7 : int.
           ((((<=) (0) __framac_tmp7) /\
            ((<=) __framac_tmp7 (Int.(-) (Int32.to_int n_12) (1)))) ->
            ((=) true true))))) else ((=) true true)))))) }
       reads { intP_intM_a_16 } writes { intP_intM_a_16 }
       ensures {
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
         "expl:Ensures clause"
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
         "expl:Ensures clause"
         ((#"/home/debian/mfsp/examples/auto-av/selsort.c" 165 10 30#
          "expl:Ensures clause"
          (ordered a_0 (0) (Int.(-) (Int32.to_int n_12) (1)) !intP_intM_a_16))
         /\
         (#"/home/debian/mfsp/examples/auto-av/selsort.c" 166 10 44#
         "expl:Ensures clause"
         (count_saved a_0 a_0 (0) (Int32.to_int n_12) !intP_intM_a_16 (old
         !intP_intM_a_16)))))) }
  
end
