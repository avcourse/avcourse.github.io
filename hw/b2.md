---
title: "Практикум -- задание №2"
---

Это задание состоит из 2-х частей. Нужно выполнить все части.

## Задание 2.1

При помощи Why3 и солверов докажите, что для любого
целого неотрицательного <code>n</code> значение выражения
<code>2<sup>3n</sup> - 3<sup>n</sup></code> делится
без остатка на 5. Использовать циклы нельзя. Для этого:

   1. Определите функцию взятия в степень, которая будет
      использоваться только в спецификациях.

   2. Запишите let-функцию со спецификацией, чтобы из
      полной корректности этой пары следовало требуемое утверждение.

   3. Докажите требуемое утверждение <<на листочке>>.

   4. Если нужно, можете добавить функций и лемм.

   5. Результат вашей работы -- это архив
      следующего состава: файл на языке WhyML, сессия доказательства.

_Прагматика_ Это задание знакомит вас с языком WhyML, с
доказательством полной корректности рекурсивных функций.

## Задание 2.2

Реализуйте алгоритм <<Решето Эратосфена>> и докажите
полную корректность своей реализации. Для этого:

   1. Опишите тип-символ для множества
      целых чисел, необходимые функциональные и
      предикатные символы для спецификации
      алгоритма. Опишите аксиомы для символов.
      Опишите val-примитивы для let-функций, оперирующих
      с множествами целых чисел. Множество этих
      примитивов должно быть минимальным, т.е.
      никакой примитив нельзя определить в виде
      let-функции через остальные примитивы.

   2. Опишите let-функцию, получающую целое
      положительное число и возвращающую множество
      всех простых чисел, не превышающих этого числа.
      Опишите ее спецификацию. В let-функции нельзя
      использовать функциональные и предикатные
      символы с предыдущего шага.

   3. Докажите полную корректность своей let-функции
      относительно ее спецификации. При необходимости
      добавляйте леммы и лемма-функции.

   4. Результат вашей работы -- это архив
      следующего состава: файл на языке WhyML, сессия доказательства.

_Прагматика_ Это задание позволяет отработать спецификацию
логических символов и отработать методы Флойда на
более сложной модели программы.
