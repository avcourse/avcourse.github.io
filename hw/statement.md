# Домашние задания

## Домашнее задание №1

1. Установите инструменты Frama-C, Why3, AstraVer и солверы
   согласно [инструкции](https://forge.ispras.ru/projects/astraver/wiki).
2. Познакомьтесь с языком Why3 по [этому документу](http://why3.lri.fr/manual.pdf).
3. Ниже описаны программы `P1` и `P2` и требования `T1` и `T2`.

   1. Промоделируйте (на листочке) программы `P1` и `P2` в виде блок-схем.
      Все переменные блок-схем должны иметь домен всех целых чисел.
   2. Промоделируйте (на листочке) требования `T1` и `T2` в виде предусловий
      и постусловий.
   3. Определите все пары программ и требований, которые находятся в отношении
      частичной корректности. Докажите эти факты (на листочке).
   4. Определите все пары программ и требований, которые находятся в отношении
      полной корректности. Докажите эти факты (на листочке).
   5. Оформите каждое доказательство в виде теории Why3. Цель теории -- доказать
      нужное отношение соответствия. Результат вашей работы -- это архив
      следующего состава: файл со всеми теориями, сессия доказательства всех
      теорий, фото блок-схем и фото доказательств с листочка.
      В начале файла с теориями поместите комментарий, обосновывающий
      отсутствие частичной корректности и полной корректности для всех пар
      программ и требований, не включенных в файл.

Входом _Программы P1_ являются три целых числа, выходом -- одно число.
Программа отнимает от первого числа третье и затем прибавляет к полученному
второе число. Так получается выходное число.
Все вычисления делаются в машинной арифметике в целых числах от -128 до 127.
Сумма и вычитание -- это бинарные операции над такими
целыми числами, их результаты -- такие же числа. Операции не определены для
случая переполнения (блок-схема зацикливается при переполнении).

Входы и выходы _Программы Р2_ те же, что и у _Программа Р1_. Ее цель --
вычислить то же выражение. Она сравнивает значения входных чисел и выбирает
такой порядок суммы и вычитания, чтобы не случилось переполнение всегда,
когда лишь результат всего искомого
выражения представим данными целыми числами. Попробуйте самостоятельно
составить такую программу. Она использует ту же машинную арифметику, что и
_Программа Р1_.

_Требования Т1_ применимы к программам с тремя входными переменными
(назовем их _x1_, _x2_, _x3_) и одной выходной переменной. Домены всех
переменных -- множество всех целых чисел. Программа должна вычислять
значение выражения _x1_ + _x2_ - _x3_.
Программа не должна зацикливаться или вычислять другое значение, если
значение выражений _x1_ - _x3_ и _x1_ + _x2_ - _x3_ представимы
в типе указанных выше ограниченных целых чисел.

_Требования Т2_ применимы к программам с тремя входными переменными
(назовем их _x1_, _x2_, _x3_) и одной выходной переменной. Домены всех
переменных -- множество всех целых чисел. Программа вычисляет значение
выражения _x1_ + _x2_ - _x3_.
Программа не должна зацикливаться или вычислять другое значение, если
значение выражения _x1_ + _x2_ - _x3_ представимо
в типе указанных выше ограниченных целых чисел.

_Прагматика_ Эта домашняя работа знакомит вас со средой верификации,
которой вы будете пользоваться в дальнейшем для верификации Си-программ.
Конкретнее, по Си-программе и спецификации к ней будут строиться
утверждения, означающие правильность программы. Утверждения будут
строиться на языке Why3 и доказываться в среде Why3 IDE. Знание этого
языка вам потребуется, чтобы читать и понимать утверждения, которые
будут генерировать инструменты верификации. Среда Why3 IDE дает
возможность использовать сразу несколько солверов для верификации. Они
отличаются языками, на которых нужно записывать доказываемые утверждения,
способами запуска и управления. Разобраться со всеми этими отличиями
берет на себя среда Why3 IDE. Вам она предоставляет унифицированный
интерфейс управления солверами и единый язык (Why3), который она сама
будет транслировать во входные языки солверов.

## Домашнее задание №2

1. Вам дана блок-схема и спецификация к ней [pdf](hw2.pdf). При помощи метода индуктивных утверждений докажите частичную корректность этой блок-схемы относительно этой спецификации. Результатом вашей работы будет архив с теорией Why3, где каждое условие верификации будет отдельной целью, и сессией доказательства. В начале файла с теорией в комментарии укажите все точки сечения. Индуктивные утверждения оформите в виде предикатов.

_Прагматика_ Эта домашняя работа позволяет отработать метод индуктивных утверждений. Он потребуется вам, чтобы верифицировать Си-программы с циклами.

## Домашнее задание №3

1. Вам дана блок-схема и спецификация к ней [pdf](hw3.pdf). При помощи метода фундированных множеств докажите завершаемость этой блок-схемы относительно этой спецификации. Результатом вашей работы будет архив с теорией Why3, где каждое условие верификации, корректности, завершимости будет отдельной целью, и сессией доказательства. В начале файла с теорией в комментарии укажите все точки сечения. Фундированное множество, индуктивные утверждения и оценочные функции оформите соответствующим способом. Не забудьте доказать фундированность множества (это тоже будут цели).

_Прагматика_ Эта домашняя работа позволяет отработать метод фундированных множеств. Он потребуется вам, чтобы доказывать завершаемость Си-программ с циклами.

## Домашнее задание №4

1. Вам дан исходный модуль на языке Си [hw4.c](hw4.c). В нем описано представление орграфов и функция подсчёта кратность дуги `count`. Функция снабжена формальной спецификацией требований к ней на языке `ACSL`. Дополните функцию необходимыми комментариями, чтобы наша связка инструментов доказывала ее полную корректность относительно ее спецификации.

_Прагматика_ Эта домашняя работа знакомит вас с языком спецификации Си-программ `ACSL` и тем, как при помощи него формулировать требования и добавлять всё необходимое для применения методов Флойда. Инструменты `Frama-C` и `AstraVer` построят модели, построят все необходимые условия в методах Флойда и запустят среду Why3 IDE, чтобы можно было доказать сгенерированные условия.

## Домашнее задание №5

1. Вы продолжаете работать с орграфами. На этот раз вы верифицируете функцию добавления дуги `add_edge`. Дополните исходный модуль [hw5.c](hw5.c) необходимыми комментариями, чтобы наша связка инструментов доказывала полную корректность функции `add_edge` и все остальные генерируемые условия.

_Прагматика_ Эта домашняя работа позволяет попробовать свои силы в верификации Си-программы с массивами. Очень многие Си-программы имеют дело с указателями и массивами.

## Домашнее задание №6

1. По сравнению с предыдущим домашним заданием изменилось только определение функционального символа `count`. В остальном задание то же. Дополните исходный модуль [hw6.c](hw6.c) необходимыми комментариями, чтобы наша связка инструментов доказывала полную корректность функции `add_edge` и все остальные генерируемые условия.

_Прагматика_ Эта домашняя работа позволяет отработать способ доказательства утверждений по индукции при помощи SMT-солверов, которые сами не умеют доказывать утверждения по индукции. Для этого вы будете использовать технику `auto-active verification`. Это очень важная и полезная техника, которая обязательно пригодится при выполнении практического задания. В этом задании вы можете отработать эту технику на маленьком примере.

## Домашнее задание №7

1. По сравнению с предыдущим домашним заданием лишь добавилось 1 новое требование к функции `add_edge`. В остальном задание то же. Дополните исходный модуль [hw7.c](hw7.c) необходимыми комментариями, чтобы наша связка инструментов доказывала полную корректность функции `add_edge` и все остальные генерируемые условия.

_Прагматика_ Эта домашняя работа нацелена показать, что в реальных случаях размеры условий верификации, которые приходится доказывать SMT-солверам, получаются большими. Причем далеко не все составные части условия верификации действительно нужны при этом. Особенно актуально это для доказательства тех условий верификации, для которых нельзя применить технику из предыдущей домашней работы, т.к. условие верификации нельзя записать на языке `ACSL`. Вам нужно научиться убирать ненужное из условия верификации и добавлять нужное. Этот навык обязательно пригодится при выполнении практического задания, и здесь вы можете отработать его на маленьком примере.
