# Домашние задания

## Домашнее задание №1

1. Установите инструменты Frama-C, Why3, AstraVer и солверы
   согласно [инструкции](https://forge.ispras.ru/projects/astraver/wiki).
2. Познакомьтесь с языком Why3 по [этому документу](http://why3.lri.fr/manual.pdf).
3. Ниже описаны программы `P1` и `P2` и требования `T1` и `T2`.

   1. Промоделируйте (на листочке) программы `P1` и `P2` в виде блок-схем.
      Все переменные блок-схем должны иметь домен всех целых чисел.
   2. Промоделируйте (на листочке) требования `T1` и `T2` в виде предусловий
      и постусловий.
   3. Определите все пары программ и требований, которые находятся в отношении
      частичной корректности. Докажите эти факты (на листочке).
   4. Определите все пары программ и требований, которые находятся в отношении
      полной корректности. Докажите эти факты (на листочке).
   5. Оформите каждое доказательство в виде теории Why3. Цель теории -- доказать
      нужное отношение соответствия. Результат вашей работы -- это архив
      следующего состава: файл со всеми теориями, сессия доказательства всех
      теорий, фото блок-схем и фото доказательств с листочка.
      В начале файла с теориями поместите комментарий, обосновывающий
      отсутствие частичной корректности и полной корректности для всех пар
      программ и требований, не включенных в файл.

Входом _Программы P1_ являются три целых числа, выходом -- одно число.
Программа отнимает от первого числа третье и затем прибавляет к полученному
второе число. Так получается выходное число.
Все вычисления делаются в машинной арифметике в целых числах от -128 до 127.
Сумма и вычитание -- это бинарные операции над такими
целыми числами, их результаты -- такие же числа. Операции не определены для
случая переполнения (блок-схема зацикливается при переполнении).

Входы и выходы _Программы Р2_ те же, что и у _Программа Р1_. Ее цель --
вычислить то же выражение. Она сравнивает значения входных чисел и выбирает
такой порядок суммы и вычитания, чтобы не случилось переполнение всегда,
когда лишь результат всего искомого
выражения представим данными целыми числами. Попробуйте самостоятельно
составить такую программу. Она использует ту же машинную арифметику, что и
_Программа Р1_.

_Требования Т1_ применимы к программам с тремя входными переменными
(назовем их _x1_, _x2_, _x3_) и одной выходной переменной. Домены всех
переменных -- множество всех целых чисел. Программа должна вычислять
значение выражения _x1_ + _x2_ - _x3_.
Программа не должна зацикливаться или вычислять другое значение, если
значение выражений _x1_ - _x3_ и _x1_ + _x2_ - _x3_ представимы
в типе указанных выше ограниченных целых чисел.

_Требования Т2_ применимы к программам с тремя входными переменными
(назовем их _x1_, _x2_, _x3_) и одной выходной переменной. Домены всех
переменных -- множество всех целых чисел. Программа вычисляет значение
выражения _x1_ + _x2_ - _x3_.
Программа не должна зацикливаться или вычислять другое значение, если
значение выражения _x1_ + _x2_ - _x3_ представимо
в типе указанных выше ограниченных целых чисел.

_Прагматика_ Эта домашняя работа знакомит вас со средой верификации,
которой вы будете пользоваться в дальнейшем для верификации Си-программ.
Конкретнее, по Си-программе и спецификации к ней будут строиться
утверждения, означающие правильность программы. Утверждения будут
строиться на языке Why3 и доказываться в среде Why3 IDE. Знание этого
языка вам потребуется, чтобы читать и понимать утверждения, которые
будут генерировать инструменты верификации. Среда Why3 IDE дает
возможность использовать сразу несколько солверов для верификации. Они
отличаются языками, на которых нужно записывать доказываемые утверждения,
способами запуска и управления. Разобраться со всеми этими отличиями
берет на себя среда Why3 IDE. Вам она предоставляет унифицированный
интерфейс управления солверами и единый язык (Why3), который она сама
будет транслировать во входные языки солверов.

## Домашнее задание №2

Вам дана блок-схема и спецификация к ней [pdf](hw2.pdf). При помощи
метода индуктивных утверждений докажите частичную корректность этой
блок-схемы относительно этой спецификации. Результатом вашей работы будет
такой же архив, как и в Домашнем задании №1. На фото блок-схемы укажите
точки сечения. Индуктивные утверждения оформите в виде предикатов.

_Прагматика_ Эта домашняя работа позволяет отработать метод индуктивных
утверждений. Он потребуется вам, чтобы верифицировать Си-программы с циклами.

## Домашнее задание №3

Вам дана блок-схема и спецификация к ней [pdf](hw3.pdf). При помощи
метода фундированных множеств докажите завершаемость этой блок-схемы
относительно этой спецификации. Результатом вашей работы будет такой же архив,
как и в Домашнем задании №1. На фото блок-схемы укажите точки сечения.
Фундированное множество, индуктивные утверждения и оценочные функции
оформите соответствующим способом в файле с теориями. Не забудьте доказать
фундированность множества (это тоже будут цели).

_Прагматика_ Эта домашняя работа позволяет отработать метод фундированных
множеств. Он потребуется вам, чтобы доказывать завершаемость Си-программ
с циклами.

## Домашнее задание №4

Вам дан исходный модуль на языке Си [hw4.c](hw4.c). Вам надо дополнить его
спецификацией функции `search` и всеми необходимыми комментариями для
доказательства её полной корректности. Изменять определение функции нельзя.
Вам надо доказать полную корректность при помощи нашей связки инструментов.
Результат вашей работы -- это архив с исходным модулем и всеми файлами и
директориями, которые создаст связка инструментов после успешного
доказательства.

Функция `search` получает на вход массив `a` из целых чисел. Размер массива передается
в параметре `n`. Функция должна найти в массиве заданное ненулевое число `x`
и возвратить индекс любого из вхождений этого числа, если оно встречается
в массиве, и некоторое отрицательное число, если оно не встречается в массиве.
В этом массиве за двумя подряд идущими
нулями остальные элементы равны 0. Это используется в реализации функции.
Причем в этом массиве должны быть два подряд элемента, равные нулю.

_Прагматика_ Эта домашняя работа знакомит вас с языком спецификации
Си-программ `ACSL` и тем, как при помощи него формулировать требования и
добавлять всё необходимое для применения методов Флойда. Инструменты `Frama-C`
и `AstraVer` построят модели, построят все необходимые условия в методах
Флойда и запустят среду Why3 IDE, чтобы можно было доказать сгенерированные
условия.

## Домашнее задание №5

Вам даны два исходных модуля на языке Си [hw5_impl1.c](hw5_impl1.c) и
[hw5_impl2.c](hw5_impl2.c) и заголовочный файл [hw5.h](hw5.h). В исходных
модулях реализована двумя способами одна и та же функция `defragment`.
В заголовочном файле находится прототип функции `defragment`. Вам надо
дополнить заголовочный файл спецификацией функции `defragment`. Затем
доказать полную корректность обеих реализаций относительно этой спецификации
при помощи нашей связки инструментов. Для этого вам надо дополнить исходные
модули всеми необходимыми комментариями для доказательства. Изменять
реализации функций нельзя.
Результат вашей работы -- это архив с исходными модулями, заголовочным файлом
и всеми файлами и директориями, которые создаст связка инструментов после
успешного доказательства.

Функция `defragment` получает на вход массив `a` из целых чисел. Размер
массива передается в параметре `n`.
В этом массиве за двумя подряд идущими
нулями остальные элементы равны 0.
Причем в этом массиве должны быть два подряд элемента, равные нулю.
Функция должна поменять местами в массиве один из ненулевых элементов
и один из идущих перед ним нулевых элементов. Если такой пары
элементов не существует, функция не меняет массив и возвращает 0. Иначе
она переставляет только эти элементы, возвращает значение ненулевого
элемента. Еще у функции есть параметры `from` и `to`. Каждый из них
должен указывать на некоторую память. В эту память функция записывает индекс:
`from` -- это первоначальный индекс ненулевого элемента, `to` -- это
финальный индекс ненулевого элемента.
Итоговый массив должен удовлетворять исходному правилу: за двумя подряд
идущими нулями остальные элементы равны 0, причем эти два нулевых элемента
действительно встречаются в массиве.

_Прагматика_ Эта домашняя работа позволяет попробовать свои силы в верификации
Си-программы с указателями и массивами. Очень многие Си-программы имеют с ними
дело.

## Домашнее задание №14

1. Вам дан исходный модуль на языке Си [hw14.c](hw14.c). В нем описано
представление орграфов и функция подсчёта кратность дуги `count`. Функция
снабжена формальной спецификацией требований к ней на языке `ACSL`.
Дополните функцию необходимыми комментариями, чтобы наша связка инструментов
доказывала ее полную корректность относительно ее спецификации.

## Домашнее задание №15

Вы продолжаете работать с орграфами. На этот раз вы верифицируете функцию
добавления дуги `add_edge`. Дополните исходный модуль [hw15.c](hw15.c)
необходимыми комментариями, чтобы наша связка инструментов доказывала
полную корректность функции `add_edge` и все остальные генерируемые условия.

## Домашнее задание №16

По сравнению с предыдущим домашним заданием изменилось только определение
функционального символа `count`. В остальном задание то же. Дополните
исходный модуль [hw16.c](hw16.c) необходимыми комментариями, чтобы наша связка
инструментов доказывала полную корректность функции `add_edge` и все остальные
генерируемые условия.

_Прагматика_ Эта домашняя работа позволяет отработать способ доказательства
утверждений по индукции при помощи SMT-солверов, которые сами не умеют
доказывать утверждения по индукции. Для этого вы будете использовать технику
`auto-active verification`. Это очень важная и полезная техника, которая
обязательно пригодится при выполнении практического задания. В этом задании
вы можете отработать эту технику на маленьком примере.

## Домашнее задание №17

1. По сравнению с предыдущим домашним заданием лишь добавилось 1 новое требование к функции `add_edge`. В остальном задание то же. Дополните исходный модуль [hw7.c](hw7.c) необходимыми комментариями, чтобы наша связка инструментов доказывала полную корректность функции `add_edge` и все остальные генерируемые условия.

_Прагматика_ Эта домашняя работа нацелена показать, что в реальных случаях размеры условий верификации, которые приходится доказывать SMT-солверам, получаются большими. Причем далеко не все составные части условия верификации действительно нужны при этом. Особенно актуально это для доказательства тех условий верификации, для которых нельзя применить технику из предыдущей домашней работы, т.к. условие верификации нельзя записать на языке `ACSL`. Вам нужно научиться убирать ненужное из условия верификации и добавлять нужное. Этот навык обязательно пригодится при выполнении практического задания, и здесь вы можете отработать его на маленьком примере.
